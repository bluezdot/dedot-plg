// Generated by dedot cli

import type {
  GenericChainErrors,
  GenericPalletError,
  RpcVersion,
} from "dedot/types";

export interface ChainErrors<Rv extends RpcVersion>
  extends GenericChainErrors<Rv> {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError<Rv>;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError<Rv>;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError<Rv>;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError<Rv>;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError<Rv>;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError<Rv>;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError<Rv>;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Babe`'s errors
   **/
  babe: {
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Submitted configuration is invalid.
     **/
    InvalidConfiguration: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Indices`'s errors
   **/
  indices: {
    /**
     * The index was not already assigned.
     **/
    NotAssigned: GenericPalletError<Rv>;

    /**
     * The index is assigned to another account.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * The index was not available.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * The source and destination accounts are identical.
     **/
    NotTransfer: GenericPalletError<Rv>;

    /**
     * The index is permanent and may not be freed/changed.
     **/
    Permanent: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError<Rv>;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError<Rv>;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError<Rv>;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError<Rv>;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError<Rv>;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError<Rv>;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError<Rv>;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError<Rv>;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError<Rv>;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError<Rv>;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError<Rv>;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ElectionProviderMultiPhase`'s errors
   **/
  electionProviderMultiPhase: {
    /**
     * Submission was too early.
     **/
    PreDispatchEarlySubmission: GenericPalletError<Rv>;

    /**
     * Wrong number of winners presented.
     **/
    PreDispatchWrongWinnerCount: GenericPalletError<Rv>;

    /**
     * Submission was too weak, score-wise.
     **/
    PreDispatchWeakSubmission: GenericPalletError<Rv>;

    /**
     * The queue was full, and the solution was not better than any of the existing ones.
     **/
    SignedQueueFull: GenericPalletError<Rv>;

    /**
     * The origin failed to pay the deposit.
     **/
    SignedCannotPayDeposit: GenericPalletError<Rv>;

    /**
     * Witness data to dispatchable is invalid.
     **/
    SignedInvalidWitness: GenericPalletError<Rv>;

    /**
     * The signed submission consumes too much weight
     **/
    SignedTooMuchWeight: GenericPalletError<Rv>;

    /**
     * OCW submitted solution for wrong round
     **/
    OcwCallWrongEra: GenericPalletError<Rv>;

    /**
     * Snapshot metadata should exist but didn't.
     **/
    MissingSnapshotMetadata: GenericPalletError<Rv>;

    /**
     * `Self::insert_submission` returned an invalid index.
     **/
    InvalidSubmissionIndex: GenericPalletError<Rv>;

    /**
     * The call is not allowed at this point.
     **/
    CallNotAllowed: GenericPalletError<Rv>;

    /**
     * The fallback failed
     **/
    FallbackFailed: GenericPalletError<Rv>;

    /**
     * Some bound not met
     **/
    BoundNotMet: GenericPalletError<Rv>;

    /**
     * Submitted solution has too many winners
     **/
    TooManyWinners: GenericPalletError<Rv>;

    /**
     * Sumission was prepared for a different round.
     **/
    PreDispatchDifferentRound: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Staking`'s errors
   **/
  staking: {
    /**
     * Not a controller account.
     **/
    NotController: GenericPalletError<Rv>;

    /**
     * Not a stash account.
     **/
    NotStash: GenericPalletError<Rv>;

    /**
     * Stash is already bonded.
     **/
    AlreadyBonded: GenericPalletError<Rv>;

    /**
     * Controller is already paired.
     **/
    AlreadyPaired: GenericPalletError<Rv>;

    /**
     * Targets cannot be empty.
     **/
    EmptyTargets: GenericPalletError<Rv>;

    /**
     * Duplicate index.
     **/
    DuplicateIndex: GenericPalletError<Rv>;

    /**
     * Slash record index out of bounds.
     **/
    InvalidSlashIndex: GenericPalletError<Rv>;

    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     **/
    InsufficientBond: GenericPalletError<Rv>;

    /**
     * Can not schedule more unlock chunks.
     **/
    NoMoreChunks: GenericPalletError<Rv>;

    /**
     * Can not rebond without unlocking chunks.
     **/
    NoUnlockChunk: GenericPalletError<Rv>;

    /**
     * Attempting to target a stash that still has funds.
     **/
    FundedTarget: GenericPalletError<Rv>;

    /**
     * Invalid era to reward.
     **/
    InvalidEraToReward: GenericPalletError<Rv>;

    /**
     * Invalid number of nominations.
     **/
    InvalidNumberOfNominations: GenericPalletError<Rv>;

    /**
     * Items are not sorted and unique.
     **/
    NotSortedAndUnique: GenericPalletError<Rv>;

    /**
     * Rewards for this era have already been claimed for this validator.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * No nominators exist on this page.
     **/
    InvalidPage: GenericPalletError<Rv>;

    /**
     * Incorrect previous history depth input provided.
     **/
    IncorrectHistoryDepth: GenericPalletError<Rv>;

    /**
     * Incorrect number of slashing spans provided.
     **/
    IncorrectSlashingSpans: GenericPalletError<Rv>;

    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     **/
    BadState: GenericPalletError<Rv>;

    /**
     * Too many nomination targets supplied.
     **/
    TooManyTargets: GenericPalletError<Rv>;

    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     **/
    BadTarget: GenericPalletError<Rv>;

    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     **/
    CannotChillOther: GenericPalletError<Rv>;

    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     **/
    TooManyNominators: GenericPalletError<Rv>;

    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     **/
    TooManyValidators: GenericPalletError<Rv>;

    /**
     * Commission is too low. Must be at least `MinCommission`.
     **/
    CommissionTooLow: GenericPalletError<Rv>;

    /**
     * Some bound is not met.
     **/
    BoundNotMet: GenericPalletError<Rv>;

    /**
     * Used when attempting to use deprecated controller account logic.
     **/
    ControllerDeprecated: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError<Rv>;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError<Rv>;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError<Rv>;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError<Rv>;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TechnicalCommittee`'s errors
   **/
  technicalCommittee: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Grandpa`'s errors
   **/
  grandpa: {
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     **/
    PauseFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     **/
    ResumeFailed: GenericPalletError<Rv>;

    /**
     * Attempt to signal GRANDPA change with one already pending.
     **/
    ChangePending: GenericPalletError<Rv>;

    /**
     * Cannot signal forced change so soon after last.
     **/
    TooSoon: GenericPalletError<Rv>;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    InvalidKeyOwnershipProof: GenericPalletError<Rv>;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    InvalidEquivocationProof: GenericPalletError<Rv>;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    DuplicateOffenceReport: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * Proposer's balance is too low.
     **/
    InsufficientProposersBalance: GenericPalletError<Rv>;

    /**
     * No proposal, bounty or spend at that index.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError<Rv>;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError<Rv>;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError<Rv>;

    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     **/
    FailedToConvertBalance: GenericPalletError<Rv>;

    /**
     * The spend has expired and cannot be claimed.
     **/
    SpendExpired: GenericPalletError<Rv>;

    /**
     * The spend is not yet eligible for payout.
     **/
    EarlyPayout: GenericPalletError<Rv>;

    /**
     * The payment has already been attempted.
     **/
    AlreadyAttempted: GenericPalletError<Rv>;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayoutError: GenericPalletError<Rv>;

    /**
     * The payout was not yet attempted/claimed.
     **/
    NotAttempted: GenericPalletError<Rv>;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Sudo`'s errors
   **/
  sudo: {
    /**
     * Sender must be the Sudo account.
     **/
    RequireSudo: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ImOnline`'s errors
   **/
  imOnline: {
    /**
     * Non existent public key.
     **/
    InvalidKey: GenericPalletError<Rv>;

    /**
     * Duplicated heartbeat.
     **/
    DuplicatedHeartbeat: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError<Rv>;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError<Rv>;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError<Rv>;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `DataAvailability`'s errors
   **/
  dataAvailability: {
    /**
     * The application key already exists.
     **/
    AppKeyAlreadyExists: GenericPalletError<Rv>;

    /**
     * The application key is an empty string.
     **/
    AppKeyCannotBeEmpty: GenericPalletError<Rv>;

    /**
     * The last application ID overflowed.
     **/
    LastAppIdOverflowed: GenericPalletError<Rv>;

    /**
     * The submitted data is empty.
     **/
    DataCannotBeEmpty: GenericPalletError<Rv>;

    /**
     * The last block length proposal Id overflowed.
     **/
    LastBlockLenProposalIdOverflowed: GenericPalletError<Rv>;

    /**
     * The proposed block dimensions are out of bounds.
     **/
    BlockDimensionsOutOfBounds: GenericPalletError<Rv>;

    /**
     * The proposed block dimensions are too small.
     **/
    BlockDimensionsTooSmall: GenericPalletError<Rv>;

    /**
     * The request to reduce block dimensions was made in a non-empty block
     **/
    InvalidBlockWeightReduction: GenericPalletError<Rv>;

    /**
     * Submit data call outside of block execution context.
     **/
    BadContext: GenericPalletError<Rv>;

    /**
     * App info was not found for the given App key
     **/
    UnknownAppKey: GenericPalletError<Rv>;

    /**
     * Submit block length proposal was made with values not power of 2
     **/
    NotPowerOfTwo: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError<Rv>;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError<Rv>;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError<Rv>;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError<Rv>;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError<Rv>;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError<Rv>;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError<Rv>;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError<Rv>;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError<Rv>;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError<Rv>;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError<Rv>;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError<Rv>;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError<Rv>;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError<Rv>;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError<Rv>;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError<Rv>;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `VoterList`'s errors
   **/
  voterList: {
    /**
     * A error in the list interface implementation.
     **/
    List: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `NominationPools`'s errors
   **/
  nominationPools: {
    /**
     * A (bonded) pool id does not exist.
     **/
    PoolNotFound: GenericPalletError<Rv>;

    /**
     * An account is not a member.
     **/
    PoolMemberNotFound: GenericPalletError<Rv>;

    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     **/
    RewardPoolNotFound: GenericPalletError<Rv>;

    /**
     * A sub pool does not exist.
     **/
    SubPoolsNotFound: GenericPalletError<Rv>;

    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     **/
    AccountBelongsToOtherPool: GenericPalletError<Rv>;

    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     **/
    FullyUnbonding: GenericPalletError<Rv>;

    /**
     * The member cannot unbond further chunks due to reaching the limit.
     **/
    MaxUnbondingLimit: GenericPalletError<Rv>;

    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     **/
    CannotWithdrawAny: GenericPalletError<Rv>;

    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
     * caller does not have nominating permissions for the pool. Members can never unbond to a
     * value below `MinJoinBond`.
     **/
    MinimumBondNotMet: GenericPalletError<Rv>;

    /**
     * The transaction could not be executed due to overflow risk for the pool.
     **/
    OverflowRisk: GenericPalletError<Rv>;

    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     **/
    NotDestroying: GenericPalletError<Rv>;

    /**
     * The caller does not have nominating permissions for the pool.
     **/
    NotNominator: GenericPalletError<Rv>;

    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     **/
    NotKickerOrDestroying: GenericPalletError<Rv>;

    /**
     * The pool is not open to join
     **/
    NotOpen: GenericPalletError<Rv>;

    /**
     * The system is maxed out on pools.
     **/
    MaxPools: GenericPalletError<Rv>;

    /**
     * Too many members in the pool or system.
     **/
    MaxPoolMembers: GenericPalletError<Rv>;

    /**
     * The pools state cannot be changed.
     **/
    CanNotChangeState: GenericPalletError<Rv>;

    /**
     * The caller does not have adequate permissions.
     **/
    DoesNotHavePermission: GenericPalletError<Rv>;

    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     **/
    MetadataExceedsMaxLen: GenericPalletError<Rv>;

    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     **/
    Defensive: GenericPalletError<Rv>;

    /**
     * Partial unbonding now allowed permissionlessly.
     **/
    PartialUnbondNotAllowedPermissionlessly: GenericPalletError<Rv>;

    /**
     * The pool's max commission cannot be set higher than the existing value.
     **/
    MaxCommissionRestricted: GenericPalletError<Rv>;

    /**
     * The supplied commission exceeds the max allowed commission.
     **/
    CommissionExceedsMaximum: GenericPalletError<Rv>;

    /**
     * The supplied commission exceeds global maximum commission.
     **/
    CommissionExceedsGlobalMaximum: GenericPalletError<Rv>;

    /**
     * Not enough blocks have surpassed since the last commission update.
     **/
    CommissionChangeThrottled: GenericPalletError<Rv>;

    /**
     * The submitted changes to commission change rate are not allowed.
     **/
    CommissionChangeRateNotAllowed: GenericPalletError<Rv>;

    /**
     * There is no pending commission to claim.
     **/
    NoPendingCommission: GenericPalletError<Rv>;

    /**
     * No commission current has been set.
     **/
    NoCommissionCurrentSet: GenericPalletError<Rv>;

    /**
     * Pool id currently in use.
     **/
    PoolIdInUse: GenericPalletError<Rv>;

    /**
     * Pool id provided is not correct/usable.
     **/
    InvalidPoolId: GenericPalletError<Rv>;

    /**
     * Bonding extra is restricted to the exact pending reward amount.
     **/
    BondExtraRestricted: GenericPalletError<Rv>;

    /**
     * No imbalance in the ED deposit for the pool.
     **/
    NothingToAdjust: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Identity`'s errors
   **/
  identity: {
    /**
     * Too many subs-accounts.
     **/
    TooManySubAccounts: GenericPalletError<Rv>;

    /**
     * Account isn't found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Account isn't named.
     **/
    NotNamed: GenericPalletError<Rv>;

    /**
     * Empty index.
     **/
    EmptyIndex: GenericPalletError<Rv>;

    /**
     * Fee is changed.
     **/
    FeeChanged: GenericPalletError<Rv>;

    /**
     * No identity found.
     **/
    NoIdentity: GenericPalletError<Rv>;

    /**
     * Sticky judgement.
     **/
    StickyJudgement: GenericPalletError<Rv>;

    /**
     * Judgement given.
     **/
    JudgementGiven: GenericPalletError<Rv>;

    /**
     * Invalid judgement.
     **/
    InvalidJudgement: GenericPalletError<Rv>;

    /**
     * The index is invalid.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * The target is invalid.
     **/
    InvalidTarget: GenericPalletError<Rv>;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    TooManyRegistrars: GenericPalletError<Rv>;

    /**
     * Account ID is already named.
     **/
    AlreadyClaimed: GenericPalletError<Rv>;

    /**
     * Sender is not a sub-account.
     **/
    NotSub: GenericPalletError<Rv>;

    /**
     * Sub-account isn't owned by sender.
     **/
    NotOwned: GenericPalletError<Rv>;

    /**
     * The provided judgement was for a different identity.
     **/
    JudgementForDifferentIdentity: GenericPalletError<Rv>;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    JudgementPaymentFailed: GenericPalletError<Rv>;

    /**
     * The provided suffix is too long.
     **/
    InvalidSuffix: GenericPalletError<Rv>;

    /**
     * The sender does not have permission to issue a username.
     **/
    NotUsernameAuthority: GenericPalletError<Rv>;

    /**
     * The authority cannot allocate any more usernames.
     **/
    NoAllocation: GenericPalletError<Rv>;

    /**
     * The signature on a username was not valid.
     **/
    InvalidSignature: GenericPalletError<Rv>;

    /**
     * Setting this username requires a signature, but none was provided.
     **/
    RequiresSignature: GenericPalletError<Rv>;

    /**
     * The username does not meet the requirements.
     **/
    InvalidUsername: GenericPalletError<Rv>;

    /**
     * The username is already taken.
     **/
    UsernameTaken: GenericPalletError<Rv>;

    /**
     * The requested username does not exist.
     **/
    NoUsername: GenericPalletError<Rv>;

    /**
     * The username cannot be forcefully removed because it can still be accepted.
     **/
    NotExpired: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Vector`'s errors
   **/
  vector: {
    VerificationError: GenericPalletError<Rv>;
    NotEnoughParticipants: GenericPalletError<Rv>;
    ConfigurationNotSet: GenericPalletError<Rv>;
    SlotBehindHead: GenericPalletError<Rv>;
    VerificationKeyIsNotSet: GenericPalletError<Rv>;
    MalformedVerificationKey: GenericPalletError<Rv>;
    FunctionIdNotKnown: GenericPalletError<Rv>;
    StepVerificationError: GenericPalletError<Rv>;
    RotateVerificationError: GenericPalletError<Rv>;
    HeaderRootNotSet: GenericPalletError<Rv>;
    VerificationFailed: GenericPalletError<Rv>;
    HeaderRootAlreadySet: GenericPalletError<Rv>;
    StateRootAlreadySet: GenericPalletError<Rv>;
    SyncCommitteeAlreadySet: GenericPalletError<Rv>;
    SyncCommitteeNotSet: GenericPalletError<Rv>;
    MessageAlreadyExecuted: GenericPalletError<Rv>;
    WrongDestinationChain: GenericPalletError<Rv>;
    UnsupportedOriginChain: GenericPalletError<Rv>;
    BroadcasterSourceChainNotSet: GenericPalletError<Rv>;
    SourceChainFrozen: GenericPalletError<Rv>;
    CannotGetStorageRoot: GenericPalletError<Rv>;
    CannotGetStorageValue: GenericPalletError<Rv>;
    InvalidMessageHash: GenericPalletError<Rv>;
    CannotDecodeData: GenericPalletError<Rv>;
    CannotDecodeDestinationAccountId: GenericPalletError<Rv>;

    /**
     * Given AssetId is not supported
     **/
    AssetNotSupported: GenericPalletError<Rv>;

    /**
     * Given inputs for the selected MessageType are invalid
     **/
    InvalidBridgeInputs: GenericPalletError<Rv>;

    /**
     * Domain is not supported
     **/
    DomainNotSupported: GenericPalletError<Rv>;

    /**
     * Function ids (step / rotate) are not set
     **/
    FunctionIdsAreNotSet: GenericPalletError<Rv>;

    /**
     * Inherent call outside of block execution context.
     **/
    BadContext: GenericPalletError<Rv>;

    /**
     * Invalid FailedIndices
     **/
    InvalidFailedIndices: GenericPalletError<Rv>;

    /**
     * Invalid updater
     **/
    UpdaterMisMatch: GenericPalletError<Rv>;

    /**
     * Proof output parsing error
     **/
    CannotParseOutputData: GenericPalletError<Rv>;

    /**
     * Cannot get current message id
     **/
    CurrentMessageIdNotFound: GenericPalletError<Rv>;

    /**
     * Public values decoding error.
     **/
    CannotDecodePublicValue: GenericPalletError<Rv>;

    /**
     * Sync committee hash is already set for given period.
     **/
    SyncCommitteeHashAlreadySet: GenericPalletError<Rv>;

    /**
     * Emit when start sync committee does not match.
     **/
    SyncCommitteeStartMismatch: GenericPalletError<Rv>;

    /**
     * Mock is not enabled.
     **/
    MockIsNotEnabled: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError<Rv>;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError<Rv>;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError<Rv>;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError<Rv>;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TxPause`'s errors
   **/
  txPause: {
    /**
     * The call is paused.
     **/
    IsPaused: GenericPalletError<Rv>;

    /**
     * The call is unpaused.
     **/
    IsUnpaused: GenericPalletError<Rv>;

    /**
     * The call is whitelisted and cannot be paused.
     **/
    Unpausable: GenericPalletError<Rv>;
    NotFound: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TreasuryCommittee`'s errors
   **/
  treasuryCommittee: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
}
