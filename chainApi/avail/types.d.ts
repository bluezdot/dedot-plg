// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  Result,
  Perbill,
  FixedBytes,
  Bytes,
  U256,
  BytesLike,
  Digest,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  PerU16,
  FixedArray,
  Percent,
  Data,
  FixedU128,
  Era,
} from "dedot/codecs";

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemExtrinsicLen = {
  raw: number;
  padded: Array<[AvailCoreAppId, FrameSystemExtrinsicLenPaddedExtrinsicLen]>;
};

export type AvailCoreAppId = number;

export type FrameSystemExtrinsicLenPaddedExtrinsicLen = {
  txLens: Array<number>;
  numScalars: number;
};

export type FrameSystemEventRecord = {
  phase: Phase;
  event: DaRuntimeRuntimeEvent;
  topics: Array<H256>;
};

export type DaRuntimeRuntimeEvent =
  | { pallet: "System"; palletEvent: FrameSystemEvent }
  | { pallet: "Utility"; palletEvent: PalletUtilityEvent }
  | { pallet: "Indices"; palletEvent: PalletIndicesEvent }
  | { pallet: "Balances"; palletEvent: PalletBalancesEvent }
  | { pallet: "TransactionPayment"; palletEvent: PalletTransactionPaymentEvent }
  | {
      pallet: "ElectionProviderMultiPhase";
      palletEvent: PalletElectionProviderMultiPhaseEvent;
    }
  | { pallet: "Staking"; palletEvent: PalletStakingPalletEvent }
  | { pallet: "Session"; palletEvent: PalletSessionEvent }
  | { pallet: "TechnicalCommittee"; palletEvent: PalletCollectiveEvent }
  | { pallet: "Grandpa"; palletEvent: PalletGrandpaEvent }
  | { pallet: "Treasury"; palletEvent: PalletTreasuryEvent }
  | { pallet: "Sudo"; palletEvent: PalletSudoEvent }
  | { pallet: "ImOnline"; palletEvent: PalletImOnlineEvent }
  | { pallet: "Offences"; palletEvent: PalletOffencesEvent }
  | { pallet: "Scheduler"; palletEvent: PalletSchedulerEvent }
  | { pallet: "DataAvailability"; palletEvent: DaControlEvent }
  | { pallet: "Preimage"; palletEvent: PalletPreimageEvent }
  | { pallet: "Multisig"; palletEvent: PalletMultisigEvent }
  | { pallet: "VoterList"; palletEvent: PalletBagsListEvent }
  | { pallet: "NominationPools"; palletEvent: PalletNominationPoolsEvent }
  | { pallet: "Identity"; palletEvent: PalletIdentityEvent }
  | { pallet: "Mandate"; palletEvent: PalletMandateEvent }
  | { pallet: "Vector"; palletEvent: PalletVectorEvent }
  | { pallet: "Proxy"; palletEvent: PalletProxyEvent }
  | { pallet: "TxPause"; palletEvent: PalletTxPauseEvent }
  | { pallet: "TreasuryCommittee"; palletEvent: PalletCollectiveEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: "ExtrinsicSuccess"; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | {
      name: "ExtrinsicFailed";
      data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo };
    }
  /**
   * `:code` was updated.
   **/
  | { name: "CodeUpdated" }
  /**
   * A new account was created.
   **/
  | { name: "NewAccount"; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: "KilledAccount"; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: "Remarked"; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | {
      name: "UpgradeAuthorized";
      data: { codeHash: H256; checkVersion: boolean };
    };

export type FrameSupportDispatchDispatchClass =
  | "Normal"
  | "Operational"
  | "Mandatory";

export type FrameSupportDispatchPays = "Yes" | "No";

export type FrameSupportDispatchDispatchFeeModifier = {
  weightMaximumFee?: bigint | undefined;
  weightFeeDivider?: number | undefined;
  weightFeeMultiplier?: number | undefined;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: "BatchInterrupted"; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: "BatchCompleted" }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: "BatchCompletedWithErrors" }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: "ItemCompleted" }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: "ItemFailed"; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: "DispatchedAs"; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndicesEvent =
  /**
   * A account index was assigned.
   **/
  | { name: "IndexAssigned"; data: { who: AccountId32; index: number } }
  /**
   * A account index has been freed up (unassigned).
   **/
  | { name: "IndexFreed"; data: { index: number } }
  /**
   * A account index has been frozen to its current account ID.
   **/
  | { name: "IndexFrozen"; data: { index: number; who: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: "Endowed"; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: "DustLost"; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | {
      name: "Transfer";
      data: { from: AccountId32; to: AccountId32; amount: bigint };
    }
  /**
   * A balance was set by root.
   **/
  | { name: "BalanceSet"; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: "Reserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: "Unreserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: "ReserveRepatriated";
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: "Deposit"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: "Withdraw"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: "Slashed"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: "Minted"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: "Burned"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: "Suspended"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: "Restored"; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: "Upgraded"; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: "Issued"; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: "Rescinded"; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: "Locked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: "Unlocked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: "Frozen"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: "Thawed"; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: "TotalIssuanceForced"; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = "Free" | "Reserved";

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  {
    name: "TransactionFeePaid";
    data: { who: AccountId32; actualFee: bigint; tip: bigint };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionProviderMultiPhaseEvent =
  /**
   * A solution was stored with the given compute.
   *
   * The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
   * the stored solution was submited in the signed phase by a miner with the `AccountId`.
   * Otherwise, the solution was stored either during the unsigned phase or by
   * `T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
   * room for this one.
   **/
  | {
      name: "SolutionStored";
      data: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        origin?: AccountId32 | undefined;
        prevEjected: boolean;
      };
    }
  /**
   * The election has been finalized, with the given computation and score.
   **/
  | {
      name: "ElectionFinalized";
      data: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        score: SpNposElectionsElectionScore;
      };
    }
  /**
   * An election failed.
   *
   * Not much can be said about which computes failed in the process.
   **/
  | { name: "ElectionFailed" }
  /**
   * An account has been rewarded for their signed submission being finalized.
   **/
  | { name: "Rewarded"; data: { account: AccountId32; value: bigint } }
  /**
   * An account has been slashed for submitting an invalid signed submission.
   **/
  | { name: "Slashed"; data: { account: AccountId32; value: bigint } }
  /**
   * There was a phase transition in a given round.
   **/
  | {
      name: "PhaseTransitioned";
      data: {
        from: PalletElectionProviderMultiPhasePhase;
        to: PalletElectionProviderMultiPhasePhase;
        round: number;
      };
    };

export type PalletElectionProviderMultiPhaseElectionCompute =
  | "OnChain"
  | "Signed"
  | "Unsigned"
  | "Fallback"
  | "Emergency";

export type SpNposElectionsElectionScore = {
  minimalStake: bigint;
  sumStake: bigint;
  sumStakeSquared: bigint;
};

export type PalletElectionProviderMultiPhasePhase =
  | { type: "Off" }
  | { type: "Signed" }
  | { type: "Unsigned"; value: [boolean, number] }
  | { type: "Emergency" };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  /**
   * The era payout has been set; the first balance is the validator-payout; the second is
   * the remainder from the maximum amount of reward.
   **/
  | {
      name: "EraPaid";
      data: { eraIndex: number; validatorPayout: bigint; remainder: bigint };
    }
  /**
   * The nominator has been rewarded by this amount to this destination.
   **/
  | {
      name: "Rewarded";
      data: {
        stash: AccountId32;
        dest: PalletStakingRewardDestination;
        amount: bigint;
      };
    }
  /**
   * A staker (validator or nominator) has been slashed by the given amount.
   **/
  | { name: "Slashed"; data: { staker: AccountId32; amount: bigint } }
  /**
   * A slash for the given validator, for the given percentage of their stake, at the given
   * era as been reported.
   **/
  | {
      name: "SlashReported";
      data: { validator: AccountId32; fraction: Perbill; slashEra: number };
    }
  /**
   * An old slashing report from a prior era was discarded because it could
   * not be processed.
   **/
  | { name: "OldSlashingReportDiscarded"; data: { sessionIndex: number } }
  /**
   * A new set of stakers was elected.
   **/
  | { name: "StakersElected" }
  /**
   * An account has bonded this amount. \[stash, amount\]
   *
   * NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
   * it will not be emitted for staking rewards when they are added to stake.
   **/
  | { name: "Bonded"; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has unbonded this amount.
   **/
  | { name: "Unbonded"; data: { stash: AccountId32; amount: bigint } }
  /**
   * An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
   * from the unlocking queue.
   **/
  | { name: "Withdrawn"; data: { stash: AccountId32; amount: bigint } }
  /**
   * A nominator has been kicked from a validator.
   **/
  | { name: "Kicked"; data: { nominator: AccountId32; stash: AccountId32 } }
  /**
   * The election failed. No new era is planned.
   **/
  | { name: "StakingElectionFailed" }
  /**
   * An account has stopped participating as either a validator or nominator.
   **/
  | { name: "Chilled"; data: { stash: AccountId32 } }
  /**
   * The stakers' rewards are getting paid.
   **/
  | {
      name: "PayoutStarted";
      data: { eraIndex: number; validatorStash: AccountId32 };
    }
  /**
   * A validator has set their preferences.
   **/
  | {
      name: "ValidatorPrefsSet";
      data: { stash: AccountId32; prefs: PalletStakingValidatorPrefs };
    }
  /**
   * Voters size limit reached.
   **/
  | { name: "SnapshotVotersSizeExceeded"; data: { size: number } }
  /**
   * Targets size limit reached.
   **/
  | { name: "SnapshotTargetsSizeExceeded"; data: { size: number } }
  /**
   * A new force era mode was set.
   **/
  | { name: "ForceEra"; data: { mode: PalletStakingForcing } };

export type PalletStakingRewardDestination =
  | { type: "Staked" }
  | { type: "Stash" }
  | { type: "Controller" }
  | { type: "Account"; value: AccountId32 }
  | { type: "None" };

export type PalletStakingValidatorPrefs = {
  commission: Perbill;
  blocked: boolean;
};

export type PalletStakingForcing =
  | "NotForcing"
  | "ForceNew"
  | "ForceNone"
  | "ForceAlways";

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: "NewSession"; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | {
      name: "Proposed";
      data: {
        account: AccountId32;
        proposalIndex: number;
        proposalHash: H256;
        threshold: number;
      };
    }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | {
      name: "Voted";
      data: {
        account: AccountId32;
        proposalHash: H256;
        voted: boolean;
        yes: number;
        no: number;
      };
    }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: "Approved"; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: "Disapproved"; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | {
      name: "Executed";
      data: { proposalHash: H256; result: Result<[], DispatchError> };
    }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | {
      name: "MemberExecuted";
      data: { proposalHash: H256; result: Result<[], DispatchError> };
    }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: "Closed"; data: { proposalHash: H256; yes: number; no: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | {
      name: "NewAuthorities";
      data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> };
    }
  /**
   * Current authority set has been paused.
   **/
  | { name: "Paused" }
  /**
   * Current authority set has been resumed.
   **/
  | { name: "Resumed" };

export type SpConsensusGrandpaAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: "Proposed"; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: "Spending"; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | {
      name: "Awarded";
      data: { proposalIndex: number; award: bigint; account: AccountId32 };
    }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: "Rejected"; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: "Burnt"; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: "Rollover"; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: "Deposit"; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | {
      name: "SpendApproved";
      data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 };
    }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | {
      name: "UpdatedInactive";
      data: { reactivated: bigint; deactivated: bigint };
    }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: "AssetSpendApproved";
      data: {
        index: number;
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: "AssetSpendVoided"; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: "Paid"; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: "PaymentFailed"; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: "SpendProcessed"; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: "Sudid";
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: "KeyChanged";
      data: {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      };
    }
  /**
   * The key was permanently removed.
   **/
  | { name: "KeyRemoved" }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: "SudoAsDone";
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletImOnlineEvent =
  /**
   * A new heartbeat was received from `AuthorityId`.
   **/
  | {
      name: "HeartbeatReceived";
      data: { authorityId: PalletImOnlineSr25519AppSr25519Public };
    }
  /**
   * At the end of the session, no offence was committed.
   **/
  | { name: "AllGood" }
  /**
   * At the end of the session, at least one validator was found to be offline.
   **/
  | {
      name: "SomeOffline";
      data: { offline: Array<[AccountId32, SpStakingExposure]> };
    };

export type PalletImOnlineSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type SpStakingExposure = {
  total: bigint;
  own: bigint;
  others: Array<SpStakingIndividualExposure>;
};

export type SpStakingIndividualExposure = { who: AccountId32; value: bigint };

/**
 * Events type.
 **/
export type PalletOffencesEvent =
  /**
   * There is an offence reported of the given `kind` happened at the `session_index` and
   * (kind-specific) time slot. This event is not deposited for duplicate slashes.
   * \[kind, timeslot\].
   **/
  { name: "Offence"; data: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: "Scheduled"; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: "Canceled"; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: "Dispatched";
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | {
      name: "CallUnavailable";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | {
      name: "PeriodicFailed";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | {
      name: "PermanentlyOverweight";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    };

/**
 * Event for the pallet.
 **/
export type DaControlEvent =
  /**
   * A new application key was created.
   **/
  | {
      name: "ApplicationKeyCreated";
      data: { key: Bytes; owner: AccountId32; id: AvailCoreAppId };
    }
  | { name: "DataSubmitted"; data: { who: AccountId32; dataHash: H256 } }
  | {
      name: "BlockLengthProposalSubmitted";
      data: {
        rows: AvailCoreBlockLengthRows;
        cols: AvailCoreBlockLengthColumns;
      };
    }
  | { name: "ApplicationKeySet"; data: { oldKey: Bytes; newKey: Bytes } }
  | {
      name: "SubmitDataFeeModifierSet";
      data: { value: FrameSupportDispatchDispatchFeeModifier };
    };

export type AvailCoreBlockLengthRows = number;

export type AvailCoreBlockLengthColumns = number;

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: "Noted"; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: "Requested"; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: "Cleared"; data: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | {
      name: "NewMultisig";
      data: {
        approving: AccountId32;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: "MultisigApproval";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: "MultisigExecuted";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: "MultisigCancelled";
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBagsListEvent =
  /**
   * Moved an account from one bag to another.
   **/
  | { name: "Rebagged"; data: { who: AccountId32; from: bigint; to: bigint } }
  /**
   * Updated the score of some account to the given amount.
   **/
  | { name: "ScoreUpdated"; data: { who: AccountId32; newScore: bigint } };

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  /**
   * A pool has been created.
   **/
  | { name: "Created"; data: { depositor: AccountId32; poolId: number } }
  /**
   * A member has became bonded in a pool.
   **/
  | {
      name: "Bonded";
      data: {
        member: AccountId32;
        poolId: number;
        bonded: bigint;
        joined: boolean;
      };
    }
  /**
   * A payout has been made to a member.
   **/
  | {
      name: "PaidOut";
      data: { member: AccountId32; poolId: number; payout: bigint };
    }
  /**
   * A member has unbonded from their pool.
   *
   * - `balance` is the corresponding balance of the number of points that has been
   * requested to be unbonded (the argument of the `unbond` transaction) from the bonded
   * pool.
   * - `points` is the number of points that are issued as a result of `balance` being
   * dissolved into the corresponding unbonding pool.
   * - `era` is the era in which the balance will be unbonded.
   * In the absence of slashing, these values will match. In the presence of slashing, the
   * number of points that are issued in the unbonding pool will be less than the amount
   * requested to be unbonded.
   **/
  | {
      name: "Unbonded";
      data: {
        member: AccountId32;
        poolId: number;
        balance: bigint;
        points: bigint;
        era: number;
      };
    }
  /**
   * A member has withdrawn from their pool.
   *
   * The given number of `points` have been dissolved in return of `balance`.
   *
   * Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
   * will be 1.
   **/
  | {
      name: "Withdrawn";
      data: {
        member: AccountId32;
        poolId: number;
        balance: bigint;
        points: bigint;
      };
    }
  /**
   * A pool has been destroyed.
   **/
  | { name: "Destroyed"; data: { poolId: number } }
  /**
   * The state of a pool has changed
   **/
  | {
      name: "StateChanged";
      data: { poolId: number; newState: PalletNominationPoolsPoolState };
    }
  /**
   * A member has been removed from a pool.
   *
   * The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
   **/
  | { name: "MemberRemoved"; data: { poolId: number; member: AccountId32 } }
  /**
   * The roles of a pool have been updated to the given new roles. Note that the depositor
   * can never change.
   **/
  | {
      name: "RolesUpdated";
      data: {
        root?: AccountId32 | undefined;
        bouncer?: AccountId32 | undefined;
        nominator?: AccountId32 | undefined;
      };
    }
  /**
   * The active balance of pool `pool_id` has been slashed to `balance`.
   **/
  | { name: "PoolSlashed"; data: { poolId: number; balance: bigint } }
  /**
   * The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
   **/
  | {
      name: "UnbondingPoolSlashed";
      data: { poolId: number; era: number; balance: bigint };
    }
  /**
   * A pool's commission setting has been changed.
   **/
  | {
      name: "PoolCommissionUpdated";
      data: { poolId: number; current?: [Perbill, AccountId32] | undefined };
    }
  /**
   * A pool's maximum commission setting has been changed.
   **/
  | {
      name: "PoolMaxCommissionUpdated";
      data: { poolId: number; maxCommission: Perbill };
    }
  /**
   * A pool's commission `change_rate` has been changed.
   **/
  | {
      name: "PoolCommissionChangeRateUpdated";
      data: {
        poolId: number;
        changeRate: PalletNominationPoolsCommissionChangeRate;
      };
    }
  /**
   * Pool commission claim permission has been updated.
   **/
  | {
      name: "PoolCommissionClaimPermissionUpdated";
      data: {
        poolId: number;
        permission?: PalletNominationPoolsCommissionClaimPermission | undefined;
      };
    }
  /**
   * Pool commission has been claimed.
   **/
  | {
      name: "PoolCommissionClaimed";
      data: { poolId: number; commission: bigint };
    }
  /**
   * Topped up deficit in frozen ED of the reward pool.
   **/
  | {
      name: "MinBalanceDeficitAdjusted";
      data: { poolId: number; amount: bigint };
    }
  /**
   * Claimed excess frozen ED of af the reward pool.
   **/
  | {
      name: "MinBalanceExcessAdjusted";
      data: { poolId: number; amount: bigint };
    };

export type PalletNominationPoolsPoolState = "Open" | "Blocked" | "Destroying";

export type PalletNominationPoolsCommissionChangeRate = {
  maxIncrease: Perbill;
  minDelay: number;
};

export type PalletNominationPoolsCommissionClaimPermission =
  | { type: "Permissionless" }
  | { type: "Account"; value: AccountId32 };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: "IdentitySet"; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: "IdentityCleared"; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: "IdentityKilled"; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | {
      name: "JudgementRequested";
      data: { who: AccountId32; registrarIndex: number };
    }
  /**
   * A judgement request was retracted.
   **/
  | {
      name: "JudgementUnrequested";
      data: { who: AccountId32; registrarIndex: number };
    }
  /**
   * A judgement was given by a registrar.
   **/
  | {
      name: "JudgementGiven";
      data: { target: AccountId32; registrarIndex: number };
    }
  /**
   * A registrar was added.
   **/
  | { name: "RegistrarAdded"; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | {
      name: "SubIdentityAdded";
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | {
      name: "SubIdentityRemoved";
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | {
      name: "SubIdentityRevoked";
      data: { sub: AccountId32; main: AccountId32; deposit: bigint };
    }
  /**
   * A username authority was added.
   **/
  | { name: "AuthorityAdded"; data: { authority: AccountId32 } }
  /**
   * A username authority was removed.
   **/
  | { name: "AuthorityRemoved"; data: { authority: AccountId32 } }
  /**
   * A username was set for `who`.
   **/
  | { name: "UsernameSet"; data: { who: AccountId32; username: Bytes } }
  /**
   * A username was queued, but `who` must accept it prior to `expiration`.
   **/
  | {
      name: "UsernameQueued";
      data: { who: AccountId32; username: Bytes; expiration: number };
    }
  /**
   * A queued username passed its expiration without being claimed and was removed.
   **/
  | { name: "PreapprovalExpired"; data: { whose: AccountId32 } }
  /**
   * A username was set as a primary and can be looked up from `who`.
   **/
  | { name: "PrimaryUsernameSet"; data: { who: AccountId32; username: Bytes } }
  /**
   * A dangling username (as in, a username corresponding to an account that has removed its
   * identity) has been removed.
   **/
  | {
      name: "DanglingUsernameRemoved";
      data: { who: AccountId32; username: Bytes };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMandateEvent =
  /**
   * A root operation was executed, show result
   **/
  { name: "RootOp"; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVectorEvent =
  /**
   * Emit event once the head is updated.
   **/
  | {
      name: "HeadUpdated";
      data: { slot: bigint; finalizationRoot: H256; executionStateRoot: H256 };
    }
  /**
   * Emit event once the sync committee updates.
   **/
  | { name: "SyncCommitteeUpdated"; data: { period: bigint; root: U256 } }
  /**
   * Emit when new updater is set.
   **/
  | {
      name: "BroadcasterUpdated";
      data: { old: H256; new: H256; domain: number };
    }
  /**
   * Emit when message gets executed.
   **/
  | {
      name: "MessageExecuted";
      data: { from: H256; to: H256; messageId: bigint; messageRoot: H256 };
    }
  /**
   * Emit if source chain gets frozen.
   **/
  | {
      name: "SourceChainFrozen";
      data: { sourceChainId: number; frozen: boolean };
    }
  /**
   * Emit when message is submitted.
   **/
  | {
      name: "MessageSubmitted";
      data: {
        from: AccountId32;
        to: H256;
        messageType: AvailCoreDataProofMessageMessageType;
        destinationDomain: number;
        messageId: bigint;
      };
    }
  /**
   * Emit whitelisted domains that are updated.
   **/
  | { name: "WhitelistedDomainsUpdated" }
  /**
   * Emit when configuration is updated.
   **/
  | {
      name: "ConfigurationUpdated";
      data: { slotsPerPeriod: bigint; finalityThreshold: number };
    }
  /**
   * Emit function Ids that are updated.
   **/
  | { name: "FunctionIdsUpdated"; data: { value?: [H256, H256] | undefined } }
  /**
   * Emit updated step verification key.
   **/
  | { name: "StepVerificationKeyUpdated"; data: { value?: Bytes | undefined } }
  /**
   * Emit updated rotate verification key.
   **/
  | {
      name: "RotateVerificationKeyUpdated";
      data: { value?: Bytes | undefined };
    }
  /**
   * Emit new updater.
   **/
  | { name: "NewUpdater"; data: { old: H256; new: H256 } }
  /**
   * Emit new SP1 verification key.
   **/
  | { name: "NewSP1VerificationKey"; data: { old: H256; new: H256 } }
  /**
   * Emit when new sync committee is updated.
   **/
  | { name: "SyncCommitteeHashUpdated"; data: { period: bigint; hash: H256 } }
  /**
   * Emit when mocks are enabled or disabled
   **/
  | { name: "MockEnabled"; data: { value: boolean } };

export type AvailCoreDataProofMessageMessageType =
  | "ArbitraryMessage"
  | "FungibleToken";

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: "ProxyExecuted"; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: "PureCreated";
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: DaRuntimeImplsProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | {
      name: "Announced";
      data: { real: AccountId32; proxy: AccountId32; callHash: H256 };
    }
  /**
   * A proxy was added.
   **/
  | {
      name: "ProxyAdded";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: "ProxyRemoved";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    };

export type DaRuntimeImplsProxyType =
  | "Any"
  | "NonTransfer"
  | "Governance"
  | "Staking"
  | "IdentityJudgement"
  | "NominationPools";

/**
 * The `Event` enum of this pallet
 **/
export type PalletTxPauseEvent =
  /**
   * This pallet, or a specific call is now paused.
   **/
  | { name: "CallPaused"; data: { fullName: [Bytes, Bytes] } }
  /**
   * This pallet, or a specific call is now unpaused.
   **/
  | { name: "CallUnpaused"; data: { fullName: [Bytes, Bytes] } };

export type FrameSystemLastRuntimeUpgradeInfo = {
  specVersion: number;
  specName: string;
};

export type FrameSystemCodeUpgradeAuthorization = {
  codeHash: H256;
  checkVersion: boolean;
};

export type FrameSystemLimitsBlockLength = {
  max: FrameSupportDispatchPerDispatchClassU32;
  cols: AvailCoreBlockLengthColumns;
  rows: AvailCoreBlockLengthRows;
  chunkSize: number;
};

export type FrameSupportDispatchPerDispatchClassU32 = {
  normal: number;
  operational: number;
  mandatory: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: "Remark"; params: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: "SetCode"; params: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: "SetStorage"; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: "KillStorage"; params: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: "KillPrefix"; params: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: "RemarkWithEvent"; params: { remark: Bytes } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * See [`Pallet::authorize_upgrade_without_checks`].
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * See [`Pallet::apply_authorized_upgrade`].
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: "Remark"; params: { remark: BytesLike } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: "SetCode"; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: "SetStorage"; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: "KillStorage"; params: { keys: Array<BytesLike> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: "KillPrefix"; params: { prefix: BytesLike; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: "RemarkWithEvent"; params: { remark: BytesLike } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * See [`Pallet::authorize_upgrade_without_checks`].
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * See [`Pallet::apply_authorized_upgrade`].
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | "InvalidSpecName"
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | "SpecVersionNeedsToIncrease"
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | "FailedToExtractRuntimeVersion"
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | "NonDefaultComposite"
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | "NonZeroRefCount"
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | "CallFiltered"
  /**
   * No upgrade authorized.
   **/
  | "NothingAuthorized"
  /**
   * The submitted code is not authorized.
   **/
  | "Unauthorized";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: "Batch"; params: { calls: Array<DaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: DaRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: "BatchAll"; params: { calls: Array<DaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: "DispatchAs";
      params: { asOrigin: DaRuntimeOriginCaller; call: DaRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: "ForceBatch"; params: { calls: Array<DaRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | {
      name: "WithWeight";
      params: { call: DaRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight };
    };

export type PalletUtilityCallLike =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: "Batch"; params: { calls: Array<DaRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: DaRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: "BatchAll"; params: { calls: Array<DaRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: "DispatchAs";
      params: {
        asOrigin: DaRuntimeOriginCaller;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: "ForceBatch"; params: { calls: Array<DaRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | {
      name: "WithWeight";
      params: {
        call: DaRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    };

export type DaRuntimeRuntimeCall =
  | { pallet: "System"; palletCall: FrameSystemCall }
  | { pallet: "Utility"; palletCall: PalletUtilityCall }
  | { pallet: "Babe"; palletCall: PalletBabeCall }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCall }
  | { pallet: "Indices"; palletCall: PalletIndicesCall }
  | { pallet: "Balances"; palletCall: PalletBalancesCall }
  | {
      pallet: "ElectionProviderMultiPhase";
      palletCall: PalletElectionProviderMultiPhaseCall;
    }
  | { pallet: "Staking"; palletCall: PalletStakingPalletCall }
  | { pallet: "Session"; palletCall: PalletSessionCall }
  | { pallet: "TechnicalCommittee"; palletCall: PalletCollectiveCall }
  | { pallet: "Grandpa"; palletCall: PalletGrandpaCall }
  | { pallet: "Treasury"; palletCall: PalletTreasuryCall }
  | { pallet: "Sudo"; palletCall: PalletSudoCall }
  | { pallet: "ImOnline"; palletCall: PalletImOnlineCall }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCall }
  | { pallet: "DataAvailability"; palletCall: DaControlCall }
  | { pallet: "Preimage"; palletCall: PalletPreimageCall }
  | { pallet: "Multisig"; palletCall: PalletMultisigCall }
  | { pallet: "VoterList"; palletCall: PalletBagsListCall }
  | { pallet: "NominationPools"; palletCall: PalletNominationPoolsCall }
  | { pallet: "Identity"; palletCall: PalletIdentityCall }
  | { pallet: "Mandate"; palletCall: PalletMandateCall }
  | { pallet: "Vector"; palletCall: PalletVectorCall }
  | { pallet: "Proxy"; palletCall: PalletProxyCall }
  | { pallet: "TxPause"; palletCall: PalletTxPauseCall }
  | { pallet: "TreasuryCommittee"; palletCall: PalletCollectiveCall };

export type DaRuntimeRuntimeCallLike =
  | { pallet: "System"; palletCall: FrameSystemCallLike }
  | { pallet: "Utility"; palletCall: PalletUtilityCallLike }
  | { pallet: "Babe"; palletCall: PalletBabeCallLike }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCallLike }
  | { pallet: "Indices"; palletCall: PalletIndicesCallLike }
  | { pallet: "Balances"; palletCall: PalletBalancesCallLike }
  | {
      pallet: "ElectionProviderMultiPhase";
      palletCall: PalletElectionProviderMultiPhaseCallLike;
    }
  | { pallet: "Staking"; palletCall: PalletStakingPalletCallLike }
  | { pallet: "Session"; palletCall: PalletSessionCallLike }
  | { pallet: "TechnicalCommittee"; palletCall: PalletCollectiveCallLike }
  | { pallet: "Grandpa"; palletCall: PalletGrandpaCallLike }
  | { pallet: "Treasury"; palletCall: PalletTreasuryCallLike }
  | { pallet: "Sudo"; palletCall: PalletSudoCallLike }
  | { pallet: "ImOnline"; palletCall: PalletImOnlineCallLike }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCallLike }
  | { pallet: "DataAvailability"; palletCall: DaControlCallLike }
  | { pallet: "Preimage"; palletCall: PalletPreimageCallLike }
  | { pallet: "Multisig"; palletCall: PalletMultisigCallLike }
  | { pallet: "VoterList"; palletCall: PalletBagsListCallLike }
  | { pallet: "NominationPools"; palletCall: PalletNominationPoolsCallLike }
  | { pallet: "Identity"; palletCall: PalletIdentityCallLike }
  | { pallet: "Mandate"; palletCall: PalletMandateCallLike }
  | { pallet: "Vector"; palletCall: PalletVectorCallLike }
  | { pallet: "Proxy"; palletCall: PalletProxyCallLike }
  | { pallet: "TxPause"; palletCall: PalletTxPauseCallLike }
  | { pallet: "TreasuryCommittee"; palletCall: PalletCollectiveCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::plan_config_change`].
   **/
  | {
      name: "PlanConfigChange";
      params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
    };

export type PalletBabeCallLike =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusSlotsEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::plan_config_change`].
   **/
  | {
      name: "PlanConfigChange";
      params: { config: SpConsensusBabeDigestsNextConfigDescriptor };
    };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: AvailCoreHeader;
  secondHeader: AvailCoreHeader;
};

export type AvailCoreHeader = {
  parentHash: H256;
  number: number;
  stateRoot: H256;
  extrinsicsRoot: H256;
  digest: Digest;
  extension: AvailCoreHeaderExtensionHeaderExtension;
};

export type SpRuntimeBlakeTwo256 = {};

export type AvailCoreHeaderExtensionHeaderExtension = {
  type: "V3";
  value: AvailCoreHeaderExtensionV3HeaderExtension;
};

export type AvailCoreHeaderExtensionV3HeaderExtension = {
  appLookup: AvailCoreDataLookupCompactCompactDataLookup;
  commitment: AvailCoreKateCommitmentV3KateCommitment;
};

export type AvailCoreDataLookupCompactCompactDataLookup = {
  size: number;
  index: Array<AvailCoreDataLookupCompactDataLookupItem>;
};

export type AvailCoreDataLookupCompactDataLookupItem = {
  appId: AvailCoreAppId;
  start: number;
};

export type AvailCoreKateCommitmentV3KateCommitment = {
  rows: number;
  cols: number;
  commitment: Bytes;
  dataRoot: H256;
};

export type SpConsensusBabeAppPublic = SpCoreSr25519Public;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = {
  session: number;
  trieNodes: Array<Bytes>;
  validatorCount: number;
};

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  type: "V1";
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | "PrimarySlots"
  | "PrimaryAndSecondaryPlainSlots"
  | "PrimaryAndSecondaryVRFSlots";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { name: "Set"; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * See [`Pallet::set`].
   **/
  { name: "Set"; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndicesCall =
  /**
   * See [`Pallet::claim`].
   **/
  | { name: "Claim"; params: { index: number } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: "Transfer"; params: { new: MultiAddress; index: number } }
  /**
   * See [`Pallet::free`].
   **/
  | { name: "Free"; params: { index: number } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: "ForceTransfer";
      params: { new: MultiAddress; index: number; freeze: boolean };
    }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: "Freeze"; params: { index: number } };

export type PalletIndicesCallLike =
  /**
   * See [`Pallet::claim`].
   **/
  | { name: "Claim"; params: { index: number } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: "Transfer"; params: { new: MultiAddressLike; index: number } }
  /**
   * See [`Pallet::free`].
   **/
  | { name: "Free"; params: { index: number } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: "ForceTransfer";
      params: { new: MultiAddressLike; index: number; freeze: boolean };
    }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: "Freeze"; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddress; value: bigint };
    }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: "ForceTransfer";
      params: { source: MultiAddress; dest: MultiAddress; value: bigint };
    }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: "TransferKeepAlive"; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: "TransferAll"; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: "ForceUnreserve"; params: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: "ForceSetBalance"; params: { who: MultiAddress; newFree: bigint } }
  /**
   * See [`Pallet::force_adjust_total_issuance`].
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    };

export type PalletBalancesCallLike =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | {
      name: "ForceTransfer";
      params: {
        source: MultiAddressLike;
        dest: MultiAddressLike;
        value: bigint;
      };
    }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | {
      name: "TransferKeepAlive";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | {
      name: "TransferAll";
      params: { dest: MultiAddressLike; keepAlive: boolean };
    }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | {
      name: "ForceUnreserve";
      params: { who: MultiAddressLike; amount: bigint };
    }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32Like> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | {
      name: "ForceSetBalance";
      params: { who: MultiAddressLike; newFree: bigint };
    }
  /**
   * See [`Pallet::force_adjust_total_issuance`].
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    };

export type PalletBalancesAdjustmentDirection = "Increase" | "Decrease";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionProviderMultiPhaseCall =
  /**
   * See [`Pallet::submit_unsigned`].
   **/
  | {
      name: "SubmitUnsigned";
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * See [`Pallet::set_minimum_untrusted_score`].
   **/
  | {
      name: "SetMinimumUntrustedScore";
      params: { maybeNextScore?: SpNposElectionsElectionScore | undefined };
    }
  /**
   * See [`Pallet::set_emergency_election_result`].
   **/
  | {
      name: "SetEmergencyElectionResult";
      params: { supports: Array<[AccountId32, SpNposElectionsSupport]> };
    }
  /**
   * See [`Pallet::submit`].
   **/
  | {
      name: "Submit";
      params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution };
    }
  /**
   * See [`Pallet::governance_fallback`].
   **/
  | {
      name: "GovernanceFallback";
      params: {
        maybeMaxVoters?: number | undefined;
        maybeMaxTargets?: number | undefined;
      };
    };

export type PalletElectionProviderMultiPhaseCallLike =
  /**
   * See [`Pallet::submit_unsigned`].
   **/
  | {
      name: "SubmitUnsigned";
      params: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  /**
   * See [`Pallet::set_minimum_untrusted_score`].
   **/
  | {
      name: "SetMinimumUntrustedScore";
      params: { maybeNextScore?: SpNposElectionsElectionScore | undefined };
    }
  /**
   * See [`Pallet::set_emergency_election_result`].
   **/
  | {
      name: "SetEmergencyElectionResult";
      params: { supports: Array<[AccountId32Like, SpNposElectionsSupport]> };
    }
  /**
   * See [`Pallet::submit`].
   **/
  | {
      name: "Submit";
      params: { rawSolution: PalletElectionProviderMultiPhaseRawSolution };
    }
  /**
   * See [`Pallet::governance_fallback`].
   **/
  | {
      name: "GovernanceFallback";
      params: {
        maybeMaxVoters?: number | undefined;
        maybeMaxTargets?: number | undefined;
      };
    };

export type PalletElectionProviderMultiPhaseRawSolution = {
  solution: DaRuntimeConstantsStakingNposSolution16;
  score: SpNposElectionsElectionScore;
  round: number;
};

export type DaRuntimeConstantsStakingNposSolution16 = {
  votes1: Array<[number, number]>;
  votes2: Array<[number, [number, PerU16], number]>;
  votes3: Array<[number, FixedArray<[number, PerU16], 2>, number]>;
  votes4: Array<[number, FixedArray<[number, PerU16], 3>, number]>;
  votes5: Array<[number, FixedArray<[number, PerU16], 4>, number]>;
  votes6: Array<[number, FixedArray<[number, PerU16], 5>, number]>;
  votes7: Array<[number, FixedArray<[number, PerU16], 6>, number]>;
  votes8: Array<[number, FixedArray<[number, PerU16], 7>, number]>;
  votes9: Array<[number, FixedArray<[number, PerU16], 8>, number]>;
  votes10: Array<[number, FixedArray<[number, PerU16], 9>, number]>;
  votes11: Array<[number, FixedArray<[number, PerU16], 10>, number]>;
  votes12: Array<[number, FixedArray<[number, PerU16], 11>, number]>;
  votes13: Array<[number, FixedArray<[number, PerU16], 12>, number]>;
  votes14: Array<[number, FixedArray<[number, PerU16], 13>, number]>;
  votes15: Array<[number, FixedArray<[number, PerU16], 14>, number]>;
  votes16: Array<[number, FixedArray<[number, PerU16], 15>, number]>;
};

export type PalletElectionProviderMultiPhaseSolutionOrSnapshotSize = {
  voters: number;
  targets: number;
};

export type SpNposElectionsSupport = {
  total: bigint;
  voters: Array<[AccountId32, bigint]>;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  /**
   * See [`Pallet::bond`].
   **/
  | {
      name: "Bond";
      params: { value: bigint; payee: PalletStakingRewardDestination };
    }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: "BondExtra"; params: { maxAdditional: bigint } }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: "Unbond"; params: { value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: "WithdrawUnbonded"; params: { numSlashingSpans: number } }
  /**
   * See [`Pallet::validate`].
   **/
  | { name: "Validate"; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: "Nominate"; params: { targets: Array<MultiAddress> } }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: "Chill" }
  /**
   * See [`Pallet::set_payee`].
   **/
  | { name: "SetPayee"; params: { payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::set_controller`].
   **/
  | { name: "SetController" }
  /**
   * See [`Pallet::set_validator_count`].
   **/
  | { name: "SetValidatorCount"; params: { new: number } }
  /**
   * See [`Pallet::increase_validator_count`].
   **/
  | { name: "IncreaseValidatorCount"; params: { additional: number } }
  /**
   * See [`Pallet::scale_validator_count`].
   **/
  | { name: "ScaleValidatorCount"; params: { factor: Percent } }
  /**
   * See [`Pallet::force_no_eras`].
   **/
  | { name: "ForceNoEras" }
  /**
   * See [`Pallet::force_new_era`].
   **/
  | { name: "ForceNewEra" }
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: "SetInvulnerables"; params: { invulnerables: Array<AccountId32> } }
  /**
   * See [`Pallet::force_unstake`].
   **/
  | {
      name: "ForceUnstake";
      params: { stash: AccountId32; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::force_new_era_always`].
   **/
  | { name: "ForceNewEraAlways" }
  /**
   * See [`Pallet::cancel_deferred_slash`].
   **/
  | {
      name: "CancelDeferredSlash";
      params: { era: number; slashIndices: Array<number> };
    }
  /**
   * See [`Pallet::payout_stakers`].
   **/
  | {
      name: "PayoutStakers";
      params: { validatorStash: AccountId32; era: number };
    }
  /**
   * See [`Pallet::rebond`].
   **/
  | { name: "Rebond"; params: { value: bigint } }
  /**
   * See [`Pallet::reap_stash`].
   **/
  | {
      name: "ReapStash";
      params: { stash: AccountId32; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::kick`].
   **/
  | { name: "Kick"; params: { who: Array<MultiAddress> } }
  /**
   * See [`Pallet::set_staking_configs`].
   **/
  | {
      name: "SetStakingConfigs";
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::chill_other`].
   **/
  | { name: "ChillOther"; params: { stash: AccountId32 } }
  /**
   * See [`Pallet::force_apply_min_commission`].
   **/
  | { name: "ForceApplyMinCommission"; params: { validatorStash: AccountId32 } }
  /**
   * See [`Pallet::set_min_commission`].
   **/
  | { name: "SetMinCommission"; params: { new: Perbill } }
  /**
   * See [`Pallet::payout_stakers_by_page`].
   **/
  | {
      name: "PayoutStakersByPage";
      params: { validatorStash: AccountId32; era: number; page: number };
    }
  /**
   * See [`Pallet::update_payee`].
   **/
  | { name: "UpdatePayee"; params: { controller: AccountId32 } }
  /**
   * See [`Pallet::deprecate_controller_batch`].
   **/
  | {
      name: "DeprecateControllerBatch";
      params: { controllers: Array<AccountId32> };
    };

export type PalletStakingPalletCallLike =
  /**
   * See [`Pallet::bond`].
   **/
  | {
      name: "Bond";
      params: { value: bigint; payee: PalletStakingRewardDestination };
    }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: "BondExtra"; params: { maxAdditional: bigint } }
  /**
   * See [`Pallet::unbond`].
   **/
  | { name: "Unbond"; params: { value: bigint } }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | { name: "WithdrawUnbonded"; params: { numSlashingSpans: number } }
  /**
   * See [`Pallet::validate`].
   **/
  | { name: "Validate"; params: { prefs: PalletStakingValidatorPrefs } }
  /**
   * See [`Pallet::nominate`].
   **/
  | { name: "Nominate"; params: { targets: Array<MultiAddressLike> } }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: "Chill" }
  /**
   * See [`Pallet::set_payee`].
   **/
  | { name: "SetPayee"; params: { payee: PalletStakingRewardDestination } }
  /**
   * See [`Pallet::set_controller`].
   **/
  | { name: "SetController" }
  /**
   * See [`Pallet::set_validator_count`].
   **/
  | { name: "SetValidatorCount"; params: { new: number } }
  /**
   * See [`Pallet::increase_validator_count`].
   **/
  | { name: "IncreaseValidatorCount"; params: { additional: number } }
  /**
   * See [`Pallet::scale_validator_count`].
   **/
  | { name: "ScaleValidatorCount"; params: { factor: Percent } }
  /**
   * See [`Pallet::force_no_eras`].
   **/
  | { name: "ForceNoEras" }
  /**
   * See [`Pallet::force_new_era`].
   **/
  | { name: "ForceNewEra" }
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | {
      name: "SetInvulnerables";
      params: { invulnerables: Array<AccountId32Like> };
    }
  /**
   * See [`Pallet::force_unstake`].
   **/
  | {
      name: "ForceUnstake";
      params: { stash: AccountId32Like; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::force_new_era_always`].
   **/
  | { name: "ForceNewEraAlways" }
  /**
   * See [`Pallet::cancel_deferred_slash`].
   **/
  | {
      name: "CancelDeferredSlash";
      params: { era: number; slashIndices: Array<number> };
    }
  /**
   * See [`Pallet::payout_stakers`].
   **/
  | {
      name: "PayoutStakers";
      params: { validatorStash: AccountId32Like; era: number };
    }
  /**
   * See [`Pallet::rebond`].
   **/
  | { name: "Rebond"; params: { value: bigint } }
  /**
   * See [`Pallet::reap_stash`].
   **/
  | {
      name: "ReapStash";
      params: { stash: AccountId32Like; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::kick`].
   **/
  | { name: "Kick"; params: { who: Array<MultiAddressLike> } }
  /**
   * See [`Pallet::set_staking_configs`].
   **/
  | {
      name: "SetStakingConfigs";
      params: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::chill_other`].
   **/
  | { name: "ChillOther"; params: { stash: AccountId32Like } }
  /**
   * See [`Pallet::force_apply_min_commission`].
   **/
  | {
      name: "ForceApplyMinCommission";
      params: { validatorStash: AccountId32Like };
    }
  /**
   * See [`Pallet::set_min_commission`].
   **/
  | { name: "SetMinCommission"; params: { new: Perbill } }
  /**
   * See [`Pallet::payout_stakers_by_page`].
   **/
  | {
      name: "PayoutStakersByPage";
      params: { validatorStash: AccountId32Like; era: number; page: number };
    }
  /**
   * See [`Pallet::update_payee`].
   **/
  | { name: "UpdatePayee"; params: { controller: AccountId32Like } }
  /**
   * See [`Pallet::deprecate_controller_batch`].
   **/
  | {
      name: "DeprecateControllerBatch";
      params: { controllers: Array<AccountId32Like> };
    };

export type PalletStakingPalletConfigOp =
  | { type: "Noop" }
  | { type: "Set"; value: bigint }
  | { type: "Remove" };

export type PalletStakingPalletConfigOpU32 =
  | { type: "Noop" }
  | { type: "Set"; value: number }
  | { type: "Remove" };

export type PalletStakingPalletConfigOpPercent =
  | { type: "Noop" }
  | { type: "Set"; value: Percent }
  | { type: "Remove" };

export type PalletStakingPalletConfigOpPerbill =
  | { type: "Noop" }
  | { type: "Set"; value: Perbill }
  | { type: "Remove" };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | {
      name: "SetKeys";
      params: { keys: DaRuntimePrimitivesSessionKeys; proof: Bytes };
    }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: "PurgeKeys" };

export type PalletSessionCallLike =
  /**
   * See [`Pallet::set_keys`].
   **/
  | {
      name: "SetKeys";
      params: { keys: DaRuntimePrimitivesSessionKeys; proof: BytesLike };
    }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: "PurgeKeys" };

export type DaRuntimePrimitivesSessionKeys = {
  babe: SpConsensusBabeAppPublic;
  grandpa: SpConsensusGrandpaAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
};

export type SpAuthorityDiscoveryAppPublic = SpCoreSr25519Public;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * See [`Pallet::set_members`].
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32>;
        prime?: AccountId32 | undefined;
        oldCount: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | {
      name: "Execute";
      params: { proposal: DaRuntimeRuntimeCall; lengthBound: number };
    }
  /**
   * See [`Pallet::propose`].
   **/
  | {
      name: "Propose";
      params: {
        threshold: number;
        proposal: DaRuntimeRuntimeCall;
        lengthBound: number;
      };
    }
  /**
   * See [`Pallet::vote`].
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * See [`Pallet::disapprove_proposal`].
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::close`].
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    };

export type PalletCollectiveCallLike =
  /**
   * See [`Pallet::set_members`].
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32Like>;
        prime?: AccountId32Like | undefined;
        oldCount: number;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | {
      name: "Execute";
      params: { proposal: DaRuntimeRuntimeCallLike; lengthBound: number };
    }
  /**
   * See [`Pallet::propose`].
   **/
  | {
      name: "Propose";
      params: {
        threshold: number;
        proposal: DaRuntimeRuntimeCallLike;
        lengthBound: number;
      };
    }
  /**
   * See [`Pallet::vote`].
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * See [`Pallet::disapprove_proposal`].
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::close`].
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::note_stalled`].
   **/
  | {
      name: "NoteStalled";
      params: { delay: number; bestFinalizedBlockNumber: number };
    };

export type PalletGrandpaCallLike =
  /**
   * See [`Pallet::report_equivocation`].
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::report_equivocation_unsigned`].
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpSessionMembershipProof;
      };
    }
  /**
   * See [`Pallet::note_stalled`].
   **/
  | {
      name: "NoteStalled";
      params: { delay: number; bestFinalizedBlockNumber: number };
    };

export type SpConsensusGrandpaEquivocationProof = {
  setId: bigint;
  equivocation: SpConsensusGrandpaEquivocation;
};

export type SpConsensusGrandpaEquivocation =
  | { type: "Prevote"; value: FinalityGrandpaEquivocation }
  | { type: "Precommit"; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = SpCoreEd25519Signature;

export type SpCoreEd25519Signature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = {
  targetHash: H256;
  targetNumber: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | {
      name: "ProposeSpend";
      params: { value: bigint; beneficiary: MultiAddress };
    }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: "RejectProposal"; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: "ApproveProposal"; params: { proposalId: number } }
  /**
   * See [`Pallet::spend_local`].
   **/
  | {
      name: "SpendLocal";
      params: { amount: bigint; beneficiary: MultiAddress };
    }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: "RemoveApproval"; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | {
      name: "Spend";
      params: {
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom?: number | undefined;
      };
    }
  /**
   * See [`Pallet::payout`].
   **/
  | { name: "Payout"; params: { index: number } }
  /**
   * See [`Pallet::check_status`].
   **/
  | { name: "CheckStatus"; params: { index: number } }
  /**
   * See [`Pallet::void_spend`].
   **/
  | { name: "VoidSpend"; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | {
      name: "ProposeSpend";
      params: { value: bigint; beneficiary: MultiAddressLike };
    }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: "RejectProposal"; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: "ApproveProposal"; params: { proposalId: number } }
  /**
   * See [`Pallet::spend_local`].
   **/
  | {
      name: "SpendLocal";
      params: { amount: bigint; beneficiary: MultiAddressLike };
    }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: "RemoveApproval"; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | {
      name: "Spend";
      params: {
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32Like;
        validFrom?: number | undefined;
      };
    }
  /**
   * See [`Pallet::payout`].
   **/
  | { name: "Payout"; params: { index: number } }
  /**
   * See [`Pallet::check_status`].
   **/
  | { name: "CheckStatus"; params: { index: number } }
  /**
   * See [`Pallet::void_spend`].
   **/
  | { name: "VoidSpend"; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: "Sudo"; params: { call: DaRuntimeRuntimeCall } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | {
      name: "SudoUncheckedWeight";
      params: { call: DaRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight };
    }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: "SetKey"; params: { new: MultiAddress } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | {
      name: "SudoAs";
      params: { who: MultiAddress; call: DaRuntimeRuntimeCall };
    }
  /**
   * See [`Pallet::remove_key`].
   **/
  | { name: "RemoveKey" };

export type PalletSudoCallLike =
  /**
   * See [`Pallet::sudo`].
   **/
  | { name: "Sudo"; params: { call: DaRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::sudo_unchecked_weight`].
   **/
  | {
      name: "SudoUncheckedWeight";
      params: {
        call: DaRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::set_key`].
   **/
  | { name: "SetKey"; params: { new: MultiAddressLike } }
  /**
   * See [`Pallet::sudo_as`].
   **/
  | {
      name: "SudoAs";
      params: { who: MultiAddressLike; call: DaRuntimeRuntimeCallLike };
    }
  /**
   * See [`Pallet::remove_key`].
   **/
  | { name: "RemoveKey" };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletImOnlineCall =
  /**
   * See [`Pallet::heartbeat`].
   **/
  {
    name: "Heartbeat";
    params: {
      heartbeat: PalletImOnlineHeartbeat;
      signature: PalletImOnlineSr25519AppSr25519Signature;
    };
  };

export type PalletImOnlineCallLike =
  /**
   * See [`Pallet::heartbeat`].
   **/
  {
    name: "Heartbeat";
    params: {
      heartbeat: PalletImOnlineHeartbeat;
      signature: PalletImOnlineSr25519AppSr25519Signature;
    };
  };

export type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

export type PalletImOnlineSr25519AppSr25519Signature = SpCoreSr25519Signature;

export type SpCoreSr25519Signature = FixedBytes<64>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCall;
      };
    };

export type PalletSchedulerCallLike =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: DaRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type DaControlCall =
  /**
   * See [`Pallet::create_application_key`].
   **/
  | { name: "CreateApplicationKey"; params: { key: Bytes } }
  /**
   * See [`Pallet::submit_data`].
   **/
  | { name: "SubmitData"; params: { data: Bytes } }
  /**
   * See [`Pallet::submit_block_length_proposal`].
   **/
  | {
      name: "SubmitBlockLengthProposal";
      params: { rows: number; cols: number };
    }
  /**
   * See [`Pallet::set_application_key`].
   **/
  | { name: "SetApplicationKey"; params: { oldKey: Bytes; newKey: Bytes } }
  /**
   * See [`Pallet::set_submit_data_fee_modifier`].
   **/
  | {
      name: "SetSubmitDataFeeModifier";
      params: { modifier: FrameSupportDispatchDispatchFeeModifier };
    };

export type DaControlCallLike =
  /**
   * See [`Pallet::create_application_key`].
   **/
  | { name: "CreateApplicationKey"; params: { key: BytesLike } }
  /**
   * See [`Pallet::submit_data`].
   **/
  | { name: "SubmitData"; params: { data: BytesLike } }
  /**
   * See [`Pallet::submit_block_length_proposal`].
   **/
  | {
      name: "SubmitBlockLengthProposal";
      params: { rows: number; cols: number };
    }
  /**
   * See [`Pallet::set_application_key`].
   **/
  | {
      name: "SetApplicationKey";
      params: { oldKey: BytesLike; newKey: BytesLike };
    }
  /**
   * See [`Pallet::set_submit_data_fee_modifier`].
   **/
  | {
      name: "SetSubmitDataFeeModifier";
      params: { modifier: FrameSupportDispatchDispatchFeeModifier };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * See [`Pallet::note_preimage`].
   **/
  | { name: "NotePreimage"; params: { bytes: Bytes } }
  /**
   * See [`Pallet::unnote_preimage`].
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::request_preimage`].
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::unrequest_preimage`].
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::ensure_updated`].
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * See [`Pallet::note_preimage`].
   **/
  | { name: "NotePreimage"; params: { bytes: BytesLike } }
  /**
   * See [`Pallet::unnote_preimage`].
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::request_preimage`].
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::unrequest_preimage`].
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * See [`Pallet::ensure_updated`].
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32>;
        call: DaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: DaRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32Like>;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: DaRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBagsListCall =
  /**
   * See [`Pallet::rebag`].
   **/
  | { name: "Rebag"; params: { dislocated: MultiAddress } }
  /**
   * See [`Pallet::put_in_front_of`].
   **/
  | { name: "PutInFrontOf"; params: { lighter: MultiAddress } }
  /**
   * See [`Pallet::put_in_front_of_other`].
   **/
  | {
      name: "PutInFrontOfOther";
      params: { heavier: MultiAddress; lighter: MultiAddress };
    };

export type PalletBagsListCallLike =
  /**
   * See [`Pallet::rebag`].
   **/
  | { name: "Rebag"; params: { dislocated: MultiAddressLike } }
  /**
   * See [`Pallet::put_in_front_of`].
   **/
  | { name: "PutInFrontOf"; params: { lighter: MultiAddressLike } }
  /**
   * See [`Pallet::put_in_front_of_other`].
   **/
  | {
      name: "PutInFrontOfOther";
      params: { heavier: MultiAddressLike; lighter: MultiAddressLike };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  /**
   * See [`Pallet::join`].
   **/
  | { name: "Join"; params: { amount: bigint; poolId: number } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: "BondExtra"; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::claim_payout`].
   **/
  | { name: "ClaimPayout" }
  /**
   * See [`Pallet::unbond`].
   **/
  | {
      name: "Unbond";
      params: { memberAccount: MultiAddress; unbondingPoints: bigint };
    }
  /**
   * See [`Pallet::pool_withdraw_unbonded`].
   **/
  | {
      name: "PoolWithdrawUnbonded";
      params: { poolId: number; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | {
      name: "WithdrawUnbonded";
      params: { memberAccount: MultiAddress; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: "Create";
      params: {
        amount: bigint;
        root: MultiAddress;
        nominator: MultiAddress;
        bouncer: MultiAddress;
      };
    }
  /**
   * See [`Pallet::create_with_pool_id`].
   **/
  | {
      name: "CreateWithPoolId";
      params: {
        amount: bigint;
        root: MultiAddress;
        nominator: MultiAddress;
        bouncer: MultiAddress;
        poolId: number;
      };
    }
  /**
   * See [`Pallet::nominate`].
   **/
  | {
      name: "Nominate";
      params: { poolId: number; validators: Array<AccountId32> };
    }
  /**
   * See [`Pallet::set_state`].
   **/
  | {
      name: "SetState";
      params: { poolId: number; state: PalletNominationPoolsPoolState };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: "SetMetadata"; params: { poolId: number; metadata: Bytes } }
  /**
   * See [`Pallet::set_configs`].
   **/
  | {
      name: "SetConfigs";
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::update_roles`].
   **/
  | {
      name: "UpdateRoles";
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: "Chill"; params: { poolId: number } }
  /**
   * See [`Pallet::bond_extra_other`].
   **/
  | {
      name: "BondExtraOther";
      params: { member: MultiAddress; extra: PalletNominationPoolsBondExtra };
    }
  /**
   * See [`Pallet::set_claim_permission`].
   **/
  | {
      name: "SetClaimPermission";
      params: { permission: PalletNominationPoolsClaimPermission };
    }
  /**
   * See [`Pallet::claim_payout_other`].
   **/
  | { name: "ClaimPayoutOther"; params: { other: AccountId32 } }
  /**
   * See [`Pallet::set_commission`].
   **/
  | {
      name: "SetCommission";
      params: {
        poolId: number;
        newCommission?: [Perbill, AccountId32] | undefined;
      };
    }
  /**
   * See [`Pallet::set_commission_max`].
   **/
  | {
      name: "SetCommissionMax";
      params: { poolId: number; maxCommission: Perbill };
    }
  /**
   * See [`Pallet::set_commission_change_rate`].
   **/
  | {
      name: "SetCommissionChangeRate";
      params: {
        poolId: number;
        changeRate: PalletNominationPoolsCommissionChangeRate;
      };
    }
  /**
   * See [`Pallet::claim_commission`].
   **/
  | { name: "ClaimCommission"; params: { poolId: number } }
  /**
   * See [`Pallet::adjust_pool_deposit`].
   **/
  | { name: "AdjustPoolDeposit"; params: { poolId: number } }
  /**
   * See [`Pallet::set_commission_claim_permission`].
   **/
  | {
      name: "SetCommissionClaimPermission";
      params: {
        poolId: number;
        permission?: PalletNominationPoolsCommissionClaimPermission | undefined;
      };
    };

export type PalletNominationPoolsCallLike =
  /**
   * See [`Pallet::join`].
   **/
  | { name: "Join"; params: { amount: bigint; poolId: number } }
  /**
   * See [`Pallet::bond_extra`].
   **/
  | { name: "BondExtra"; params: { extra: PalletNominationPoolsBondExtra } }
  /**
   * See [`Pallet::claim_payout`].
   **/
  | { name: "ClaimPayout" }
  /**
   * See [`Pallet::unbond`].
   **/
  | {
      name: "Unbond";
      params: { memberAccount: MultiAddressLike; unbondingPoints: bigint };
    }
  /**
   * See [`Pallet::pool_withdraw_unbonded`].
   **/
  | {
      name: "PoolWithdrawUnbonded";
      params: { poolId: number; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::withdraw_unbonded`].
   **/
  | {
      name: "WithdrawUnbonded";
      params: { memberAccount: MultiAddressLike; numSlashingSpans: number };
    }
  /**
   * See [`Pallet::create`].
   **/
  | {
      name: "Create";
      params: {
        amount: bigint;
        root: MultiAddressLike;
        nominator: MultiAddressLike;
        bouncer: MultiAddressLike;
      };
    }
  /**
   * See [`Pallet::create_with_pool_id`].
   **/
  | {
      name: "CreateWithPoolId";
      params: {
        amount: bigint;
        root: MultiAddressLike;
        nominator: MultiAddressLike;
        bouncer: MultiAddressLike;
        poolId: number;
      };
    }
  /**
   * See [`Pallet::nominate`].
   **/
  | {
      name: "Nominate";
      params: { poolId: number; validators: Array<AccountId32Like> };
    }
  /**
   * See [`Pallet::set_state`].
   **/
  | {
      name: "SetState";
      params: { poolId: number; state: PalletNominationPoolsPoolState };
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: "SetMetadata"; params: { poolId: number; metadata: BytesLike } }
  /**
   * See [`Pallet::set_configs`].
   **/
  | {
      name: "SetConfigs";
      params: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  /**
   * See [`Pallet::update_roles`].
   **/
  | {
      name: "UpdateRoles";
      params: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  /**
   * See [`Pallet::chill`].
   **/
  | { name: "Chill"; params: { poolId: number } }
  /**
   * See [`Pallet::bond_extra_other`].
   **/
  | {
      name: "BondExtraOther";
      params: {
        member: MultiAddressLike;
        extra: PalletNominationPoolsBondExtra;
      };
    }
  /**
   * See [`Pallet::set_claim_permission`].
   **/
  | {
      name: "SetClaimPermission";
      params: { permission: PalletNominationPoolsClaimPermission };
    }
  /**
   * See [`Pallet::claim_payout_other`].
   **/
  | { name: "ClaimPayoutOther"; params: { other: AccountId32Like } }
  /**
   * See [`Pallet::set_commission`].
   **/
  | {
      name: "SetCommission";
      params: {
        poolId: number;
        newCommission?: [Perbill, AccountId32Like] | undefined;
      };
    }
  /**
   * See [`Pallet::set_commission_max`].
   **/
  | {
      name: "SetCommissionMax";
      params: { poolId: number; maxCommission: Perbill };
    }
  /**
   * See [`Pallet::set_commission_change_rate`].
   **/
  | {
      name: "SetCommissionChangeRate";
      params: {
        poolId: number;
        changeRate: PalletNominationPoolsCommissionChangeRate;
      };
    }
  /**
   * See [`Pallet::claim_commission`].
   **/
  | { name: "ClaimCommission"; params: { poolId: number } }
  /**
   * See [`Pallet::adjust_pool_deposit`].
   **/
  | { name: "AdjustPoolDeposit"; params: { poolId: number } }
  /**
   * See [`Pallet::set_commission_claim_permission`].
   **/
  | {
      name: "SetCommissionClaimPermission";
      params: {
        poolId: number;
        permission?: PalletNominationPoolsCommissionClaimPermission | undefined;
      };
    };

export type PalletNominationPoolsBondExtra =
  | { type: "FreeBalance"; value: bigint }
  | { type: "Rewards" };

export type PalletNominationPoolsConfigOp =
  | { type: "Noop" }
  | { type: "Set"; value: bigint }
  | { type: "Remove" };

export type PalletNominationPoolsConfigOpU32 =
  | { type: "Noop" }
  | { type: "Set"; value: number }
  | { type: "Remove" };

export type PalletNominationPoolsConfigOpPerbill =
  | { type: "Noop" }
  | { type: "Set"; value: Perbill }
  | { type: "Remove" };

export type PalletNominationPoolsConfigOp004 =
  | { type: "Noop" }
  | { type: "Set"; value: AccountId32 }
  | { type: "Remove" };

export type PalletNominationPoolsClaimPermission =
  | "Permissioned"
  | "PermissionlessCompound"
  | "PermissionlessWithdraw"
  | "PermissionlessAll";

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: "AddRegistrar"; params: { account: MultiAddress } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: "SetIdentity"; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: "SetSubs"; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: "ClearIdentity" }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: "RequestJudgement"; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: "CancelRequest"; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: "SetFee"; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: "SetAccountId"; params: { index: number; new: MultiAddress } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: "SetFields"; params: { index: number; fields: bigint } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: "ProvideJudgement";
      params: {
        regIndex: number;
        target: MultiAddress;
        judgement: PalletIdentityJudgement;
        identity: H256;
      };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: "KillIdentity"; params: { target: MultiAddress } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: "AddSub"; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: "RenameSub"; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: "RemoveSub"; params: { sub: MultiAddress } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: "QuitSub" }
  /**
   * See [`Pallet::add_username_authority`].
   **/
  | {
      name: "AddUsernameAuthority";
      params: { authority: MultiAddress; suffix: Bytes; allocation: number };
    }
  /**
   * See [`Pallet::remove_username_authority`].
   **/
  | { name: "RemoveUsernameAuthority"; params: { authority: MultiAddress } }
  /**
   * See [`Pallet::set_username_for`].
   **/
  | {
      name: "SetUsernameFor";
      params: {
        who: MultiAddress;
        username: Bytes;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * See [`Pallet::accept_username`].
   **/
  | { name: "AcceptUsername"; params: { username: Bytes } }
  /**
   * See [`Pallet::remove_expired_approval`].
   **/
  | { name: "RemoveExpiredApproval"; params: { username: Bytes } }
  /**
   * See [`Pallet::set_primary_username`].
   **/
  | { name: "SetPrimaryUsername"; params: { username: Bytes } }
  /**
   * See [`Pallet::remove_dangling_username`].
   **/
  | { name: "RemoveDanglingUsername"; params: { username: Bytes } };

export type PalletIdentityCallLike =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: "AddRegistrar"; params: { account: MultiAddressLike } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: "SetIdentity"; params: { info: PalletIdentityLegacyIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: "SetSubs"; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: "ClearIdentity" }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: "RequestJudgement"; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: "CancelRequest"; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: "SetFee"; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: "SetAccountId"; params: { index: number; new: MultiAddressLike } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: "SetFields"; params: { index: number; fields: bigint } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: "ProvideJudgement";
      params: {
        regIndex: number;
        target: MultiAddressLike;
        judgement: PalletIdentityJudgement;
        identity: H256;
      };
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: "KillIdentity"; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: "AddSub"; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: "RenameSub"; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: "RemoveSub"; params: { sub: MultiAddressLike } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: "QuitSub" }
  /**
   * See [`Pallet::add_username_authority`].
   **/
  | {
      name: "AddUsernameAuthority";
      params: {
        authority: MultiAddressLike;
        suffix: BytesLike;
        allocation: number;
      };
    }
  /**
   * See [`Pallet::remove_username_authority`].
   **/
  | { name: "RemoveUsernameAuthority"; params: { authority: MultiAddressLike } }
  /**
   * See [`Pallet::set_username_for`].
   **/
  | {
      name: "SetUsernameFor";
      params: {
        who: MultiAddressLike;
        username: BytesLike;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * See [`Pallet::accept_username`].
   **/
  | { name: "AcceptUsername"; params: { username: BytesLike } }
  /**
   * See [`Pallet::remove_expired_approval`].
   **/
  | { name: "RemoveExpiredApproval"; params: { username: BytesLike } }
  /**
   * See [`Pallet::set_primary_username`].
   **/
  | { name: "SetPrimaryUsername"; params: { username: BytesLike } }
  /**
   * See [`Pallet::remove_dangling_username`].
   **/
  | { name: "RemoveDanglingUsername"; params: { username: BytesLike } };

export type PalletIdentityLegacyIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityJudgement =
  | { type: "Unknown" }
  | { type: "FeePaid"; value: bigint }
  | { type: "Reasonable" }
  | { type: "KnownGood" }
  | { type: "OutOfDate" }
  | { type: "LowQuality" }
  | { type: "Erroneous" };

export type SpRuntimeMultiSignature =
  | { type: "Ed25519"; value: SpCoreEd25519Signature }
  | { type: "Sr25519"; value: SpCoreSr25519Signature }
  | { type: "Ecdsa"; value: SpCoreEcdsaSignature };

export type SpCoreEcdsaSignature = FixedBytes<65>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMandateCall =
  /**
   * See [`Pallet::mandate`].
   **/
  { name: "Mandate"; params: { call: DaRuntimeRuntimeCall } };

export type PalletMandateCallLike =
  /**
   * See [`Pallet::mandate`].
   **/
  { name: "Mandate"; params: { call: DaRuntimeRuntimeCallLike } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVectorCall =
  /**
   * See [`Pallet::fulfill_call`].
   **/
  | {
      name: "FulfillCall";
      params: {
        functionId: H256;
        input: Bytes;
        output: Bytes;
        proof: Bytes;
        slot: bigint;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | {
      name: "Execute";
      params: {
        slot: bigint;
        addrMessage: AvailCoreDataProofMessageAddressedMessage;
        accountProof: Array<Bytes>;
        storageProof: Array<Bytes>;
      };
    }
  /**
   * See [`Pallet::source_chain_froze`].
   **/
  | {
      name: "SourceChainFroze";
      params: { sourceChainId: number; frozen: boolean };
    }
  /**
   * See [`Pallet::send_message`].
   **/
  | {
      name: "SendMessage";
      params: { message: AvailCoreDataProofMessage; to: H256; domain: number };
    }
  /**
   * See [`Pallet::set_poseidon_hash`].
   **/
  | { name: "SetPoseidonHash"; params: { period: bigint; poseidonHash: Bytes } }
  /**
   * See [`Pallet::set_broadcaster`].
   **/
  | {
      name: "SetBroadcaster";
      params: { broadcasterDomain: number; broadcaster: H256 };
    }
  /**
   * See [`Pallet::set_whitelisted_domains`].
   **/
  | { name: "SetWhitelistedDomains"; params: { value: Array<number> } }
  /**
   * See [`Pallet::set_configuration`].
   **/
  | {
      name: "SetConfiguration";
      params: { value: PalletVectorStateConfiguration };
    }
  /**
   * See [`Pallet::set_function_ids`].
   **/
  | { name: "SetFunctionIds"; params: { value?: [H256, H256] | undefined } }
  /**
   * See [`Pallet::set_step_verification_key`].
   **/
  | { name: "SetStepVerificationKey"; params: { value?: Bytes | undefined } }
  /**
   * See [`Pallet::set_rotate_verification_key`].
   **/
  | { name: "SetRotateVerificationKey"; params: { value?: Bytes | undefined } }
  /**
   * See [`Pallet::failed_send_message_txs`].
   **/
  | { name: "FailedSendMessageTxs"; params: { failedTxs: Array<number> } }
  /**
   * See [`Pallet::set_updater`].
   **/
  | { name: "SetUpdater"; params: { updater: H256 } }
  /**
   * See [`Pallet::fulfill`].
   **/
  | { name: "Fulfill"; params: { proof: Bytes; publicValues: Bytes } }
  /**
   * See [`Pallet::set_sp1_verification_key`].
   **/
  | { name: "SetSp1VerificationKey"; params: { sp1Vk: H256 } }
  /**
   * See [`Pallet::set_sync_committee_hash`].
   **/
  | { name: "SetSyncCommitteeHash"; params: { period: bigint; hash: H256 } }
  /**
   * See [`Pallet::enable_mock`].
   **/
  | { name: "EnableMock"; params: { value: boolean } }
  /**
   * See [`Pallet::mock_fulfill`].
   **/
  | { name: "MockFulfill"; params: { publicValues: Bytes } };

export type PalletVectorCallLike =
  /**
   * See [`Pallet::fulfill_call`].
   **/
  | {
      name: "FulfillCall";
      params: {
        functionId: H256;
        input: BytesLike;
        output: BytesLike;
        proof: BytesLike;
        slot: bigint;
      };
    }
  /**
   * See [`Pallet::execute`].
   **/
  | {
      name: "Execute";
      params: {
        slot: bigint;
        addrMessage: AvailCoreDataProofMessageAddressedMessage;
        accountProof: Array<BytesLike>;
        storageProof: Array<BytesLike>;
      };
    }
  /**
   * See [`Pallet::source_chain_froze`].
   **/
  | {
      name: "SourceChainFroze";
      params: { sourceChainId: number; frozen: boolean };
    }
  /**
   * See [`Pallet::send_message`].
   **/
  | {
      name: "SendMessage";
      params: { message: AvailCoreDataProofMessage; to: H256; domain: number };
    }
  /**
   * See [`Pallet::set_poseidon_hash`].
   **/
  | {
      name: "SetPoseidonHash";
      params: { period: bigint; poseidonHash: BytesLike };
    }
  /**
   * See [`Pallet::set_broadcaster`].
   **/
  | {
      name: "SetBroadcaster";
      params: { broadcasterDomain: number; broadcaster: H256 };
    }
  /**
   * See [`Pallet::set_whitelisted_domains`].
   **/
  | { name: "SetWhitelistedDomains"; params: { value: Array<number> } }
  /**
   * See [`Pallet::set_configuration`].
   **/
  | {
      name: "SetConfiguration";
      params: { value: PalletVectorStateConfiguration };
    }
  /**
   * See [`Pallet::set_function_ids`].
   **/
  | { name: "SetFunctionIds"; params: { value?: [H256, H256] | undefined } }
  /**
   * See [`Pallet::set_step_verification_key`].
   **/
  | {
      name: "SetStepVerificationKey";
      params: { value?: BytesLike | undefined };
    }
  /**
   * See [`Pallet::set_rotate_verification_key`].
   **/
  | {
      name: "SetRotateVerificationKey";
      params: { value?: BytesLike | undefined };
    }
  /**
   * See [`Pallet::failed_send_message_txs`].
   **/
  | { name: "FailedSendMessageTxs"; params: { failedTxs: Array<number> } }
  /**
   * See [`Pallet::set_updater`].
   **/
  | { name: "SetUpdater"; params: { updater: H256 } }
  /**
   * See [`Pallet::fulfill`].
   **/
  | { name: "Fulfill"; params: { proof: BytesLike; publicValues: BytesLike } }
  /**
   * See [`Pallet::set_sp1_verification_key`].
   **/
  | { name: "SetSp1VerificationKey"; params: { sp1Vk: H256 } }
  /**
   * See [`Pallet::set_sync_committee_hash`].
   **/
  | { name: "SetSyncCommitteeHash"; params: { period: bigint; hash: H256 } }
  /**
   * See [`Pallet::enable_mock`].
   **/
  | { name: "EnableMock"; params: { value: boolean } }
  /**
   * See [`Pallet::mock_fulfill`].
   **/
  | { name: "MockFulfill"; params: { publicValues: BytesLike } };

export type AvailCoreDataProofMessageAddressedMessage = {
  message: AvailCoreDataProofMessage;
  from: H256;
  to: H256;
  originDomain: number;
  destinationDomain: number;
  id: bigint;
};

export type AvailCoreDataProofMessage =
  | { type: "ArbitraryMessage"; value: Bytes }
  | { type: "FungibleToken"; value: { assetId: H256; amount: bigint } };

export type PalletVectorStateConfiguration = {
  slotsPerPeriod: bigint;
  finalityThreshold: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddress;
        forceProxyType?: DaRuntimeImplsProxyType | undefined;
        call: DaRuntimeRuntimeCall;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddress;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddress;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: "RemoveProxies" }
  /**
   * See [`Pallet::create_pure`].
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddress;
        proxyType: DaRuntimeImplsProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: "Announce"; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddress; callHash: H256 };
    }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddress; callHash: H256 };
    }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: DaRuntimeImplsProxyType | undefined;
        call: DaRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddressLike;
        forceProxyType?: DaRuntimeImplsProxyType | undefined;
        call: DaRuntimeRuntimeCallLike;
      };
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
      };
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: "RemoveProxies" }
  /**
   * See [`Pallet::create_pure`].
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: DaRuntimeImplsProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddressLike;
        proxyType: DaRuntimeImplsProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: "Announce"; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddressLike; callHash: H256 };
    }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddressLike; callHash: H256 };
    }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: DaRuntimeImplsProxyType | undefined;
        call: DaRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTxPauseCall =
  /**
   * See [`Pallet::pause`].
   **/
  | { name: "Pause"; params: { fullName: [Bytes, Bytes] } }
  /**
   * See [`Pallet::unpause`].
   **/
  | { name: "Unpause"; params: { ident: [Bytes, Bytes] } };

export type PalletTxPauseCallLike =
  /**
   * See [`Pallet::pause`].
   **/
  | { name: "Pause"; params: { fullName: [BytesLike, BytesLike] } }
  /**
   * See [`Pallet::unpause`].
   **/
  | { name: "Unpause"; params: { ident: [BytesLike, BytesLike] } };

export type DaRuntimeOriginCaller =
  | { type: "System"; value: FrameSupportDispatchRawOrigin }
  | { type: "TechnicalCommittee"; value: PalletCollectiveRawOrigin }
  | { type: "TreasuryCommittee"; value: PalletCollectiveRawOrigin }
  | { type: "Void"; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { type: "Root" }
  | { type: "Signed"; value: AccountId32 }
  | { type: "None" };

export type PalletCollectiveRawOrigin =
  | { type: "Members"; value: [number, number] }
  | { type: "Member"; value: AccountId32 }
  | { type: "Phantom" };

export type SpCoreVoid = null;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  "TooManyCalls";

export type SpConsensusBabeDigestsPreDigest =
  | { type: "Primary"; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | {
      type: "SecondaryPlain";
      value: SpConsensusBabeDigestsSecondaryPlainPreDigest;
    }
  | {
      type: "SecondaryVRF";
      value: SpConsensusBabeDigestsSecondaryVRFPreDigest;
    };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = {
  preOutput: FixedBytes<32>;
  proof: FixedBytes<64>;
};

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
};

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = {
  c: [bigint, bigint];
  allowedSlots: SpConsensusBabeAllowedSlots;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidEquivocationProof"
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidKeyOwnershipProof"
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | "DuplicateOffenceReport"
  /**
   * Submitted configuration is invalid.
   **/
  | "InvalidConfiguration";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndicesError =
  /**
   * The index was not already assigned.
   **/
  | "NotAssigned"
  /**
   * The index is assigned to another account.
   **/
  | "NotOwner"
  /**
   * The index was not available.
   **/
  | "InUse"
  /**
   * The source and destination accounts are identical.
   **/
  | "NotTransfer"
  /**
   * The index is permanent and may not be freed/changed.
   **/
  | "Permanent";

export type PalletBalancesBalanceLock = {
  id: FixedBytes<8>;
  amount: bigint;
  reasons: PalletBalancesReasons;
};

export type PalletBalancesReasons = "Fee" | "Misc" | "All";

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = {
  id: DaRuntimeRuntimeHoldReason;
  amount: bigint;
};

export type DaRuntimeRuntimeHoldReason = {
  type: "Preimage";
  value: PalletPreimageHoldReason;
};

export type PalletPreimageHoldReason = "Preimage";

export type PalletBalancesIdAmountRuntimeFreezeReason = {
  id: DaRuntimeRuntimeFreezeReason;
  amount: bigint;
};

export type DaRuntimeRuntimeFreezeReason = {
  type: "NominationPools";
  value: PalletNominationPoolsFreezeReason;
};

export type PalletNominationPoolsFreezeReason = "PoolMinBalance";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | "VestingBalance"
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | "LiquidityRestrictions"
  /**
   * Balance too low to send value.
   **/
  | "InsufficientBalance"
  /**
   * Value too low to create account due to existential deposit.
   **/
  | "ExistentialDeposit"
  /**
   * Transfer/payment would kill account.
   **/
  | "Expendability"
  /**
   * A vesting schedule already exists for this account.
   **/
  | "ExistingVestingSchedule"
  /**
   * Beneficiary account must pre-exist.
   **/
  | "DeadAccount"
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | "TooManyReserves"
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | "TooManyHolds"
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | "TooManyFreezes"
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | "IssuanceDeactivated"
  /**
   * The delta cannot be zero.
   **/
  | "DeltaZero";

export type PalletTransactionPaymentReleases = "V1Ancient" | "V2";

export type PalletElectionProviderMultiPhaseReadySolution = {
  supports: Array<[AccountId32, SpNposElectionsSupport]>;
  score: SpNposElectionsElectionScore;
  compute: PalletElectionProviderMultiPhaseElectionCompute;
};

export type PalletElectionProviderMultiPhaseRoundSnapshot = {
  voters: Array<[AccountId32, bigint, Array<AccountId32>]>;
  targets: Array<AccountId32>;
};

export type PalletElectionProviderMultiPhaseSignedSignedSubmission = {
  who: AccountId32;
  deposit: bigint;
  rawSolution: PalletElectionProviderMultiPhaseRawSolution;
  callFee: bigint;
};

/**
 * Error of the pallet that can be returned in response to dispatches.
 **/
export type PalletElectionProviderMultiPhaseError =
  /**
   * Submission was too early.
   **/
  | "PreDispatchEarlySubmission"
  /**
   * Wrong number of winners presented.
   **/
  | "PreDispatchWrongWinnerCount"
  /**
   * Submission was too weak, score-wise.
   **/
  | "PreDispatchWeakSubmission"
  /**
   * The queue was full, and the solution was not better than any of the existing ones.
   **/
  | "SignedQueueFull"
  /**
   * The origin failed to pay the deposit.
   **/
  | "SignedCannotPayDeposit"
  /**
   * Witness data to dispatchable is invalid.
   **/
  | "SignedInvalidWitness"
  /**
   * The signed submission consumes too much weight
   **/
  | "SignedTooMuchWeight"
  /**
   * OCW submitted solution for wrong round
   **/
  | "OcwCallWrongEra"
  /**
   * Snapshot metadata should exist but didn't.
   **/
  | "MissingSnapshotMetadata"
  /**
   * `Self::insert_submission` returned an invalid index.
   **/
  | "InvalidSubmissionIndex"
  /**
   * The call is not allowed at this point.
   **/
  | "CallNotAllowed"
  /**
   * The fallback failed
   **/
  | "FallbackFailed"
  /**
   * Some bound not met
   **/
  | "BoundNotMet"
  /**
   * Submitted solution has too many winners
   **/
  | "TooManyWinners"
  /**
   * Sumission was prepared for a different round.
   **/
  | "PreDispatchDifferentRound";

export type PalletStakingStakingLedger = {
  stash: AccountId32;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  legacyClaimedRewards: Array<number>;
};

export type PalletStakingUnlockChunk = { value: bigint; era: number };

export type PalletStakingNominations = {
  targets: Array<AccountId32>;
  submittedIn: number;
  suppressed: boolean;
};

export type PalletStakingActiveEraInfo = {
  index: number;
  start?: bigint | undefined;
};

export type SpStakingPagedExposureMetadata = {
  total: bigint;
  own: bigint;
  nominatorCount: number;
  pageCount: number;
};

export type SpStakingExposurePage = {
  pageTotal: bigint;
  others: Array<SpStakingIndividualExposure>;
};

export type PalletStakingEraRewardPoints = {
  total: number;
  individual: Array<[AccountId32, number]>;
};

export type PalletStakingUnappliedSlash = {
  validator: AccountId32;
  own: bigint;
  others: Array<[AccountId32, bigint]>;
  reporters: Array<AccountId32>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = {
  slashed: bigint;
  paidOut: bigint;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | "NotController"
  /**
   * Not a stash account.
   **/
  | "NotStash"
  /**
   * Stash is already bonded.
   **/
  | "AlreadyBonded"
  /**
   * Controller is already paired.
   **/
  | "AlreadyPaired"
  /**
   * Targets cannot be empty.
   **/
  | "EmptyTargets"
  /**
   * Duplicate index.
   **/
  | "DuplicateIndex"
  /**
   * Slash record index out of bounds.
   **/
  | "InvalidSlashIndex"
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | "InsufficientBond"
  /**
   * Can not schedule more unlock chunks.
   **/
  | "NoMoreChunks"
  /**
   * Can not rebond without unlocking chunks.
   **/
  | "NoUnlockChunk"
  /**
   * Attempting to target a stash that still has funds.
   **/
  | "FundedTarget"
  /**
   * Invalid era to reward.
   **/
  | "InvalidEraToReward"
  /**
   * Invalid number of nominations.
   **/
  | "InvalidNumberOfNominations"
  /**
   * Items are not sorted and unique.
   **/
  | "NotSortedAndUnique"
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | "AlreadyClaimed"
  /**
   * No nominators exist on this page.
   **/
  | "InvalidPage"
  /**
   * Incorrect previous history depth input provided.
   **/
  | "IncorrectHistoryDepth"
  /**
   * Incorrect number of slashing spans provided.
   **/
  | "IncorrectSlashingSpans"
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | "BadState"
  /**
   * Too many nomination targets supplied.
   **/
  | "TooManyTargets"
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | "BadTarget"
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | "CannotChillOther"
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | "TooManyNominators"
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | "TooManyValidators"
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | "CommissionTooLow"
  /**
   * Some bound is not met.
   **/
  | "BoundNotMet"
  /**
   * Used when attempting to use deprecated controller account logic.
   **/
  | "ControllerDeprecated";

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | "InvalidProof"
  /**
   * No associated validator ID for account.
   **/
  | "NoAssociatedValidatorId"
  /**
   * Registered duplicate key.
   **/
  | "DuplicatedKey"
  /**
   * No keys are associated with this account.
   **/
  | "NoKeys"
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | "NoAccount";

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32>;
  nays: Array<AccountId32>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | "NotMember"
  /**
   * Duplicate proposals not allowed
   **/
  | "DuplicateProposal"
  /**
   * Proposal must exist
   **/
  | "ProposalMissing"
  /**
   * Mismatched index
   **/
  | "WrongIndex"
  /**
   * Duplicate vote ignored
   **/
  | "DuplicateVote"
  /**
   * Members are already initialized!
   **/
  | "AlreadyInitialized"
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | "TooEarly"
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | "TooManyProposals"
  /**
   * The given weight bound for the proposal was too low.
   **/
  | "WrongProposalWeight"
  /**
   * The given length bound for the proposal was too low.
   **/
  | "WrongProposalLength"
  /**
   * Prime account is not a member
   **/
  | "PrimeAccountNotMember";

export type PalletGrandpaStoredState =
  | { type: "Live" }
  | { type: "PendingPause"; value: { scheduledAt: number; delay: number } }
  | { type: "Paused" }
  | { type: "PendingResume"; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | "PauseFailed"
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | "ResumeFailed"
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | "ChangePending"
  /**
   * Cannot signal forced change so soon after last.
   **/
  | "TooSoon"
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidKeyOwnershipProof"
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidEquivocationProof"
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | "DuplicateOffenceReport";

export type PalletTreasuryProposal = {
  proposer: AccountId32;
  value: bigint;
  beneficiary: AccountId32;
  bond: bigint;
};

export type PalletTreasurySpendStatus = {
  assetKind: [];
  amount: bigint;
  beneficiary: AccountId32;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { type: "Pending" }
  | { type: "Attempted"; value: { id: [] } }
  | { type: "Failed" };

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | "InsufficientProposersBalance"
  /**
   * No proposal, bounty or spend at that index.
   **/
  | "InvalidIndex"
  /**
   * Too many approvals in the queue.
   **/
  | "TooManyApprovals"
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | "InsufficientPermission"
  /**
   * Proposal has not been approved.
   **/
  | "ProposalNotApproved"
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | "FailedToConvertBalance"
  /**
   * The spend has expired and cannot be claimed.
   **/
  | "SpendExpired"
  /**
   * The spend is not yet eligible for payout.
   **/
  | "EarlyPayout"
  /**
   * The payment has already been attempted.
   **/
  | "AlreadyAttempted"
  /**
   * There was some issue with the mechanism of payment.
   **/
  | "PayoutError"
  /**
   * The payout was not yet attempted/claimed.
   **/
  | "NotAttempted"
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | "Inconclusive";

/**
 * Error for the Sudo pallet.
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account.
   **/
  "RequireSudo";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletImOnlineError =
  /**
   * Non existent public key.
   **/
  | "InvalidKey"
  /**
   * Duplicated heartbeat.
   **/
  | "DuplicatedHeartbeat";

export type SpStakingOffenceOffenceDetails = {
  offender: [AccountId32, SpStakingExposure];
  reporters: Array<AccountId32>;
};

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: DaRuntimeOriginCaller;
};

export type FrameSupportPreimagesBounded =
  | { type: "Legacy"; value: { hash: H256 } }
  | { type: "Inline"; value: Bytes }
  | { type: "Lookup"; value: { hash: H256; len: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | "FailedToSchedule"
  /**
   * Cannot find the scheduled call.
   **/
  | "NotFound"
  /**
   * Given target block number is in the past.
   **/
  | "TargetBlockNumberInPast"
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | "RescheduleNoChange"
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | "Named";

export type DaControlAppKeyInfo = { owner: AccountId32; id: AvailCoreAppId };

/**
 * Error for the System pallet
 **/
export type DaControlError =
  /**
   * The application key already exists.
   **/
  | "AppKeyAlreadyExists"
  /**
   * The application key is an empty string.
   **/
  | "AppKeyCannotBeEmpty"
  /**
   * The last application ID overflowed.
   **/
  | "LastAppIdOverflowed"
  /**
   * The submitted data is empty.
   **/
  | "DataCannotBeEmpty"
  /**
   * The last block length proposal Id overflowed.
   **/
  | "LastBlockLenProposalIdOverflowed"
  /**
   * The proposed block dimensions are out of bounds.
   **/
  | "BlockDimensionsOutOfBounds"
  /**
   * The proposed block dimensions are too small.
   **/
  | "BlockDimensionsTooSmall"
  /**
   * The request to reduce block dimensions was made in a non-empty block
   **/
  | "InvalidBlockWeightReduction"
  /**
   * Submit data call outside of block execution context.
   **/
  | "BadContext"
  /**
   * App info was not found for the given App key
   **/
  | "UnknownAppKey"
  /**
   * Submit block length proposal was made with values not power of 2
   **/
  | "NotPowerOfTwo";

export type PalletPreimageOldRequestStatus =
  | {
      type: "Unrequested";
      value: { deposit: [AccountId32, bigint]; len: number };
    }
  | {
      type: "Requested";
      value: {
        deposit?: [AccountId32, bigint] | undefined;
        count: number;
        len?: number | undefined;
      };
    };

export type PalletPreimageRequestStatus =
  | {
      type: "Unrequested";
      value: {
        ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration];
        len: number;
      };
    }
  | {
      type: "Requested";
      value: {
        maybeTicket?:
          | [AccountId32, FrameSupportTokensFungibleHoldConsideration]
          | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | "TooBig"
  /**
   * Preimage has already been noted on-chain.
   **/
  | "AlreadyNoted"
  /**
   * The user is not authorized to perform this action.
   **/
  | "NotAuthorized"
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | "NotNoted"
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | "Requested"
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | "NotRequested"
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | "TooMany"
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | "TooFew";

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | "MinimumThreshold"
  /**
   * Call is already approved by this signatory.
   **/
  | "AlreadyApproved"
  /**
   * Call doesn't need any (more) approvals.
   **/
  | "NoApprovalsNeeded"
  /**
   * There are too few signatories in the list.
   **/
  | "TooFewSignatories"
  /**
   * There are too many signatories in the list.
   **/
  | "TooManySignatories"
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | "SignatoriesOutOfOrder"
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | "SenderInSignatories"
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | "NotFound"
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | "NotOwner"
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | "NoTimepoint"
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | "WrongTimepoint"
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | "UnexpectedTimepoint"
  /**
   * The maximum weight information provided was too low.
   **/
  | "MaxWeightTooLow"
  /**
   * The data to be stored is already stored.
   **/
  | "AlreadyStored";

export type PalletBagsListListNode = {
  id: AccountId32;
  prev?: AccountId32 | undefined;
  next?: AccountId32 | undefined;
  bagUpper: bigint;
  score: bigint;
};

export type PalletBagsListListBag = {
  head?: AccountId32 | undefined;
  tail?: AccountId32 | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBagsListError =
  /**
   * A error in the list interface implementation.
   **/
  { name: "List"; data: PalletBagsListListListError };

export type PalletBagsListListListError =
  | "Duplicate"
  | "NotHeavier"
  | "NotInSameBag"
  | "NodeNotFound";

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
  claimPermission?: PalletNominationPoolsCommissionClaimPermission | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32;
  root?: AccountId32 | undefined;
  nominator?: AccountId32 | undefined;
  bouncer?: AccountId32 | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = {
  points: bigint;
  balance: bigint;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  /**
   * A (bonded) pool id does not exist.
   **/
  | { name: "PoolNotFound" }
  /**
   * An account is not a member.
   **/
  | { name: "PoolMemberNotFound" }
  /**
   * A reward pool does not exist. In all cases this is a system logic error.
   **/
  | { name: "RewardPoolNotFound" }
  /**
   * A sub pool does not exist.
   **/
  | { name: "SubPoolsNotFound" }
  /**
   * An account is already delegating in another pool. An account may only belong to one
   * pool at a time.
   **/
  | { name: "AccountBelongsToOtherPool" }
  /**
   * The member is fully unbonded (and thus cannot access the bonded and reward pool
   * anymore to, for example, collect rewards).
   **/
  | { name: "FullyUnbonding" }
  /**
   * The member cannot unbond further chunks due to reaching the limit.
   **/
  | { name: "MaxUnbondingLimit" }
  /**
   * None of the funds can be withdrawn yet because the bonding duration has not passed.
   **/
  | { name: "CannotWithdrawAny" }
  /**
   * The amount does not meet the minimum bond to either join or create a pool.
   *
   * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
   * caller does not have nominating permissions for the pool. Members can never unbond to a
   * value below `MinJoinBond`.
   **/
  | { name: "MinimumBondNotMet" }
  /**
   * The transaction could not be executed due to overflow risk for the pool.
   **/
  | { name: "OverflowRisk" }
  /**
   * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
   * other members to be permissionlessly unbonded.
   **/
  | { name: "NotDestroying" }
  /**
   * The caller does not have nominating permissions for the pool.
   **/
  | { name: "NotNominator" }
  /**
   * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
   **/
  | { name: "NotKickerOrDestroying" }
  /**
   * The pool is not open to join
   **/
  | { name: "NotOpen" }
  /**
   * The system is maxed out on pools.
   **/
  | { name: "MaxPools" }
  /**
   * Too many members in the pool or system.
   **/
  | { name: "MaxPoolMembers" }
  /**
   * The pools state cannot be changed.
   **/
  | { name: "CanNotChangeState" }
  /**
   * The caller does not have adequate permissions.
   **/
  | { name: "DoesNotHavePermission" }
  /**
   * Metadata exceeds [`Config::MaxMetadataLen`]
   **/
  | { name: "MetadataExceedsMaxLen" }
  /**
   * Some error occurred that should never happen. This should be reported to the
   * maintainers.
   **/
  | { name: "Defensive"; data: PalletNominationPoolsDefensiveError }
  /**
   * Partial unbonding now allowed permissionlessly.
   **/
  | { name: "PartialUnbondNotAllowedPermissionlessly" }
  /**
   * The pool's max commission cannot be set higher than the existing value.
   **/
  | { name: "MaxCommissionRestricted" }
  /**
   * The supplied commission exceeds the max allowed commission.
   **/
  | { name: "CommissionExceedsMaximum" }
  /**
   * The supplied commission exceeds global maximum commission.
   **/
  | { name: "CommissionExceedsGlobalMaximum" }
  /**
   * Not enough blocks have surpassed since the last commission update.
   **/
  | { name: "CommissionChangeThrottled" }
  /**
   * The submitted changes to commission change rate are not allowed.
   **/
  | { name: "CommissionChangeRateNotAllowed" }
  /**
   * There is no pending commission to claim.
   **/
  | { name: "NoPendingCommission" }
  /**
   * No commission current has been set.
   **/
  | { name: "NoCommissionCurrentSet" }
  /**
   * Pool id currently in use.
   **/
  | { name: "PoolIdInUse" }
  /**
   * Pool id provided is not correct/usable.
   **/
  | { name: "InvalidPoolId" }
  /**
   * Bonding extra is restricted to the exact pending reward amount.
   **/
  | { name: "BondExtraRestricted" }
  /**
   * No imbalance in the ED deposit for the pool.
   **/
  | { name: "NothingToAdjust" };

export type PalletNominationPoolsDefensiveError =
  | "NotEnoughSpaceInUnbondPool"
  | "PoolNotFound"
  | "RewardPoolNotFound"
  | "SubPoolsNotFound"
  | "BondedStashKilledPrematurely";

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityLegacyIdentityInfo;
};

export type PalletIdentityRegistrarInfo = {
  account: AccountId32;
  fee: bigint;
  fields: bigint;
};

export type PalletIdentityAuthorityProperties = {
  suffix: Bytes;
  allocation: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | "TooManySubAccounts"
  /**
   * Account isn't found.
   **/
  | "NotFound"
  /**
   * Account isn't named.
   **/
  | "NotNamed"
  /**
   * Empty index.
   **/
  | "EmptyIndex"
  /**
   * Fee is changed.
   **/
  | "FeeChanged"
  /**
   * No identity found.
   **/
  | "NoIdentity"
  /**
   * Sticky judgement.
   **/
  | "StickyJudgement"
  /**
   * Judgement given.
   **/
  | "JudgementGiven"
  /**
   * Invalid judgement.
   **/
  | "InvalidJudgement"
  /**
   * The index is invalid.
   **/
  | "InvalidIndex"
  /**
   * The target is invalid.
   **/
  | "InvalidTarget"
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | "TooManyRegistrars"
  /**
   * Account ID is already named.
   **/
  | "AlreadyClaimed"
  /**
   * Sender is not a sub-account.
   **/
  | "NotSub"
  /**
   * Sub-account isn't owned by sender.
   **/
  | "NotOwned"
  /**
   * The provided judgement was for a different identity.
   **/
  | "JudgementForDifferentIdentity"
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | "JudgementPaymentFailed"
  /**
   * The provided suffix is too long.
   **/
  | "InvalidSuffix"
  /**
   * The sender does not have permission to issue a username.
   **/
  | "NotUsernameAuthority"
  /**
   * The authority cannot allocate any more usernames.
   **/
  | "NoAllocation"
  /**
   * The signature on a username was not valid.
   **/
  | "InvalidSignature"
  /**
   * Setting this username requires a signature, but none was provided.
   **/
  | "RequiresSignature"
  /**
   * The username does not meet the requirements.
   **/
  | "InvalidUsername"
  /**
   * The username is already taken.
   **/
  | "UsernameTaken"
  /**
   * The requested username does not exist.
   **/
  | "NoUsername"
  /**
   * The username cannot be forcefully removed because it can still be accepted.
   **/
  | "NotExpired";

export type PalletVectorStorageUtilsMessageStatusEnum =
  | "NotExecuted"
  | "ExecutionSucceeded";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletVectorError =
  | "VerificationError"
  | "NotEnoughParticipants"
  | "ConfigurationNotSet"
  | "SlotBehindHead"
  | "VerificationKeyIsNotSet"
  | "MalformedVerificationKey"
  | "FunctionIdNotKnown"
  | "StepVerificationError"
  | "RotateVerificationError"
  | "HeaderRootNotSet"
  | "VerificationFailed"
  | "HeaderRootAlreadySet"
  | "StateRootAlreadySet"
  | "SyncCommitteeAlreadySet"
  | "SyncCommitteeNotSet"
  | "MessageAlreadyExecuted"
  | "WrongDestinationChain"
  | "UnsupportedOriginChain"
  | "BroadcasterSourceChainNotSet"
  | "SourceChainFrozen"
  | "CannotGetStorageRoot"
  | "CannotGetStorageValue"
  | "InvalidMessageHash"
  | "CannotDecodeData"
  | "CannotDecodeDestinationAccountId"
  /**
   * Given AssetId is not supported
   **/
  | "AssetNotSupported"
  /**
   * Given inputs for the selected MessageType are invalid
   **/
  | "InvalidBridgeInputs"
  /**
   * Domain is not supported
   **/
  | "DomainNotSupported"
  /**
   * Function ids (step / rotate) are not set
   **/
  | "FunctionIdsAreNotSet"
  /**
   * Inherent call outside of block execution context.
   **/
  | "BadContext"
  /**
   * Invalid FailedIndices
   **/
  | "InvalidFailedIndices"
  /**
   * Invalid updater
   **/
  | "UpdaterMisMatch"
  /**
   * Proof output parsing error
   **/
  | "CannotParseOutputData"
  /**
   * Cannot get current message id
   **/
  | "CurrentMessageIdNotFound"
  /**
   * Public values decoding error.
   **/
  | "CannotDecodePublicValue"
  /**
   * Sync committee hash is already set for given period.
   **/
  | "SyncCommitteeHashAlreadySet"
  /**
   * Emit when start sync committee does not match.
   **/
  | "SyncCommitteeStartMismatch"
  /**
   * Mock is not enabled.
   **/
  | "MockIsNotEnabled";

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: DaRuntimeImplsProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = {
  real: AccountId32;
  callHash: H256;
  height: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | "TooMany"
  /**
   * Proxy registration not found.
   **/
  | "NotFound"
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | "NotProxy"
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | "Unproxyable"
  /**
   * Account is already a proxy.
   **/
  | "Duplicate"
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | "NoPermission"
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | "Unannounced"
  /**
   * Cannot add self as proxy.
   **/
  | "NoSelfProxy";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTxPauseError =
  /**
   * The call is paused.
   **/
  | "IsPaused"
  /**
   * The call is unpaused.
   **/
  | "IsUnpaused"
  /**
   * The call is whitelisted and cannot be paused.
   **/
  | "Unpausable"
  | "NotFound";

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type DaControlExtensionsCheckAppId = AvailCoreAppId;

export type DaRuntimeRuntime = {};

export type DaRuntimeRuntimeError =
  | { pallet: "System"; palletError: FrameSystemError }
  | { pallet: "Utility"; palletError: PalletUtilityError }
  | { pallet: "Babe"; palletError: PalletBabeError }
  | { pallet: "Indices"; palletError: PalletIndicesError }
  | { pallet: "Balances"; palletError: PalletBalancesError }
  | {
      pallet: "ElectionProviderMultiPhase";
      palletError: PalletElectionProviderMultiPhaseError;
    }
  | { pallet: "Staking"; palletError: PalletStakingPalletError }
  | { pallet: "Session"; palletError: PalletSessionError }
  | { pallet: "TechnicalCommittee"; palletError: PalletCollectiveError }
  | { pallet: "Grandpa"; palletError: PalletGrandpaError }
  | { pallet: "Treasury"; palletError: PalletTreasuryError }
  | { pallet: "Sudo"; palletError: PalletSudoError }
  | { pallet: "ImOnline"; palletError: PalletImOnlineError }
  | { pallet: "Scheduler"; palletError: PalletSchedulerError }
  | { pallet: "DataAvailability"; palletError: DaControlError }
  | { pallet: "Preimage"; palletError: PalletPreimageError }
  | { pallet: "Multisig"; palletError: PalletMultisigError }
  | { pallet: "VoterList"; palletError: PalletBagsListError }
  | { pallet: "NominationPools"; palletError: PalletNominationPoolsError }
  | { pallet: "Identity"; palletError: PalletIdentityError }
  | { pallet: "Vector"; palletError: PalletVectorError }
  | { pallet: "Proxy"; palletError: PalletProxyError }
  | { pallet: "TxPause"; palletError: PalletTxPauseError }
  | { pallet: "TreasuryCommittee"; palletError: PalletCollectiveError };
