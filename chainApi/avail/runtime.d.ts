// Generated by dedot cli

import type {
  GenericRuntimeApis,
  GenericRuntimeApiMethod,
  RpcVersion,
} from "dedot/types";
import type {
  RuntimeVersion,
  Block,
  Header,
  Option,
  OpaqueMetadata,
  ApplyExtrinsicResult,
  OpaqueExtrinsicLike,
  CheckInherentsResult,
  InherentData,
  OpaqueExtrinsic,
  TransactionValidity,
  TransactionSource,
  BlockHash,
  SetId,
  OpaqueKeyOwnershipProof,
  AccountId32Like,
  AuthorityList,
  GrandpaEquivocationProof,
  BabeConfiguration,
  BabeEpoch,
  Slot,
  BabeEquivocationProof,
  AccountId32,
  Nonce,
  RuntimeDispatchInfo,
  FeeDetails,
  Balance,
  Weight,
  RawBytesLike,
  Result,
  Hash,
  MmrError,
  LeafIndex,
  GeneratedMmrProofResult,
  BlockNumber,
  MmrEncodableOpaqueLeaf,
  MmrBatchProof,
  NpPoolId,
  Bytes,
  BytesLike,
  KeyTypeId,
  Text,
} from "dedot/codecs";

export interface RuntimeApis<Rv extends RpcVersion>
  extends GenericRuntimeApis<Rv> {
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   * @version: 4
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<Rv, () => Promise<RuntimeVersion>>;

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     * @param {Block} block
     **/
    executeBlock: GenericRuntimeApiMethod<Rv, (block: Block) => Promise<[]>>;

    /**
     * Initialize a block with the given header.
     *
     * @callname: Core_initialize_block
     * @param {Header} header
     **/
    initializeBlock: GenericRuntimeApiMethod<
      Rv,
      (header: Header) => Promise<[]>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   * @version: 2
   **/
  metadata: {
    /**
     * Returns the metadata at a given version.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<
      Rv,
      (version: number) => Promise<Option<OpaqueMetadata>>
    >;

    /**
     * Returns the supported metadata versions.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<Rv, () => Promise<Array<number>>>;

    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<Rv, () => Promise<OpaqueMetadata>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   * @version: 6
   **/
  blockBuilder: {
    /**
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {OpaqueExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (extrinsic: OpaqueExtrinsicLike) => Promise<ApplyExtrinsicResult>
    >;

    /**
     *
     * @callname: BlockBuilder_check_inherents
     * @param {Block} block
     * @param {InherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      Rv,
      (block: Block, data: InherentData) => Promise<CheckInherentsResult>
    >;

    /**
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {InherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      Rv,
      (inherent: InherentData) => Promise<Array<OpaqueExtrinsic>>
    >;

    /**
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<Rv, () => Promise<Header>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   * @version: 3
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {TransactionSource} source
     * @param {OpaqueExtrinsicLike} tx
     * @param {BlockHash} blockHash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      Rv,
      (
        source: TransactionSource,
        tx: OpaqueExtrinsicLike,
        blockHash: BlockHash,
      ) => Promise<TransactionValidity>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   * @version: 2
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<
      Rv,
      (header: Header) => Promise<[]>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GrandpaApi - 0xed99c5acb25eedf5
   * @version: 3
   **/
  grandpaApi: {
    /**
     * Get current GRANDPA authority set id.
     *
     * @callname: GrandpaApi_current_set_id
     **/
    currentSetId: GenericRuntimeApiMethod<Rv, () => Promise<SetId>>;

    /**
     * Get the current GRANDPA authorities and weights. This should not change except
     * for when changes are scheduled and the corresponding delay has passed.
     *
     * When called at block B, it will return the set of authorities that should be
     * used to finalize descendants of this block (B+1, B+2, ...). The block B itself
     * is finalized by the authorities from block B-1.
     *
     * @callname: GrandpaApi_generate_key_ownership_proof
     * @param {SetId} setId
     * @param {AccountId32Like} authorityId
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        setId: SetId,
        authorityId: AccountId32Like,
      ) => Promise<Option<OpaqueKeyOwnershipProof>>
    >;

    /**
     * Generates a proof of key ownership for the given authority in the
     * given set. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `set_id` as parameter the current
     * implementations ignore this parameter and instead rely on this
     * method being called at the correct block height, i.e. any point at
     * which the given set id is live on-chain. Future implementations will
     * instead use indexed data through an offchain worker, not requiring
     * older states to be available.
     *
     * @callname: GrandpaApi_grandpa_authorities
     **/
    grandpaAuthorities: GenericRuntimeApiMethod<
      Rv,
      () => Promise<AuthorityList>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: GrandpaApi_submit_report_equivocation_unsigned_extrinsic
     * @param {GrandpaEquivocationProof} equivocationProof
     * @param {OpaqueKeyOwnershipProof} keyOwnerProof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: GrandpaEquivocationProof,
        keyOwnerProof: OpaqueKeyOwnershipProof,
      ) => Promise<Option<[]>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: BabeApi - 0xcbca25e39f142387
   * @version: 2
   **/
  babeApi: {
    /**
     * Return the configuration for BABE.
     *
     * @callname: BabeApi_configuration
     **/
    configuration: GenericRuntimeApiMethod<
      Rv,
      () => Promise<BabeConfiguration>
    >;

    /**
     * Returns information regarding the current epoch.
     *
     * @callname: BabeApi_current_epoch
     **/
    currentEpoch: GenericRuntimeApiMethod<Rv, () => Promise<BabeEpoch>>;

    /**
     * Returns the slot that started the current epoch.
     *
     * @callname: BabeApi_current_epoch_start
     **/
    currentEpochStart: GenericRuntimeApiMethod<Rv, () => Promise<Slot>>;

    /**
     * Returns information regarding the next epoch (which was already previously announced).
     *
     * @callname: BabeApi_next_epoch
     **/
    nextEpoch: GenericRuntimeApiMethod<Rv, () => Promise<BabeEpoch>>;

    /**
     * Generates a proof of key ownership for the given authority in the
     * current epoch. An example usage of this module is coupled with the
     * session historical module to prove that a given authority key is
     * tied to a given staking identity during a specific session. Proofs
     * of key ownership are necessary for submitting equivocation reports.
     * NOTE: even though the API takes a `slot` as parameter the current
     * implementations ignores this parameter and instead relies on this
     * method being called at the correct block height, i.e. any point at
     * which the epoch for the given slot is live on-chain. Future
     * implementations will instead use indexed data through an offchain
     * worker, not requiring older states to be available.
     *
     * @callname: BabeApi_generate_key_ownership_proof
     * @param {Slot} slot
     * @param {AccountId32Like} authorityId
     **/
    generateKeyOwnershipProof: GenericRuntimeApiMethod<
      Rv,
      (
        slot: Slot,
        authorityId: AccountId32Like,
      ) => Promise<Option<OpaqueKeyOwnershipProof>>
    >;

    /**
     * Submits an unsigned extrinsic to report an equivocation. The caller
     * must provide the equivocation proof and a key ownership proof
     * (should be obtained using `generate_key_ownership_proof`). The
     * extrinsic will be unsigned and should only be accepted for local
     * authorship (not to be broadcast to the network). This method returns
     * `None` when creation of the extrinsic fails, e.g. if equivocation
     * reporting is disabled for the given runtime (i.e. this method is
     * hardcoded to return `None`). Only useful in an offchain context.
     *
     * @callname: BabeApi_submit_report_equivocation_unsigned_extrinsic
     * @param {BabeEquivocationProof} equivocationProof
     * @param {OpaqueKeyOwnershipProof} keyOwnerProof
     **/
    submitReportEquivocationUnsignedExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        equivocationProof: BabeEquivocationProof,
        keyOwnerProof: OpaqueKeyOwnershipProof,
      ) => Promise<Option<[]>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AuthorityDiscoveryApi - 0x687ad44ad37f03c2
   * @version: 1
   **/
  authorityDiscoveryApi: {
    /**
     * Retrieve authority identifiers of the current and next authority set.
     *
     * @callname: AuthorityDiscoveryApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<Rv, () => Promise<Array<AccountId32>>>;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   * @version: 1
   **/
  accountNonceApi: {
    /**
     * The API to query account nonce (aka transaction index)
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} accountId
     **/
    accountNonce: GenericRuntimeApiMethod<
      Rv,
      (accountId: AccountId32Like) => Promise<Nonce>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   * @version: 4
   **/
  transactionPaymentApi: {
    /**
     * The transaction info
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {OpaqueExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      Rv,
      (uxt: OpaqueExtrinsicLike, len: number) => Promise<RuntimeDispatchInfo>
    >;

    /**
     * The transaction fee details
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {OpaqueExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (uxt: OpaqueExtrinsicLike, len: number) => Promise<FeeDetails>
    >;

    /**
     * Query the output of the current LengthToFee given some input
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<
      Rv,
      (length: number) => Promise<Balance>
    >;

    /**
     * Query the output of the current WeightToFee given some input
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<
      Rv,
      (weight: Weight) => Promise<Balance>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: TransactionPaymentCallApi - 0xf3ff14d5ab527059
   * @version: 3
   **/
  transactionPaymentCallApi: {
    /**
     * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_info
     * @param {RawBytesLike} call
     * @param {number} len
     **/
    queryCallInfo: GenericRuntimeApiMethod<
      Rv,
      (call: RawBytesLike, len: number) => Promise<RuntimeDispatchInfo>
    >;

    /**
     * Query fee details of a given encoded `Call`.
     *
     * @callname: TransactionPaymentCallApi_query_call_fee_details
     * @param {RawBytesLike} call
     * @param {number} len
     **/
    queryCallFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (call: RawBytesLike, len: number) => Promise<FeeDetails>
    >;

    /**
     * Query the output of the current LengthToFee given some input
     *
     * @callname: TransactionPaymentCallApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<
      Rv,
      (length: number) => Promise<Balance>
    >;

    /**
     * Query the output of the current WeightToFee given some input
     *
     * @callname: TransactionPaymentCallApi_query_weight_to_fee
     * @param {Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<
      Rv,
      (weight: Weight) => Promise<Balance>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: MmrApi - 0x91d5df18b0d2cf58
   * @version: 2
   **/
  mmrApi: {
    /**
     * Return the on-chain MMR root hash.
     *
     * @callname: MmrApi_mmr_root
     **/
    mmrRoot: GenericRuntimeApiMethod<Rv, () => Promise<Result<Hash, MmrError>>>;

    /**
     * Return the number of MMR blocks in the chain.
     *
     * @callname: MmrApi_mmr_leaf_count
     **/
    mmrLeafCount: GenericRuntimeApiMethod<
      Rv,
      () => Promise<Result<LeafIndex, MmrError>>
    >;

    /**
     * Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,
     * use historical MMR state at given block height `n`. Else, use current MMR state.
     *
     * @callname: MmrApi_generate_proof
     * @param {Array<BlockNumber>} blockNumbers
     * @param {Option<BlockNumber>} bestKnownBlockNumber
     **/
    generateProof: GenericRuntimeApiMethod<
      Rv,
      (
        blockNumbers: Array<BlockNumber>,
        bestKnownBlockNumber?: Option<BlockNumber>,
      ) => Promise<Result<GeneratedMmrProofResult, MmrError>>
    >;

    /**
     * Verify MMR proof against on-chain MMR for a batch of leaves.
     *
     * Note this function will use on-chain MMR root hash and check if the proof matches the hash.
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
     *
     * @callname: MmrApi_verify_proof
     * @param {Array<MmrEncodableOpaqueLeaf>} leaves
     * @param {MmrBatchProof} proof
     **/
    verifyProof: GenericRuntimeApiMethod<
      Rv,
      (
        leaves: Array<MmrEncodableOpaqueLeaf>,
        proof: MmrBatchProof,
      ) => Promise<Result<[], MmrError>>
    >;

    /**
     * Verify MMR proof against given root hash for a batch of leaves.
     *
     * Note this function does not require any on-chain storage - the
     * proof is verified against given MMR root hash.
     *
     * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
     * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
     *
     * @callname: MmrApi_verify_proof_stateless
     * @param {Hash} root
     * @param {Array<MmrEncodableOpaqueLeaf>} leaves
     * @param {MmrBatchProof} proof
     **/
    verifyProofStateless: GenericRuntimeApiMethod<
      Rv,
      (
        root: Hash,
        leaves: Array<MmrEncodableOpaqueLeaf>,
        proof: MmrBatchProof,
      ) => Promise<Result<[], MmrError>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: NominationPoolsApi - 0x17a6bc0d0062aeb3
   * @version: 1
   **/
  nominationPoolsApi: {
    /**
     * Returns the pending rewards for the member that the AccountId was given for.
     *
     * @callname: NominationPoolsApi_pending_rewards
     * @param {AccountId32Like} who
     **/
    pendingRewards: GenericRuntimeApiMethod<
      Rv,
      (who: AccountId32Like) => Promise<Balance>
    >;

    /**
     * Returns the equivalent balance of `points` for a given pool.
     *
     * @callname: NominationPoolsApi_points_to_balance
     * @param {NpPoolId} poolId
     * @param {Balance} points
     **/
    pointsToBalance: GenericRuntimeApiMethod<
      Rv,
      (poolId: NpPoolId, points: Balance) => Promise<Balance>
    >;

    /**
     * Returns the equivalent points of `new_funds` for a given pool.
     *
     * @callname: NominationPoolsApi_balance_to_points
     * @param {NpPoolId} poolId
     * @param {Balance} newFunds
     **/
    balanceToPoints: GenericRuntimeApiMethod<
      Rv,
      (poolId: NpPoolId, newFunds: Balance) => Promise<Balance>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   * @version: 1
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {Option<BytesLike>} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (seed?: Option<BytesLike>) => Promise<Bytes>
    >;

    /**
     * Decode the given public session key
     *
     * Returns the list of public raw public keys + key typ
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (encoded: BytesLike) => Promise<Option<Array<[Bytes, KeyTypeId]>>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: StakingApi - 0x18ef58a3b67ba770
   * @version: 1
   **/
  stakingApi: {
    /**
     * Returns the nominations quota for a nominator with a given balance.
     *
     * @callname: StakingApi_nominations_quota
     * @param {Balance} balance
     **/
    nominationsQuota: GenericRuntimeApiMethod<
      Rv,
      (balance: Balance) => Promise<number>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
  /**
   * @runtimeapi: GenesisBuilder - 0xfbc577b9d747efd6
   * @version: 1
   **/
  genesisBuilder: {
    /**
     * Creates the default `GenesisConfig` and returns it as a JSON blob.
     *
     * This function instantiates the default `GenesisConfig` struct for the runtime and serializes it into a JSON
     * blob. It returns a `Vec<u8>` containing the JSON representation of the default `GenesisConfig`.
     *
     * @callname: GenesisBuilder_create_default_config
     **/
    createDefaultConfig: GenericRuntimeApiMethod<Rv, () => Promise<Bytes>>;

    /**
     * Build `GenesisConfig` from a JSON blob not using any defaults and store it in the storage.
     *
     * This function deserializes the full `GenesisConfig` from the given JSON blob and puts it into the storage.
     * If the provided JSON blob is incorrect or incomplete or the deserialization fails, an error is returned.
     * It is recommended to log any errors encountered during the process.
     *
     * Please note that provided json blob must contain all `GenesisConfig` fields, no defaults will be used.
     *
     * @callname: GenesisBuilder_build_config
     * @param {BytesLike} json
     **/
    buildConfig: GenericRuntimeApiMethod<
      Rv,
      (json: BytesLike) => Promise<Result<[], Text>>
    >;

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>;
  };
}
