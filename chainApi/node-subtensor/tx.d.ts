// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from "dedot/types";
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  AccountId32Like,
  H160,
  FixedBytes,
  U256,
  Permill,
} from "dedot/codecs";
import type {
  NodeSubtensorRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  SpConsensusGrandpaEquivocationProof,
  SpCoreVoid,
  PalletBalancesAdjustmentDirection,
  SpWeightsWeightV2Weight,
  PalletSubtensorSubnetIdentityV2,
  NodeSubtensorRuntimeOriginCaller,
  PalletMultisigTimepoint,
  SubtensorRuntimeCommonProxyType,
  PalletRegistryIdentityInfo,
  PalletCommitmentsCommitmentInfo,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusGrandpaAppPublic,
  PalletAdminUtilsPrecompileEnum,
  SubstrateFixedFixedI128,
  EthereumTransactionTransactionV2,
  PalletDrandPulsesPayload,
  PalletDrandBeaconConfigurationPayload,
} from "./types";

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = NodeSubtensorRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion>
  extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "Remark";
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetHeapPages";
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetCode";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetCodeWithoutChecks";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetStorage";
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "KillStorage";
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "KillPrefix";
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "RemarkWithEvent";
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "AuthorizeUpgrade";
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "AuthorizeUpgradeWithoutChecks";
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "ApplyAuthorizedUpgrade";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Timestamp";
          palletCall: {
            name: "Set";
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Grandpa`'s transaction calls
   **/
  grandpa: {
    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpCoreVoid} keyOwnerProof
     **/
    reportEquivocation: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpCoreVoid,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Grandpa";
          palletCall: {
            name: "ReportEquivocation";
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpCoreVoid;
            };
          };
        }
      >
    >;

    /**
     * Report voter equivocation/misbehavior. This method will verify the
     * equivocation proof and validate the given key ownership proof
     * against the extracted offender. If both are valid, the offence
     * will be reported.
     *
     * This extrinsic must be called unsigned and it is expected that only
     * block authors will call it (validated in `ValidateUnsigned`), as such
     * if the block author is defined it will be defined as the equivocation
     * reporter.
     *
     * @param {SpConsensusGrandpaEquivocationProof} equivocationProof
     * @param {SpCoreVoid} keyOwnerProof
     **/
    reportEquivocationUnsigned: GenericTxCall<
      Rv,
      (
        equivocationProof: SpConsensusGrandpaEquivocationProof,
        keyOwnerProof: SpCoreVoid,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Grandpa";
          palletCall: {
            name: "ReportEquivocationUnsigned";
            params: {
              equivocationProof: SpConsensusGrandpaEquivocationProof;
              keyOwnerProof: SpCoreVoid;
            };
          };
        }
      >
    >;

    /**
     * Note that the current authority set of the GRANDPA finality gadget has stalled.
     *
     * This will trigger a forced authority set change at the beginning of the next session, to
     * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
     * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
     * The block production rate (which may be slowed down because of finality lagging) should
     * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
     * authority will start voting on top of `best_finalized_block_number` for new finalized
     * blocks. `best_finalized_block_number` should be the highest of the latest finalized
     * block of all validators of the new authority set.
     *
     * Only callable by root.
     *
     * @param {number} delay
     * @param {number} bestFinalizedBlockNumber
     **/
    noteStalled: GenericTxCall<
      Rv,
      (
        delay: number,
        bestFinalizedBlockNumber: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Grandpa";
          palletCall: {
            name: "NoteStalled";
            params: { delay: number; bestFinalizedBlockNumber: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferAllowDeath";
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceTransfer";
            params: {
              source: MultiAddressLike;
              dest: MultiAddressLike;
              value: bigint;
            };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferKeepAlive";
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferAll";
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceUnreserve";
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "UpgradeAccounts";
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceSetBalance";
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceAdjustTotalIssuance";
            params: {
              direction: PalletBalancesAdjustmentDirection;
              delta: bigint;
            };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "Burn";
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `SubtensorModule`'s transaction calls
   **/
  subtensorModule: {
    /**
     * --- Sets the caller weights for the incentive mechanism. The call can be
     * made from the hotkey account so is potentially insecure, however, the damage
     * of changing weights is minimal if caught early. This function includes all the
     * checks that the passed weights meet the requirements. Stored as u16s they represent
     * rational values in the range [0,1] which sum to 1 and can be interpreted as
     * probabilities. The specific weights determine how inflation propagates outward
     * from this peer.
     *
     * Note: The 16 bit integers weights should represent 1.0 as the max u16.
     * However, the function normalizes all integers to u16_max anyway. This means that if the sum of all
     * elements is larger or smaller than the amount of elements * u16_max, all elements
     * will be corrected for this deviation.
     *
     * # Args:
     * * `origin`: (<T as frame_system::Config>Origin):
     * - The caller, a hotkey who wishes to set their weights.
     *
     * * `netuid` (u16):
     * - The network uid we are setting these weights on.
     *
     * * `dests` (Vec<u16>):
     * - The edge endpoint for the weight, i.e. j for w_ij.
     *
     * * 'weights' (Vec<u16>):
     * - The u16 integer encoded weights. Interpreted as rational
     * values in the range [0,1]. They must sum to in32::MAX.
     *
     * * 'version_key' ( u64 ):
     * - The network version key to check if the validator is up to date.
     *
     * # Event:
     * * WeightsSet;
     * - On successfully setting the weights on chain.
     *
     * # Raises:
     * * 'SubNetworkDoesNotExist':
     * - Attempting to set weights on a non-existent network.
     *
     * * 'NotRegistered':
     * - Attempting to set weights from a non registered account.
     *
     * * 'WeightVecNotEqualSize':
     * - Attempting to set weights with uids not of same length.
     *
     * * 'DuplicateUids':
     * - Attempting to set weights with duplicate uids.
     *
     * * 'UidsLengthExceedUidsInSubNet':
     * - Attempting to set weights above the max allowed uids.
     *
     * * 'UidVecContainInvalidOne':
     * - Attempting to set weights with invalid uids.
     *
     * * 'WeightVecLengthIsLow':
     * - Attempting to set weights with fewer weights than min.
     *
     * * 'MaxWeightExceeded':
     * - Attempting to set weights with max value exceeding limit.
     *
     * @param {number} netuid
     * @param {Array<number>} dests
     * @param {Array<number>} weights
     * @param {bigint} versionKey
     **/
    setWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        dests: Array<number>,
        weights: Array<number>,
        versionKey: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetWeights";
            params: {
              netuid: number;
              dests: Array<number>;
              weights: Array<number>;
              versionKey: bigint;
            };
          };
        }
      >
    >;

    /**
     * --- Allows a hotkey to set weights for multiple netuids as a batch.
     *
     * # Args:
     * * `origin`: (<T as frame_system::Config>Origin):
     * - The caller, a hotkey who wishes to set their weights.
     *
     * * `netuids` (Vec<Compact<u16>>):
     * - The network uids we are setting these weights on.
     *
     * * `weights` (Vec<Vec<(Compact<u16>, Compact<u16>)>):
     * - The weights to set for each network. [(uid, weight), ...]
     *
     * * `version_keys` (Vec<Compact<u64>>):
     * - The network version keys to check if the validator is up to date.
     *
     * # Event:
     * * WeightsSet;
     * - On successfully setting the weights on chain.
     * * BatchWeightsCompleted;
     * - On success of the batch.
     * * BatchCompletedWithErrors;
     * - On failure of any of the weights in the batch.
     * * BatchWeightItemFailed;
     * - On failure for each failed item in the batch.
     *
     *
     * @param {Array<number>} netuids
     * @param {Array<Array<[number, number]>>} weights
     * @param {Array<bigint>} versionKeys
     **/
    batchSetWeights: GenericTxCall<
      Rv,
      (
        netuids: Array<number>,
        weights: Array<Array<[number, number]>>,
        versionKeys: Array<bigint>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BatchSetWeights";
            params: {
              netuids: Array<number>;
              weights: Array<Array<[number, number]>>;
              versionKeys: Array<bigint>;
            };
          };
        }
      >
    >;

    /**
     * ---- Used to commit a hash of your weight values to later be revealed.
     *
     * # Args:
     * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
     * - The signature of the committing hotkey.
     *
     * * `netuid` (`u16`):
     * - The u16 network identifier.
     *
     * * `commit_hash` (`H256`):
     * - The hash representing the committed weights.
     *
     * # Raises:
     * * `CommitRevealDisabled`:
     * - Attempting to commit when the commit-reveal mechanism is disabled.
     *
     * * `TooManyUnrevealedCommits`:
     * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
     *
     *
     * @param {number} netuid
     * @param {H256} commitHash
     **/
    commitWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        commitHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "CommitWeights";
            params: { netuid: number; commitHash: H256 };
          };
        }
      >
    >;

    /**
     * --- Allows a hotkey to commit weight hashes for multiple netuids as a batch.
     *
     * # Args:
     * * `origin`: (<T as frame_system::Config>Origin):
     * - The caller, a hotkey who wishes to set their weights.
     *
     * * `netuids` (Vec<Compact<u16>>):
     * - The network uids we are setting these weights on.
     *
     * * `commit_hashes` (Vec<H256>):
     * - The commit hashes to commit.
     *
     * # Event:
     * * WeightsSet;
     * - On successfully setting the weights on chain.
     * * BatchWeightsCompleted;
     * - On success of the batch.
     * * BatchCompletedWithErrors;
     * - On failure of any of the weights in the batch.
     * * BatchWeightItemFailed;
     * - On failure for each failed item in the batch.
     *
     *
     * @param {Array<number>} netuids
     * @param {Array<H256>} commitHashes
     **/
    batchCommitWeights: GenericTxCall<
      Rv,
      (
        netuids: Array<number>,
        commitHashes: Array<H256>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BatchCommitWeights";
            params: { netuids: Array<number>; commitHashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * ---- Used to reveal the weights for a previously committed hash.
     *
     * # Args:
     * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
     * - The signature of the revealing hotkey.
     *
     * * `netuid` (`u16`):
     * - The u16 network identifier.
     *
     * * `uids` (`Vec<u16>`):
     * - The uids for the weights being revealed.
     *
     * * `values` (`Vec<u16>`):
     * - The values of the weights being revealed.
     *
     * * `salt` (`Vec<u16>`):
     * - The salt used to generate the commit hash.
     *
     * * `version_key` (`u64`):
     * - The network version key.
     *
     * # Raises:
     * * `CommitRevealDisabled`:
     * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
     *
     * * `NoWeightsCommitFound`:
     * - Attempting to reveal weights without an existing commit.
     *
     * * `ExpiredWeightCommit`:
     * - Attempting to reveal a weight commit that has expired.
     *
     * * `RevealTooEarly`:
     * - Attempting to reveal weights outside the valid reveal period.
     *
     * * `InvalidRevealCommitHashNotMatch`:
     * - The revealed hash does not match any committed hash.
     *
     *
     * @param {number} netuid
     * @param {Array<number>} uids
     * @param {Array<number>} values
     * @param {Array<number>} salt
     * @param {bigint} versionKey
     **/
    revealWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        uids: Array<number>,
        values: Array<number>,
        salt: Array<number>,
        versionKey: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RevealWeights";
            params: {
              netuid: number;
              uids: Array<number>;
              values: Array<number>;
              salt: Array<number>;
              versionKey: bigint;
            };
          };
        }
      >
    >;

    /**
     * ---- Used to commit encrypted commit-reveal v3 weight values to later be revealed.
     *
     * # Args:
     * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
     * - The committing hotkey.
     *
     * * `netuid` (`u16`):
     * - The u16 network identifier.
     *
     * * `commit` (`Vec<u8>`):
     * - The encrypted compressed commit.
     * The steps for this are:
     * 1. Instantiate [`WeightsTlockPayload`]
     * 2. Serialize it using the `parity_scale_codec::Encode` trait
     * 3. Encrypt it following the steps (here)[https://github.com/ideal-lab5/tle/blob/f8e6019f0fb02c380ebfa6b30efb61786dede07b/timelock/src/tlock.rs#L283-L336]
     * to produce a [`TLECiphertext<TinyBLS381>`] type.
     * 4. Serialize and compress using the `ark-serialize` `CanonicalSerialize` trait.
     *
     * * reveal_round (`u64`):
     * - The drand reveal round which will be avaliable during epoch `n+1` from the current
     * epoch.
     *
     * # Raises:
     * * `CommitRevealV3Disabled`:
     * - Attempting to commit when the commit-reveal mechanism is disabled.
     *
     * * `TooManyUnrevealedCommits`:
     * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
     *
     *
     * @param {number} netuid
     * @param {BytesLike} commit
     * @param {bigint} revealRound
     **/
    commitCrv3Weights: GenericTxCall<
      Rv,
      (
        netuid: number,
        commit: BytesLike,
        revealRound: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "CommitCrv3Weights";
            params: { netuid: number; commit: BytesLike; revealRound: bigint };
          };
        }
      >
    >;

    /**
     * ---- The implementation for batch revealing committed weights.
     *
     * # Args:
     * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
     * - The signature of the revealing hotkey.
     *
     * * `netuid` (`u16`):
     * - The u16 network identifier.
     *
     * * `uids_list` (`Vec<Vec<u16>>`):
     * - A list of uids for each set of weights being revealed.
     *
     * * `values_list` (`Vec<Vec<u16>>`):
     * - A list of values for each set of weights being revealed.
     *
     * * `salts_list` (`Vec<Vec<u16>>`):
     * - A list of salts used to generate the commit hashes.
     *
     * * `version_keys` (`Vec<u64>`):
     * - A list of network version keys.
     *
     * # Raises:
     * * `CommitRevealDisabled`:
     * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
     *
     * * `NoWeightsCommitFound`:
     * - Attempting to reveal weights without an existing commit.
     *
     * * `ExpiredWeightCommit`:
     * - Attempting to reveal a weight commit that has expired.
     *
     * * `RevealTooEarly`:
     * - Attempting to reveal weights outside the valid reveal period.
     *
     * * `InvalidRevealCommitHashNotMatch`:
     * - The revealed hash does not match any committed hash.
     *
     * * `InvalidInputLengths`:
     * - The input vectors are of mismatched lengths.
     *
     * @param {number} netuid
     * @param {Array<Array<number>>} uidsList
     * @param {Array<Array<number>>} valuesList
     * @param {Array<Array<number>>} saltsList
     * @param {Array<bigint>} versionKeys
     **/
    batchRevealWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        uidsList: Array<Array<number>>,
        valuesList: Array<Array<number>>,
        saltsList: Array<Array<number>>,
        versionKeys: Array<bigint>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BatchRevealWeights";
            params: {
              netuid: number;
              uidsList: Array<Array<number>>;
              valuesList: Array<Array<number>>;
              saltsList: Array<Array<number>>;
              versionKeys: Array<bigint>;
            };
          };
        }
      >
    >;

    /**
     * # Args:
     * * `origin`: (<T as frame_system::Config>Origin):
     * - The caller, a hotkey who wishes to set their weights.
     *
     * * `netuid` (u16):
     * - The network uid we are setting these weights on.
     *
     * * `hotkey` (T::AccountId):
     * - The hotkey associated with the operation and the calling coldkey.
     *
     * * `dests` (Vec<u16>):
     * - The edge endpoint for the weight, i.e. j for w_ij.
     *
     * * 'weights' (Vec<u16>):
     * - The u16 integer encoded weights. Interpreted as rational
     * values in the range [0,1]. They must sum to in32::MAX.
     *
     * * 'version_key' ( u64 ):
     * - The network version key to check if the validator is up to date.
     *
     * # Event:
     *
     * * WeightsSet;
     * - On successfully setting the weights on chain.
     *
     * # Raises:
     *
     * * NonAssociatedColdKey;
     * - Attempting to set weights on a non-associated cold key.
     *
     * * 'SubNetworkDoesNotExist':
     * - Attempting to set weights on a non-existent network.
     *
     * * 'NotRootSubnet':
     * - Attempting to set weights on a subnet that is not the root network.
     *
     * * 'WeightVecNotEqualSize':
     * - Attempting to set weights with uids not of same length.
     *
     * * 'UidVecContainInvalidOne':
     * - Attempting to set weights with invalid uids.
     *
     * * 'NotRegistered':
     * - Attempting to set weights from a non registered account.
     *
     * * 'WeightVecLengthIsLow':
     * - Attempting to set weights with fewer weights than min.
     *
     * * 'IncorrectWeightVersionKey':
     * - Attempting to set weights with the incorrect network version key.
     *
     * * 'SettingWeightsTooFast':
     * - Attempting to set weights too fast.
     *
     * * 'WeightVecLengthIsLow':
     * - Attempting to set weights with fewer weights than min.
     *
     * * 'MaxWeightExceeded':
     * - Attempting to set weights with max value exceeding limit.
     *
     *
     * @param {number} netuid
     * @param {AccountId32Like} hotkey
     * @param {Array<number>} dests
     * @param {Array<number>} weights
     * @param {bigint} versionKey
     **/
    setTaoWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        hotkey: AccountId32Like,
        dests: Array<number>,
        weights: Array<number>,
        versionKey: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetTaoWeights";
            params: {
              netuid: number;
              hotkey: AccountId32Like;
              dests: Array<number>;
              weights: Array<number>;
              versionKey: bigint;
            };
          };
        }
      >
    >;

    /**
     * --- Sets the key as a delegate.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The hotkey we are delegating (must be owned by the coldkey.)
     *
     * * 'take' (u64):
     * - The stake proportion that this hotkey takes from delegations.
     *
     * # Event:
     * * DelegateAdded;
     * - On successfully setting a hotkey as a delegate.
     *
     * # Raises:
     * * 'NotRegistered':
     * - The hotkey we are delegating is not registered on the network.
     *
     * * 'NonAssociatedColdKey':
     * - The hotkey we are delegating is not owned by the calling coldket.
     *
     *
     * @param {AccountId32Like} hotkey
     **/
    becomeDelegate: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BecomeDelegate";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * --- Allows delegates to decrease its take value.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>::Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The hotkey we are delegating (must be owned by the coldkey.)
     *
     * * 'netuid' (u16):
     * - Subnet ID to decrease take for
     *
     * * 'take' (u16):
     * - The new stake proportion that this hotkey takes from delegations.
     * The new value can be between 0 and 11_796 and should be strictly
     * lower than the previous value. It T is the new value (rational number),
     * the the parameter is calculated as [65535 * T]. For example, 1% would be
     * [0.01 * 65535] = [655.35] = 655
     *
     * # Event:
     * * TakeDecreased;
     * - On successfully setting a decreased take for this hotkey.
     *
     * # Raises:
     * * 'NotRegistered':
     * - The hotkey we are delegating is not registered on the network.
     *
     * * 'NonAssociatedColdKey':
     * - The hotkey we are delegating is not owned by the calling coldkey.
     *
     * * 'DelegateTakeTooLow':
     * - The delegate is setting a take which is not lower than the previous.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} take
     **/
    decreaseTake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        take: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "DecreaseTake";
            params: { hotkey: AccountId32Like; take: number };
          };
        }
      >
    >;

    /**
     * --- Allows delegates to increase its take value. This call is rate-limited.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>::Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The hotkey we are delegating (must be owned by the coldkey.)
     *
     * * 'take' (u16):
     * - The new stake proportion that this hotkey takes from delegations.
     * The new value can be between 0 and 11_796 and should be strictly
     * greater than the previous value. T is the new value (rational number),
     * the the parameter is calculated as [65535 * T]. For example, 1% would be
     * [0.01 * 65535] = [655.35] = 655
     *
     * # Event:
     * * TakeIncreased;
     * - On successfully setting a increased take for this hotkey.
     *
     * # Raises:
     * * 'NotRegistered':
     * - The hotkey we are delegating is not registered on the network.
     *
     * * 'NonAssociatedColdKey':
     * - The hotkey we are delegating is not owned by the calling coldkey.
     *
     * * 'DelegateTakeTooHigh':
     * - The delegate is setting a take which is not greater than the previous.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} take
     **/
    increaseTake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        take: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "IncreaseTake";
            params: { hotkey: AccountId32Like; take: number };
          };
        }
      >
    >;

    /**
     * --- Adds stake to a hotkey. The call is made from a coldkey account.
     * This delegates stake to the hotkey.
     *
     * Note: the coldkey account may own the hotkey, in which case they are
     * delegating to themselves.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The associated hotkey account.
     *
     * * 'netuid' (u16):
     * - Subnetwork UID
     *
     * * 'amount_staked' (u64):
     * - The amount of stake to be added to the hotkey staking account.
     *
     * # Event:
     * * StakeAdded;
     * - On the successfully adding stake to a global account.
     *
     * # Raises:
     * * 'NotEnoughBalanceToStake':
     * - Not enough balance on the coldkey to add onto the global account.
     *
     * * 'NonAssociatedColdKey':
     * - The calling coldkey is not associated with this hotkey.
     *
     * * 'BalanceWithdrawalError':
     * - Errors stemming from transaction pallet.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {bigint} amountStaked
     **/
    addStake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        amountStaked: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "AddStake";
            params: {
              hotkey: AccountId32Like;
              netuid: number;
              amountStaked: bigint;
            };
          };
        }
      >
    >;

    /**
     * Remove stake from the staking account. The call must be made
     * from the coldkey account attached to the neuron metadata. Only this key
     * has permission to make staking and unstaking requests.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The associated hotkey account.
     *
     * * 'netuid' (u16):
     * - Subnetwork UID
     *
     * * 'amount_unstaked' (u64):
     * - The amount of stake to be added to the hotkey staking account.
     *
     * # Event:
     * * StakeRemoved;
     * - On the successfully removing stake from the hotkey account.
     *
     * # Raises:
     * * 'NotRegistered':
     * - Thrown if the account we are attempting to unstake from is non existent.
     *
     * * 'NonAssociatedColdKey':
     * - Thrown if the coldkey does not own the hotkey we are unstaking from.
     *
     * * 'NotEnoughStakeToWithdraw':
     * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {bigint} amountUnstaked
     **/
    removeStake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        amountUnstaked: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RemoveStake";
            params: {
              hotkey: AccountId32Like;
              netuid: number;
              amountUnstaked: bigint;
            };
          };
        }
      >
    >;

    /**
     * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
     * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller.
     *
     * * 'netuid' (u16):
     * - The u16 network identifier.
     *
     * * 'version' (u64):
     * - The bittensor version identifier.
     *
     * * 'ip' (u64):
     * - The endpoint ip information as a u128 encoded integer.
     *
     * * 'port' (u16):
     * - The endpoint port information as a u16 encoded integer.
     *
     * * 'ip_type' (u8):
     * - The endpoint ip version as a u8, 4 or 6.
     *
     * * 'protocol' (u8):
     * - UDP:1 or TCP:0
     *
     * * 'placeholder1' (u8):
     * - Placeholder for further extra params.
     *
     * * 'placeholder2' (u8):
     * - Placeholder for further extra params.
     *
     * # Event:
     * * AxonServed;
     * - On successfully serving the axon info.
     *
     * # Raises:
     * * 'SubNetworkDoesNotExist':
     * - Attempting to set weights on a non-existent network.
     *
     * * 'NotRegistered':
     * - Attempting to set weights from a non registered account.
     *
     * * 'InvalidIpType':
     * - The ip type is not 4 or 6.
     *
     * * 'InvalidIpAddress':
     * - The numerically encoded ip address does not resolve to a proper ip.
     *
     * * 'ServingRateLimitExceeded':
     * - Attempting to set prometheus information withing the rate limit min.
     *
     *
     * @param {number} netuid
     * @param {number} version
     * @param {bigint} ip
     * @param {number} port
     * @param {number} ipType
     * @param {number} protocol
     * @param {number} placeholder1
     * @param {number} placeholder2
     **/
    serveAxon: GenericTxCall<
      Rv,
      (
        netuid: number,
        version: number,
        ip: bigint,
        port: number,
        ipType: number,
        protocol: number,
        placeholder1: number,
        placeholder2: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "ServeAxon";
            params: {
              netuid: number;
              version: number;
              ip: bigint;
              port: number;
              ipType: number;
              protocol: number;
              placeholder1: number;
              placeholder2: number;
            };
          };
        }
      >
    >;

    /**
     * Same as `serve_axon` but takes a certificate as an extra optional argument.
     * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
     * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller.
     *
     * * 'netuid' (u16):
     * - The u16 network identifier.
     *
     * * 'version' (u64):
     * - The bittensor version identifier.
     *
     * * 'ip' (u64):
     * - The endpoint ip information as a u128 encoded integer.
     *
     * * 'port' (u16):
     * - The endpoint port information as a u16 encoded integer.
     *
     * * 'ip_type' (u8):
     * - The endpoint ip version as a u8, 4 or 6.
     *
     * * 'protocol' (u8):
     * - UDP:1 or TCP:0
     *
     * * 'placeholder1' (u8):
     * - Placeholder for further extra params.
     *
     * * 'placeholder2' (u8):
     * - Placeholder for further extra params.
     *
     * * 'certificate' (Vec<u8>):
     * - TLS certificate for inter neuron communitation.
     *
     * # Event:
     * * AxonServed;
     * - On successfully serving the axon info.
     *
     * # Raises:
     * * 'SubNetworkDoesNotExist':
     * - Attempting to set weights on a non-existent network.
     *
     * * 'NotRegistered':
     * - Attempting to set weights from a non registered account.
     *
     * * 'InvalidIpType':
     * - The ip type is not 4 or 6.
     *
     * * 'InvalidIpAddress':
     * - The numerically encoded ip address does not resolve to a proper ip.
     *
     * * 'ServingRateLimitExceeded':
     * - Attempting to set prometheus information withing the rate limit min.
     *
     *
     * @param {number} netuid
     * @param {number} version
     * @param {bigint} ip
     * @param {number} port
     * @param {number} ipType
     * @param {number} protocol
     * @param {number} placeholder1
     * @param {number} placeholder2
     * @param {BytesLike} certificate
     **/
    serveAxonTls: GenericTxCall<
      Rv,
      (
        netuid: number,
        version: number,
        ip: bigint,
        port: number,
        ipType: number,
        protocol: number,
        placeholder1: number,
        placeholder2: number,
        certificate: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "ServeAxonTls";
            params: {
              netuid: number;
              version: number;
              ip: bigint;
              port: number;
              ipType: number;
              protocol: number;
              placeholder1: number;
              placeholder2: number;
              certificate: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * ---- Set prometheus information for the neuron.
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the calling hotkey.
     *
     * * 'netuid' (u16):
     * - The u16 network identifier.
     *
     * * 'version' (u16):
     * - The bittensor version identifier.
     *
     * * 'ip' (u128):
     * - The prometheus ip information as a u128 encoded integer.
     *
     * * 'port' (u16):
     * - The prometheus port information as a u16 encoded integer.
     *
     * * 'ip_type' (u8):
     * - The ip type v4 or v6.
     *
     *
     * @param {number} netuid
     * @param {number} version
     * @param {bigint} ip
     * @param {number} port
     * @param {number} ipType
     **/
    servePrometheus: GenericTxCall<
      Rv,
      (
        netuid: number,
        version: number,
        ip: bigint,
        port: number,
        ipType: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "ServePrometheus";
            params: {
              netuid: number;
              version: number;
              ip: bigint;
              port: number;
              ipType: number;
            };
          };
        }
      >
    >;

    /**
     * ---- Registers a new neuron to the subnetwork.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the calling hotkey.
     *
     * * 'netuid' (u16):
     * - The u16 network identifier.
     *
     * * 'block_number' ( u64 ):
     * - Block hash used to prove work done.
     *
     * * 'nonce' ( u64 ):
     * - Positive integer nonce used in POW.
     *
     * * 'work' ( Vec<u8> ):
     * - Vector encoded bytes representing work done.
     *
     * * 'hotkey' ( T::AccountId ):
     * - Hotkey to be registered to the network.
     *
     * * 'coldkey' ( T::AccountId ):
     * - Associated coldkey account.
     *
     * # Event:
     * * NeuronRegistered;
     * - On successfully registering a uid to a neuron slot on a subnetwork.
     *
     * # Raises:
     * * 'SubNetworkDoesNotExist':
     * - Attempting to register to a non existent network.
     *
     * * 'TooManyRegistrationsThisBlock':
     * - This registration exceeds the total allowed on this network this block.
     *
     * * 'HotKeyAlreadyRegisteredInSubNet':
     * - The hotkey is already registered on this network.
     *
     * * 'InvalidWorkBlock':
     * - The work has been performed on a stale, future, or non existent block.
     *
     * * 'InvalidDifficulty':
     * - The work does not match the difficulty.
     *
     * * 'InvalidSeal':
     * - The seal is incorrect.
     *
     *
     * @param {number} netuid
     * @param {bigint} blockNumber
     * @param {bigint} nonce
     * @param {BytesLike} work
     * @param {AccountId32Like} hotkey
     * @param {AccountId32Like} coldkey
     **/
    register: GenericTxCall<
      Rv,
      (
        netuid: number,
        blockNumber: bigint,
        nonce: bigint,
        work: BytesLike,
        hotkey: AccountId32Like,
        coldkey: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "Register";
            params: {
              netuid: number;
              blockNumber: bigint;
              nonce: bigint;
              work: BytesLike;
              hotkey: AccountId32Like;
              coldkey: AccountId32Like;
            };
          };
        }
      >
    >;

    /**
     * Register the hotkey to root network
     *
     * @param {AccountId32Like} hotkey
     **/
    rootRegister: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RootRegister";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Attempt to adjust the senate membership to include a hotkey
     *
     * @param {AccountId32Like} hotkey
     **/
    adjustSenate: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "AdjustSenate";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * User register a new subnetwork via burning token
     *
     * @param {number} netuid
     * @param {AccountId32Like} hotkey
     **/
    burnedRegister: GenericTxCall<
      Rv,
      (
        netuid: number,
        hotkey: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BurnedRegister";
            params: { netuid: number; hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * The extrinsic for user to change its hotkey in subnet or all subnets.
     *
     * @param {AccountId32Like} hotkey
     * @param {AccountId32Like} newHotkey
     * @param {number | undefined} netuid
     **/
    swapHotkey: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        newHotkey: AccountId32Like,
        netuid: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SwapHotkey";
            params: {
              hotkey: AccountId32Like;
              newHotkey: AccountId32Like;
              netuid: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * The extrinsic for user to change the coldkey associated with their account.
     *
     * # Arguments
     *
     * * `origin` - The origin of the call, must be signed by the old coldkey.
     * * `old_coldkey` - The current coldkey associated with the account.
     * * `new_coldkey` - The new coldkey to be associated with the account.
     *
     * # Returns
     *
     * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
     *
     * # Weight
     *
     * Weight is calculated based on the number of database reads and writes.
     *
     * @param {AccountId32Like} oldColdkey
     * @param {AccountId32Like} newColdkey
     * @param {bigint} swapCost
     **/
    swapColdkey: GenericTxCall<
      Rv,
      (
        oldColdkey: AccountId32Like,
        newColdkey: AccountId32Like,
        swapCost: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SwapColdkey";
            params: {
              oldColdkey: AccountId32Like;
              newColdkey: AccountId32Like;
              swapCost: bigint;
            };
          };
        }
      >
    >;

    /**
     * Sets the childkey take for a given hotkey.
     *
     * This function allows a coldkey to set the childkey take for a given hotkey.
     * The childkey take determines the proportion of stake that the hotkey keeps for itself
     * when distributing stake to its children.
     *
     * # Arguments:
     * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
     * - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey.
     *
     * * `hotkey` (T::AccountId):
     * - The hotkey for which the childkey take will be set.
     *
     * * `take` (u16):
     * - The new childkey take value. This is a percentage represented as a value between 0 and 10000,
     * where 10000 represents 100%.
     *
     * # Events:
     * * `ChildkeyTakeSet`:
     * - On successfully setting the childkey take for a hotkey.
     *
     * # Errors:
     * * `NonAssociatedColdKey`:
     * - The coldkey does not own the hotkey.
     * * `InvalidChildkeyTake`:
     * - The provided take value is invalid (greater than the maximum allowed take).
     * * `TxChildkeyTakeRateLimitExceeded`:
     * - The rate limit for changing childkey take has been exceeded.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {number} take
     **/
    setChildkeyTake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        take: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetChildkeyTake";
            params: { hotkey: AccountId32Like; netuid: number; take: number };
          };
        }
      >
    >;

    /**
     * Sets the transaction rate limit for changing childkey take.
     *
     * This function can only be called by the root origin.
     *
     * # Arguments:
     * * `origin` - The origin of the call, must be root.
     * * `tx_rate_limit` - The new rate limit in blocks.
     *
     * # Errors:
     * * `BadOrigin` - If the origin is not root.
     *
     *
     * @param {bigint} txRateLimit
     **/
    sudoSetTxChildkeyTakeRateLimit: GenericTxCall<
      Rv,
      (txRateLimit: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SudoSetTxChildkeyTakeRateLimit";
            params: { txRateLimit: bigint };
          };
        }
      >
    >;

    /**
     * Sets the minimum allowed childkey take.
     *
     * This function can only be called by the root origin.
     *
     * # Arguments:
     * * `origin` - The origin of the call, must be root.
     * * `take` - The new minimum childkey take value.
     *
     * # Errors:
     * * `BadOrigin` - If the origin is not root.
     *
     *
     * @param {number} take
     **/
    sudoSetMinChildkeyTake: GenericTxCall<
      Rv,
      (take: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SudoSetMinChildkeyTake";
            params: { take: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum allowed childkey take.
     *
     * This function can only be called by the root origin.
     *
     * # Arguments:
     * * `origin` - The origin of the call, must be root.
     * * `take` - The new maximum childkey take value.
     *
     * # Errors:
     * * `BadOrigin` - If the origin is not root.
     *
     *
     * @param {number} take
     **/
    sudoSetMaxChildkeyTake: GenericTxCall<
      Rv,
      (take: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SudoSetMaxChildkeyTake";
            params: { take: number };
          };
        }
      >
    >;

    /**
     * Authenticates a council proposal and dispatches a function call with `Root` origin.
     *
     * The dispatch origin for this call must be a council majority.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      Rv,
      (call: NodeSubtensorRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "Sudo";
            params: { call: NodeSubtensorRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Authenticates a council proposal and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * user to specify the weight of the call.
     *
     * The dispatch origin for this call must be a council majority.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      Rv,
      (
        call: NodeSubtensorRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SudoUncheckedWeight";
            params: {
              call: NodeSubtensorRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * User vote on a proposal
     *
     * @param {AccountId32Like} hotkey
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "Vote";
            params: {
              hotkey: AccountId32Like;
              proposal: H256;
              index: number;
              approve: boolean;
            };
          };
        }
      >
    >;

    /**
     * User register a new subnetwork
     *
     * @param {AccountId32Like} hotkey
     **/
    registerNetwork: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RegisterNetwork";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Facility extrinsic for user to get taken from faucet
     * It is only available when pow-faucet feature enabled
     * Just deployed in testnet and devnet for testing purpose
     *
     * @param {bigint} blockNumber
     * @param {bigint} nonce
     * @param {BytesLike} work
     **/
    faucet: GenericTxCall<
      Rv,
      (
        blockNumber: bigint,
        nonce: bigint,
        work: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "Faucet";
            params: { blockNumber: bigint; nonce: bigint; work: BytesLike };
          };
        }
      >
    >;

    /**
     * Remove a user's subnetwork
     * The caller must be the owner of the network
     *
     * @param {AccountId32Like} coldkey
     * @param {number} netuid
     **/
    dissolveNetwork: GenericTxCall<
      Rv,
      (
        coldkey: AccountId32Like,
        netuid: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "DissolveNetwork";
            params: { coldkey: AccountId32Like; netuid: number };
          };
        }
      >
    >;

    /**
     * Set a single child for a given hotkey on a specified network.
     *
     * This function allows a coldkey to set a single child for a given hotkey on a specified network.
     * The proportion of the hotkey's stake to be allocated to the child is also specified.
     *
     * # Arguments:
     * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
     * - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey.
     *
     * * `hotkey` (T::AccountId):
     * - The hotkey which will be assigned the child.
     *
     * * `child` (T::AccountId):
     * - The child which will be assigned to the hotkey.
     *
     * * `netuid` (u16):
     * - The u16 network identifier where the childkey will exist.
     *
     * * `proportion` (u64):
     * - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized.
     *
     * # Events:
     * * `ChildAddedSingular`:
     * - On successfully registering a child to a hotkey.
     *
     * # Errors:
     * * `SubNetworkDoesNotExist`:
     * - Attempting to register to a non-existent network.
     * * `RegistrationNotPermittedOnRootSubnet`:
     * - Attempting to register a child on the root network.
     * * `NonAssociatedColdKey`:
     * - The coldkey does not own the hotkey or the child is the same as the hotkey.
     * * `HotKeyAccountNotExists`:
     * - The hotkey account does not exist.
     *
     * # Detailed Explanation of Checks:
     * 1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey.
     * 2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root.
     * 3. **Network Existence Check**: Ensures that the specified network exists.
     * 4. **Ownership Verification**: Ensures that the coldkey owns the hotkey.
     * 5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists.
     * 6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey.
     * 7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children.
     * 8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child.
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {Array<[bigint, AccountId32Like]>} children
     **/
    setChildren: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        children: Array<[bigint, AccountId32Like]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetChildren";
            params: {
              hotkey: AccountId32Like;
              netuid: number;
              children: Array<[bigint, AccountId32Like]>;
            };
          };
        }
      >
    >;

    /**
     * Schedules a coldkey swap operation to be executed at a future block.
     *
     * This function allows a user to schedule the swapping of their coldkey to a new one
     * at a specified future block. The swap is not executed immediately but is scheduled
     * to occur at the specified block number.
     *
     * # Arguments
     *
     * * `origin` - The origin of the call, which should be signed by the current coldkey owner.
     * * `new_coldkey` - The account ID of the new coldkey that will replace the current one.
     * * `when` - The block number at which the coldkey swap should be executed.
     *
     * # Returns
     *
     * Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful.
     *
     * # Errors
     *
     * This function may return an error if:
     * * The origin is not signed.
     * * The scheduling fails due to conflicts or system constraints.
     *
     * # Notes
     *
     * - The actual swap is not performed by this function. It merely schedules the swap operation.
     * - The weight of this call is set to a fixed value and may need adjustment based on benchmarking.
     *
     * # TODO
     *
     * - Implement proper weight calculation based on the complexity of the operation.
     * - Consider adding checks to prevent scheduling too far into the future.
     * TODO: Benchmark this call
     *
     * @param {AccountId32Like} newColdkey
     **/
    scheduleSwapColdkey: GenericTxCall<
      Rv,
      (newColdkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "ScheduleSwapColdkey";
            params: { newColdkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Schedule the dissolution of a network at a specified block number.
     *
     * # Arguments
     *
     * * `origin` - The origin of the call, must be signed by the sender.
     * * `netuid` - The u16 network identifier to be dissolved.
     *
     * # Returns
     *
     * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
     *
     * # Weight
     *
     * Weight is calculated based on the number of database reads and writes.
     *
     * @param {number} netuid
     **/
    scheduleDissolveNetwork: GenericTxCall<
      Rv,
      (netuid: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "ScheduleDissolveNetwork";
            params: { netuid: number };
          };
        }
      >
    >;

    /**
     * ---- Set prometheus information for the neuron.
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the calling hotkey.
     *
     * * 'netuid' (u16):
     * - The u16 network identifier.
     *
     * * 'version' (u16):
     * - The bittensor version identifier.
     *
     * * 'ip' (u128):
     * - The prometheus ip information as a u128 encoded integer.
     *
     * * 'port' (u16):
     * - The prometheus port information as a u16 encoded integer.
     *
     * * 'ip_type' (u8):
     * - The ip type v4 or v6.
     *
     *
     * @param {BytesLike} name
     * @param {BytesLike} url
     * @param {BytesLike} githubRepo
     * @param {BytesLike} image
     * @param {BytesLike} discord
     * @param {BytesLike} description
     * @param {BytesLike} additional
     **/
    setIdentity: GenericTxCall<
      Rv,
      (
        name: BytesLike,
        url: BytesLike,
        githubRepo: BytesLike,
        image: BytesLike,
        discord: BytesLike,
        description: BytesLike,
        additional: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetIdentity";
            params: {
              name: BytesLike;
              url: BytesLike;
              githubRepo: BytesLike;
              image: BytesLike;
              discord: BytesLike;
              description: BytesLike;
              additional: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * ---- Set the identity information for a subnet.
     * # Args:
     * * `origin` - (<T as frame_system::Config>::Origin):
     * - The signature of the calling coldkey, which must be the owner of the subnet.
     *
     * * `netuid` (u16):
     * - The unique network identifier of the subnet.
     *
     * * `subnet_name` (Vec<u8>):
     * - The name of the subnet.
     *
     * * `github_repo` (Vec<u8>):
     * - The GitHub repository associated with the subnet identity.
     *
     * * `subnet_contact` (Vec<u8>):
     * - The contact information for the subnet.
     *
     * @param {number} netuid
     * @param {BytesLike} subnetName
     * @param {BytesLike} githubRepo
     * @param {BytesLike} subnetContact
     * @param {BytesLike} subnetUrl
     * @param {BytesLike} discord
     * @param {BytesLike} description
     * @param {BytesLike} additional
     **/
    setSubnetIdentity: GenericTxCall<
      Rv,
      (
        netuid: number,
        subnetName: BytesLike,
        githubRepo: BytesLike,
        subnetContact: BytesLike,
        subnetUrl: BytesLike,
        discord: BytesLike,
        description: BytesLike,
        additional: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetSubnetIdentity";
            params: {
              netuid: number;
              subnetName: BytesLike;
              githubRepo: BytesLike;
              subnetContact: BytesLike;
              subnetUrl: BytesLike;
              discord: BytesLike;
              description: BytesLike;
              additional: BytesLike;
            };
          };
        }
      >
    >;

    /**
     * User register a new subnetwork
     *
     * @param {AccountId32Like} hotkey
     * @param {PalletSubtensorSubnetIdentityV2 | undefined} identity
     **/
    registerNetworkWithIdentity: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        identity: PalletSubtensorSubnetIdentityV2 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RegisterNetworkWithIdentity";
            params: {
              hotkey: AccountId32Like;
              identity: PalletSubtensorSubnetIdentityV2 | undefined;
            };
          };
        }
      >
    >;

    /**
     * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
     *
     * # Args:
     * * `origin` - (<T as frame_system::Config>::Origin):
     * - The signature of the caller's coldkey.
     *
     * * `hotkey` (T::AccountId):
     * - The associated hotkey account.
     *
     * # Event:
     * * StakeRemoved;
     * - On the successfully removing stake from the hotkey account.
     *
     * # Raises:
     * * `NotRegistered`:
     * - Thrown if the account we are attempting to unstake from is non existent.
     *
     * * `NonAssociatedColdKey`:
     * - Thrown if the coldkey does not own the hotkey we are unstaking from.
     *
     * * `NotEnoughStakeToWithdraw`:
     * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
     *
     * * `TxRateLimitExceeded`:
     * - Thrown if key has hit transaction rate limit
     *
     * @param {AccountId32Like} hotkey
     **/
    unstakeAll: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "UnstakeAll";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
     *
     * # Args:
     * * `origin` - (<T as frame_system::Config>::Origin):
     * - The signature of the caller's coldkey.
     *
     * * `hotkey` (T::AccountId):
     * - The associated hotkey account.
     *
     * # Event:
     * * StakeRemoved;
     * - On the successfully removing stake from the hotkey account.
     *
     * # Raises:
     * * `NotRegistered`:
     * - Thrown if the account we are attempting to unstake from is non existent.
     *
     * * `NonAssociatedColdKey`:
     * - Thrown if the coldkey does not own the hotkey we are unstaking from.
     *
     * * `NotEnoughStakeToWithdraw`:
     * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
     *
     * * `TxRateLimitExceeded`:
     * - Thrown if key has hit transaction rate limit
     *
     * @param {AccountId32Like} hotkey
     **/
    unstakeAllAlpha: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "UnstakeAllAlpha";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * ---- The implementation for the extrinsic move_stake: Moves specified amount of stake from a hotkey to another across subnets.
     *
     * # Args:
     * * `origin` - (<T as frame_system::Config>::Origin):
     * - The signature of the caller's coldkey.
     *
     * * `origin_hotkey` (T::AccountId):
     * - The hotkey account to move stake from.
     *
     * * `destination_hotkey` (T::AccountId):
     * - The hotkey account to move stake to.
     *
     * * `origin_netuid` (T::AccountId):
     * - The subnet ID to move stake from.
     *
     * * `destination_netuid` (T::AccountId):
     * - The subnet ID to move stake to.
     *
     * * `alpha_amount` (T::AccountId):
     * - The alpha stake amount to move.
     *
     *
     * @param {AccountId32Like} originHotkey
     * @param {AccountId32Like} destinationHotkey
     * @param {number} originNetuid
     * @param {number} destinationNetuid
     * @param {bigint} alphaAmount
     **/
    moveStake: GenericTxCall<
      Rv,
      (
        originHotkey: AccountId32Like,
        destinationHotkey: AccountId32Like,
        originNetuid: number,
        destinationNetuid: number,
        alphaAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "MoveStake";
            params: {
              originHotkey: AccountId32Like;
              destinationHotkey: AccountId32Like;
              originNetuid: number;
              destinationNetuid: number;
              alphaAmount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Transfers a specified amount of stake from one coldkey to another, optionally across subnets,
     * while keeping the same hotkey.
     *
     * # Arguments
     * * `origin` - The origin of the transaction, which must be signed by the `origin_coldkey`.
     * * `destination_coldkey` - The coldkey to which the stake is transferred.
     * * `hotkey` - The hotkey associated with the stake.
     * * `origin_netuid` - The network/subnet ID to move stake from.
     * * `destination_netuid` - The network/subnet ID to move stake to (for cross-subnet transfer).
     * * `alpha_amount` - The amount of stake to transfer.
     *
     * # Errors
     * Returns an error if:
     * * The origin is not signed by the correct coldkey.
     * * Either subnet does not exist.
     * * The hotkey does not exist.
     * * There is insufficient stake on `(origin_coldkey, hotkey, origin_netuid)`.
     * * The transfer amount is below the minimum stake requirement.
     *
     * # Events
     * May emit a `StakeTransferred` event on success.
     *
     * @param {AccountId32Like} destinationColdkey
     * @param {AccountId32Like} hotkey
     * @param {number} originNetuid
     * @param {number} destinationNetuid
     * @param {bigint} alphaAmount
     **/
    transferStake: GenericTxCall<
      Rv,
      (
        destinationColdkey: AccountId32Like,
        hotkey: AccountId32Like,
        originNetuid: number,
        destinationNetuid: number,
        alphaAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "TransferStake";
            params: {
              destinationColdkey: AccountId32Like;
              hotkey: AccountId32Like;
              originNetuid: number;
              destinationNetuid: number;
              alphaAmount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
     *
     * # Arguments
     * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
     * * `hotkey` - The hotkey whose stake is being swapped.
     * * `origin_netuid` - The network/subnet ID from which stake is removed.
     * * `destination_netuid` - The network/subnet ID to which stake is added.
     * * `alpha_amount` - The amount of stake to swap.
     *
     * # Errors
     * Returns an error if:
     * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
     * * Either `origin_netuid` or `destination_netuid` does not exist.
     * * The hotkey does not exist.
     * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
     * * The swap amount is below the minimum stake requirement.
     *
     * # Events
     * May emit a `StakeSwapped` event on success.
     *
     * @param {AccountId32Like} hotkey
     * @param {number} originNetuid
     * @param {number} destinationNetuid
     * @param {bigint} alphaAmount
     **/
    swapStake: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        originNetuid: number,
        destinationNetuid: number,
        alphaAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SwapStake";
            params: {
              hotkey: AccountId32Like;
              originNetuid: number;
              destinationNetuid: number;
              alphaAmount: bigint;
            };
          };
        }
      >
    >;

    /**
     * --- Adds stake to a hotkey on a subnet with a price limit.
     * This extrinsic allows to specify the limit price for alpha token
     * at which or better (lower) the staking should execute.
     *
     * In case if slippage occurs and the price shall move beyond the limit
     * price, the staking order may execute only partially or not execute
     * at all.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The associated hotkey account.
     *
     * * 'netuid' (u16):
     * - Subnetwork UID
     *
     * * 'amount_staked' (u64):
     * - The amount of stake to be added to the hotkey staking account.
     *
     * * 'limit_price' (u64):
     * - The limit price expressed in units of RAO per one Alpha.
     *
     * * 'allow_partial' (bool):
     * - Allows partial execution of the amount. If set to false, this becomes
     * fill or kill type or order.
     *
     * # Event:
     * * StakeAdded;
     * - On the successfully adding stake to a global account.
     *
     * # Raises:
     * * 'NotEnoughBalanceToStake':
     * - Not enough balance on the coldkey to add onto the global account.
     *
     * * 'NonAssociatedColdKey':
     * - The calling coldkey is not associated with this hotkey.
     *
     * * 'BalanceWithdrawalError':
     * - Errors stemming from transaction pallet.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {bigint} amountStaked
     * @param {bigint} limitPrice
     * @param {boolean} allowPartial
     **/
    addStakeLimit: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        amountStaked: bigint,
        limitPrice: bigint,
        allowPartial: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "AddStakeLimit";
            params: {
              hotkey: AccountId32Like;
              netuid: number;
              amountStaked: bigint;
              limitPrice: bigint;
              allowPartial: boolean;
            };
          };
        }
      >
    >;

    /**
     * --- Removes stake from a hotkey on a subnet with a price limit.
     * This extrinsic allows to specify the limit price for alpha token
     * at which or better (higher) the staking should execute.
     *
     * In case if slippage occurs and the price shall move beyond the limit
     * price, the staking order may execute only partially or not execute
     * at all.
     *
     * # Args:
     * * 'origin': (<T as frame_system::Config>Origin):
     * - The signature of the caller's coldkey.
     *
     * * 'hotkey' (T::AccountId):
     * - The associated hotkey account.
     *
     * * 'netuid' (u16):
     * - Subnetwork UID
     *
     * * 'amount_unstaked' (u64):
     * - The amount of stake to be added to the hotkey staking account.
     *
     * * 'limit_price' (u64):
     * - The limit price expressed in units of RAO per one Alpha.
     *
     * * 'allow_partial' (bool):
     * - Allows partial execution of the amount. If set to false, this becomes
     * fill or kill type or order.
     *
     * # Event:
     * * StakeRemoved;
     * - On the successfully removing stake from the hotkey account.
     *
     * # Raises:
     * * 'NotRegistered':
     * - Thrown if the account we are attempting to unstake from is non existent.
     *
     * * 'NonAssociatedColdKey':
     * - Thrown if the coldkey does not own the hotkey we are unstaking from.
     *
     * * 'NotEnoughStakeToWithdraw':
     * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
     *
     *
     * @param {AccountId32Like} hotkey
     * @param {number} netuid
     * @param {bigint} amountUnstaked
     * @param {bigint} limitPrice
     * @param {boolean} allowPartial
     **/
    removeStakeLimit: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        netuid: number,
        amountUnstaked: bigint,
        limitPrice: bigint,
        allowPartial: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RemoveStakeLimit";
            params: {
              hotkey: AccountId32Like;
              netuid: number;
              amountUnstaked: bigint;
              limitPrice: bigint;
              allowPartial: boolean;
            };
          };
        }
      >
    >;

    /**
     * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
     *
     * # Arguments
     * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
     * * `hotkey` - The hotkey whose stake is being swapped.
     * * `origin_netuid` - The network/subnet ID from which stake is removed.
     * * `destination_netuid` - The network/subnet ID to which stake is added.
     * * `alpha_amount` - The amount of stake to swap.
     * * `limit_price` - The limit price expressed in units of RAO per one Alpha.
     * * `allow_partial` - Allows partial execution of the amount. If set to false, this becomes fill or kill type or order.
     *
     * # Errors
     * Returns an error if:
     * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
     * * Either `origin_netuid` or `destination_netuid` does not exist.
     * * The hotkey does not exist.
     * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
     * * The swap amount is below the minimum stake requirement.
     *
     * # Events
     * May emit a `StakeSwapped` event on success.
     *
     * @param {AccountId32Like} hotkey
     * @param {number} originNetuid
     * @param {number} destinationNetuid
     * @param {bigint} alphaAmount
     * @param {bigint} limitPrice
     * @param {boolean} allowPartial
     **/
    swapStakeLimit: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        originNetuid: number,
        destinationNetuid: number,
        alphaAmount: bigint,
        limitPrice: bigint,
        allowPartial: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SwapStakeLimit";
            params: {
              hotkey: AccountId32Like;
              originNetuid: number;
              destinationNetuid: number;
              alphaAmount: bigint;
              limitPrice: bigint;
              allowPartial: boolean;
            };
          };
        }
      >
    >;

    /**
     * Attempts to associate a hotkey with a coldkey.
     *
     * # Arguments
     * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
     * * `hotkey` - The hotkey to associate with the coldkey.
     *
     * # Note
     * Will charge based on the weight even if the hotkey is already associated with a coldkey.
     *
     * @param {AccountId32Like} hotkey
     **/
    tryAssociateHotkey: GenericTxCall<
      Rv,
      (hotkey: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "TryAssociateHotkey";
            params: { hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Initiates a call on a subnet.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be signed by the subnet owner.
     * * `netuid` - The unique identifier of the subnet on which the call is being initiated.
     *
     * # Events
     * Emits a `FirstEmissionBlockNumberSet` event on success.
     *
     * @param {number} netuid
     **/
    startCall: GenericTxCall<
      Rv,
      (netuid: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "StartCall";
            params: { netuid: number };
          };
        }
      >
    >;

    /**
     * Attempts to associate a hotkey with an EVM key.
     *
     * The signature will be checked to see if the recovered public key matches the `evm_key` provided.
     *
     * The EVM key is expected to sign the message according to this formula to produce the signature:
     * ```text
     * keccak_256(hotkey ++ keccak_256(block_number))
     * ```
     *
     * # Arguments
     * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
     * * `netuid` - The netuid that the `hotkey` belongs to.
     * * `hotkey` - The hotkey associated with the `origin`.
     * * `evm_key` - The EVM key to associate with the `hotkey`.
     * * `block_number` - The block number used in the `signature`.
     * * `signature` - A signed message by the `evm_key` containing the `hotkey` and the hashed `block_number`.
     *
     * # Errors
     * Returns an error if:
     * * The transaction is not signed.
     * * The hotkey is not owned by the origin coldkey.
     * * The hotkey does not belong to the subnet identified by the netuid.
     * * The EVM key cannot be recovered from the signature.
     * * The EVM key recovered from the signature does not match the given EVM key.
     *
     * # Events
     * May emit a `EvmKeyAssociated` event on success
     *
     * @param {number} netuid
     * @param {AccountId32Like} hotkey
     * @param {H160} evmKey
     * @param {bigint} blockNumber
     * @param {FixedBytes<65>} signature
     **/
    associateEvmKey: GenericTxCall<
      Rv,
      (
        netuid: number,
        hotkey: AccountId32Like,
        evmKey: H160,
        blockNumber: bigint,
        signature: FixedBytes<65>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "AssociateEvmKey";
            params: {
              netuid: number;
              hotkey: AccountId32Like;
              evmKey: H160;
              blockNumber: bigint;
              signature: FixedBytes<65>;
            };
          };
        }
      >
    >;

    /**
     * Recycles alpha from a cold/hot key pair, reducing AlphaOut on a subnet
     *
     * # Arguments
     * * `origin` - The origin of the call (must be signed by the coldkey)
     * * `hotkey` - The hotkey account
     * * `amount` - The amount of alpha to recycle
     * * `netuid` - The subnet ID
     *
     * # Events
     * Emits a `TokensRecycled` event on success.
     *
     * @param {AccountId32Like} hotkey
     * @param {bigint} amount
     * @param {number} netuid
     **/
    recycleAlpha: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        amount: bigint,
        netuid: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "RecycleAlpha";
            params: { hotkey: AccountId32Like; amount: bigint; netuid: number };
          };
        }
      >
    >;

    /**
     * Burns alpha from a cold/hot key pair without reducing `AlphaOut`
     *
     * # Arguments
     * * `origin` - The origin of the call (must be signed by the coldkey)
     * * `hotkey` - The hotkey account
     * * `amount` - The amount of alpha to burn
     * * `netuid` - The subnet ID
     *
     * # Events
     * Emits a `TokensBurned` event on success.
     *
     * @param {AccountId32Like} hotkey
     * @param {bigint} amount
     * @param {number} netuid
     **/
    burnAlpha: GenericTxCall<
      Rv,
      (
        hotkey: AccountId32Like,
        amount: bigint,
        netuid: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "BurnAlpha";
            params: { hotkey: AccountId32Like; amount: bigint; netuid: number };
          };
        }
      >
    >;

    /**
     * Sets the pending childkey cooldown (in blocks). Root only.
     *
     * @param {bigint} cooldown
     **/
    setPendingChildkeyCooldown: GenericTxCall<
      Rv,
      (cooldown: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SubtensorModule";
          palletCall: {
            name: "SetPendingChildkeyCooldown";
            params: { cooldown: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Triumvirate`'s transaction calls
   **/
  triumvirate: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId32Like>} newMembers
     * @param {AccountId32Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      Rv,
      (
        newMembers: Array<AccountId32Like>,
        prime: AccountId32Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "SetMembers";
            params: {
              newMembers: Array<AccountId32Like>;
              prime: AccountId32Like | undefined;
              oldCount: number;
            };
          };
        }
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      Rv,
      (
        proposal: NodeSubtensorRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "Execute";
            params: {
              proposal: NodeSubtensorRuntimeRuntimeCallLike;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     * @param {number} duration
     **/
    propose: GenericTxCall<
      Rv,
      (
        proposal: NodeSubtensorRuntimeRuntimeCallLike,
        lengthBound: number,
        duration: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "Propose";
            params: {
              proposal: NodeSubtensorRuntimeRuntimeCallLike;
              lengthBound: number;
              duration: number;
            };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "Vote";
            params: { proposal: H256; index: number; approve: boolean };
          };
        }
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "DisapproveProposal";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Triumvirate";
          palletCall: {
            name: "Close";
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `TriumvirateMembers`'s transaction calls
   **/
  triumvirateMembers: {
    /**
     * Add a member `who` to the set.
     *
     * May only be called from `T::AddOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    addMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "AddMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a member `who` from the set.
     *
     * May only be called from `T::RemoveOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    removeMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "RemoveMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Swap out one member `remove` for another `add`.
     *
     * May only be called from `T::SwapOrigin`.
     *
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     *
     * @param {MultiAddressLike} remove
     * @param {MultiAddressLike} add
     **/
    swapMember: GenericTxCall<
      Rv,
      (
        remove: MultiAddressLike,
        add: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "SwapMember";
            params: { remove: MultiAddressLike; add: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     *
     * May only be called from `T::ResetOrigin`.
     *
     * @param {Array<AccountId32Like>} members
     **/
    resetMembers: GenericTxCall<
      Rv,
      (members: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "ResetMembers";
            params: { members: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Swap out the sending member for some other key `new`.
     *
     * May only be called from `Signed` origin of a current member.
     *
     * Prime membership is passed from the origin account to `new`, if extant.
     *
     * @param {MultiAddressLike} new_
     **/
    changeKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "ChangeKey";
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the prime member. Must be a current member.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    setPrime: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "SetPrime";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the prime member if it exists.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     **/
    clearPrime: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TriumvirateMembers";
          palletCall: {
            name: "ClearPrime";
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `SenateMembers`'s transaction calls
   **/
  senateMembers: {
    /**
     * Add a member `who` to the set.
     *
     * May only be called from `T::AddOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    addMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "AddMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a member `who` from the set.
     *
     * May only be called from `T::RemoveOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    removeMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "RemoveMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Swap out one member `remove` for another `add`.
     *
     * May only be called from `T::SwapOrigin`.
     *
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     *
     * @param {MultiAddressLike} remove
     * @param {MultiAddressLike} add
     **/
    swapMember: GenericTxCall<
      Rv,
      (
        remove: MultiAddressLike,
        add: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "SwapMember";
            params: { remove: MultiAddressLike; add: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     *
     * May only be called from `T::ResetOrigin`.
     *
     * @param {Array<AccountId32Like>} members
     **/
    resetMembers: GenericTxCall<
      Rv,
      (members: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "ResetMembers";
            params: { members: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Swap out the sending member for some other key `new`.
     *
     * May only be called from `Signed` origin of a current member.
     *
     * Prime membership is passed from the origin account to `new`, if extant.
     *
     * @param {MultiAddressLike} new_
     **/
    changeKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "ChangeKey";
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the prime member. Must be a current member.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    setPrime: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "SetPrime";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the prime member if it exists.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     **/
    clearPrime: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SenateMembers";
          palletCall: {
            name: "ClearPrime";
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<NodeSubtensorRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (
        calls: Array<NodeSubtensorRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "Batch";
            params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "AsDerivative";
            params: {
              index: number;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<NodeSubtensorRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (
        calls: Array<NodeSubtensorRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "BatchAll";
            params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {NodeSubtensorRuntimeOriginCaller} asOrigin
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: NodeSubtensorRuntimeOriginCaller,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "DispatchAs";
            params: {
              asOrigin: NodeSubtensorRuntimeOriginCaller;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<NodeSubtensorRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (
        calls: Array<NodeSubtensorRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "ForceBatch";
            params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: NodeSubtensorRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "WithWeight";
            params: {
              call: NodeSubtensorRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Sudo`'s transaction calls
   **/
  sudo: {
    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    sudo: GenericTxCall<
      Rv,
      (call: NodeSubtensorRuntimeRuntimeCallLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Sudo";
          palletCall: {
            name: "Sudo";
            params: { call: NodeSubtensorRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Root` origin.
     * This function does not check the weight of the call, and instead allows the
     * Sudo user to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    sudoUncheckedWeight: GenericTxCall<
      Rv,
      (
        call: NodeSubtensorRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Sudo";
          palletCall: {
            name: "SudoUncheckedWeight";
            params: {
              call: NodeSubtensorRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
     * key.
     *
     * @param {MultiAddressLike} new_
     **/
    setKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Sudo";
          palletCall: {
            name: "SetKey";
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Authenticates the sudo key and dispatches a function call with `Signed` origin from
     * a given account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {MultiAddressLike} who
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    sudoAs: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Sudo";
          palletCall: {
            name: "SudoAs";
            params: {
              who: MultiAddressLike;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Permanently removes the sudo key.
     *
     * **This cannot be un-done.**
     *
     **/
    removeKey: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Sudo";
          palletCall: {
            name: "RemoveKey";
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "AsMultiThreshold1";
            params: {
              otherSignatories: Array<AccountId32Like>;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: NodeSubtensorRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "AsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: NodeSubtensorRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "ApproveAsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "CancelAsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "NotePreimage";
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "UnnotePreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "RequestPreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "UnrequestPreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "EnsureUpdated";
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "Schedule";
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "Cancel";
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleNamed";
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelNamed";
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleAfter";
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleNamedAfter";
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "SetRetry";
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "SetRetryNamed";
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelRetry";
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelRetryNamed";
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {SubtensorRuntimeCommonProxyType | undefined} forceProxyType
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: SubtensorRuntimeCommonProxyType | undefined,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "Proxy";
            params: {
              real: MultiAddressLike;
              forceProxyType: SubtensorRuntimeCommonProxyType | undefined;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {SubtensorRuntimeCommonProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: SubtensorRuntimeCommonProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "AddProxy";
            params: {
              delegate: MultiAddressLike;
              proxyType: SubtensorRuntimeCommonProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {SubtensorRuntimeCommonProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: SubtensorRuntimeCommonProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveProxy";
            params: {
              delegate: MultiAddressLike;
              proxyType: SubtensorRuntimeCommonProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveProxies";
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {SubtensorRuntimeCommonProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: SubtensorRuntimeCommonProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "CreatePure";
            params: {
              proxyType: SubtensorRuntimeCommonProxyType;
              delay: number;
              index: number;
            };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {SubtensorRuntimeCommonProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: SubtensorRuntimeCommonProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "KillPure";
            params: {
              spawner: MultiAddressLike;
              proxyType: SubtensorRuntimeCommonProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "Announce";
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveAnnouncement";
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RejectAnnouncement";
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {SubtensorRuntimeCommonProxyType | undefined} forceProxyType
     * @param {NodeSubtensorRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: SubtensorRuntimeCommonProxyType | undefined,
        call: NodeSubtensorRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "ProxyAnnounced";
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: SubtensorRuntimeCommonProxyType | undefined;
              call: NodeSubtensorRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Registry`'s transaction calls
   **/
  registry: {
    /**
     * Register an identity for an account. This will overwrite any existing identity.
     *
     * @param {AccountId32Like} identified
     * @param {PalletRegistryIdentityInfo} info
     **/
    setIdentity: GenericTxCall<
      Rv,
      (
        identified: AccountId32Like,
        info: PalletRegistryIdentityInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Registry";
          palletCall: {
            name: "SetIdentity";
            params: {
              identified: AccountId32Like;
              info: PalletRegistryIdentityInfo;
            };
          };
        }
      >
    >;

    /**
     * Clear the identity of an account.
     *
     * @param {AccountId32Like} identified
     **/
    clearIdentity: GenericTxCall<
      Rv,
      (identified: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Registry";
          palletCall: {
            name: "ClearIdentity";
            params: { identified: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Commitments`'s transaction calls
   **/
  commitments: {
    /**
     * Set the commitment for a given netuid
     *
     * @param {number} netuid
     * @param {PalletCommitmentsCommitmentInfo} info
     **/
    setCommitment: GenericTxCall<
      Rv,
      (
        netuid: number,
        info: PalletCommitmentsCommitmentInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Commitments";
          palletCall: {
            name: "SetCommitment";
            params: { netuid: number; info: PalletCommitmentsCommitmentInfo };
          };
        }
      >
    >;

    /**
     * *DEPRECATED* Sudo-set the commitment rate limit
     *
     * @param {number} rateLimitBlocks
     **/
    setRateLimit: GenericTxCall<
      Rv,
      (rateLimitBlocks: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Commitments";
          palletCall: {
            name: "SetRateLimit";
            params: { rateLimitBlocks: number };
          };
        }
      >
    >;

    /**
     * Sudo-set MaxSpace
     *
     * @param {number} newLimit
     **/
    setMaxSpace: GenericTxCall<
      Rv,
      (newLimit: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Commitments";
          palletCall: {
            name: "SetMaxSpace";
            params: { newLimit: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `AdminUtils`'s transaction calls
   **/
  adminUtils: {
    /**
     * The extrinsic sets the new authorities for Aura consensus.
     * It is only callable by the root account.
     * The extrinsic will call the Aura pallet to change the authorities.
     *
     * @param {Array<SpConsensusAuraSr25519AppSr25519Public>} newAuthorities
     **/
    swapAuthorities: GenericTxCall<
      Rv,
      (
        newAuthorities: Array<SpConsensusAuraSr25519AppSr25519Public>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SwapAuthorities";
            params: {
              newAuthorities: Array<SpConsensusAuraSr25519AppSr25519Public>;
            };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the default take for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the default take.
     *
     * @param {number} defaultTake
     **/
    sudoSetDefaultTake: GenericTxCall<
      Rv,
      (defaultTake: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetDefaultTake";
            params: { defaultTake: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the transaction rate limit for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the transaction rate limit.
     *
     * @param {bigint} txRateLimit
     **/
    sudoSetTxRateLimit: GenericTxCall<
      Rv,
      (txRateLimit: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetTxRateLimit";
            params: { txRateLimit: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the serving rate limit for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the serving rate limit.
     *
     * @param {number} netuid
     * @param {bigint} servingRateLimit
     **/
    sudoSetServingRateLimit: GenericTxCall<
      Rv,
      (
        netuid: number,
        servingRateLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetServingRateLimit";
            params: { netuid: number; servingRateLimit: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the minimum difficulty for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the minimum difficulty.
     *
     * @param {number} netuid
     * @param {bigint} minDifficulty
     **/
    sudoSetMinDifficulty: GenericTxCall<
      Rv,
      (
        netuid: number,
        minDifficulty: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMinDifficulty";
            params: { netuid: number; minDifficulty: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the maximum difficulty for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the maximum difficulty.
     *
     * @param {number} netuid
     * @param {bigint} maxDifficulty
     **/
    sudoSetMaxDifficulty: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxDifficulty: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxDifficulty";
            params: { netuid: number; maxDifficulty: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the weights version key for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the weights version key.
     *
     * @param {number} netuid
     * @param {bigint} weightsVersionKey
     **/
    sudoSetWeightsVersionKey: GenericTxCall<
      Rv,
      (
        netuid: number,
        weightsVersionKey: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetWeightsVersionKey";
            params: { netuid: number; weightsVersionKey: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the weights set rate limit for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the weights set rate limit.
     *
     * @param {number} netuid
     * @param {bigint} weightsSetRateLimit
     **/
    sudoSetWeightsSetRateLimit: GenericTxCall<
      Rv,
      (
        netuid: number,
        weightsSetRateLimit: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetWeightsSetRateLimit";
            params: { netuid: number; weightsSetRateLimit: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the adjustment interval for a subnet.
     * It is only callable by the root account, not changeable by the subnet owner.
     * The extrinsic will call the Subtensor pallet to set the adjustment interval.
     *
     * @param {number} netuid
     * @param {number} adjustmentInterval
     **/
    sudoSetAdjustmentInterval: GenericTxCall<
      Rv,
      (
        netuid: number,
        adjustmentInterval: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetAdjustmentInterval";
            params: { netuid: number; adjustmentInterval: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the adjustment alpha for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the adjustment alpha.
     *
     * @param {number} netuid
     * @param {bigint} adjustmentAlpha
     **/
    sudoSetAdjustmentAlpha: GenericTxCall<
      Rv,
      (
        netuid: number,
        adjustmentAlpha: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetAdjustmentAlpha";
            params: { netuid: number; adjustmentAlpha: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the adjustment beta for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the adjustment beta.
     *
     * @param {number} netuid
     * @param {number} maxWeightLimit
     **/
    sudoSetMaxWeightLimit: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxWeightLimit: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxWeightLimit";
            params: { netuid: number; maxWeightLimit: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the immunity period for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the immunity period.
     *
     * @param {number} netuid
     * @param {number} immunityPeriod
     **/
    sudoSetImmunityPeriod: GenericTxCall<
      Rv,
      (
        netuid: number,
        immunityPeriod: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetImmunityPeriod";
            params: { netuid: number; immunityPeriod: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the minimum allowed weights for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the minimum allowed weights.
     *
     * @param {number} netuid
     * @param {number} minAllowedWeights
     **/
    sudoSetMinAllowedWeights: GenericTxCall<
      Rv,
      (
        netuid: number,
        minAllowedWeights: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMinAllowedWeights";
            params: { netuid: number; minAllowedWeights: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the maximum allowed UIDs for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet.
     *
     * @param {number} netuid
     * @param {number} maxAllowedUids
     **/
    sudoSetMaxAllowedUids: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxAllowedUids: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxAllowedUids";
            params: { netuid: number; maxAllowedUids: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the kappa for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the kappa.
     *
     * @param {number} netuid
     * @param {number} kappa
     **/
    sudoSetKappa: GenericTxCall<
      Rv,
      (
        netuid: number,
        kappa: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetKappa";
            params: { netuid: number; kappa: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the rho for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the rho.
     *
     * @param {number} netuid
     * @param {number} rho
     **/
    sudoSetRho: GenericTxCall<
      Rv,
      (
        netuid: number,
        rho: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetRho";
            params: { netuid: number; rho: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the activity cutoff for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the activity cutoff.
     *
     * @param {number} netuid
     * @param {number} activityCutoff
     **/
    sudoSetActivityCutoff: GenericTxCall<
      Rv,
      (
        netuid: number,
        activityCutoff: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetActivityCutoff";
            params: { netuid: number; activityCutoff: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the network registration allowed for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the network registration allowed.
     *
     * @param {number} netuid
     * @param {boolean} registrationAllowed
     **/
    sudoSetNetworkRegistrationAllowed: GenericTxCall<
      Rv,
      (
        netuid: number,
        registrationAllowed: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkRegistrationAllowed";
            params: { netuid: number; registrationAllowed: boolean };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the network PoW registration allowed for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the network PoW registration allowed.
     *
     * @param {number} netuid
     * @param {boolean} registrationAllowed
     **/
    sudoSetNetworkPowRegistrationAllowed: GenericTxCall<
      Rv,
      (
        netuid: number,
        registrationAllowed: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkPowRegistrationAllowed";
            params: { netuid: number; registrationAllowed: boolean };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the target registrations per interval for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the target registrations per interval.
     *
     * @param {number} netuid
     * @param {number} targetRegistrationsPerInterval
     **/
    sudoSetTargetRegistrationsPerInterval: GenericTxCall<
      Rv,
      (
        netuid: number,
        targetRegistrationsPerInterval: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetTargetRegistrationsPerInterval";
            params: { netuid: number; targetRegistrationsPerInterval: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the minimum burn for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the minimum burn.
     *
     * @param {number} netuid
     * @param {bigint} minBurn
     **/
    sudoSetMinBurn: GenericTxCall<
      Rv,
      (
        netuid: number,
        minBurn: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMinBurn";
            params: { netuid: number; minBurn: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the maximum burn for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the maximum burn.
     *
     * @param {number} netuid
     * @param {bigint} maxBurn
     **/
    sudoSetMaxBurn: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxBurn: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxBurn";
            params: { netuid: number; maxBurn: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the difficulty for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the difficulty.
     *
     * @param {number} netuid
     * @param {bigint} difficulty
     **/
    sudoSetDifficulty: GenericTxCall<
      Rv,
      (
        netuid: number,
        difficulty: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetDifficulty";
            params: { netuid: number; difficulty: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the maximum allowed validators for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the maximum allowed validators.
     *
     * @param {number} netuid
     * @param {number} maxAllowedValidators
     **/
    sudoSetMaxAllowedValidators: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxAllowedValidators: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxAllowedValidators";
            params: { netuid: number; maxAllowedValidators: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the bonds moving average for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the bonds moving average.
     *
     * @param {number} netuid
     * @param {bigint} bondsMovingAverage
     **/
    sudoSetBondsMovingAverage: GenericTxCall<
      Rv,
      (
        netuid: number,
        bondsMovingAverage: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetBondsMovingAverage";
            params: { netuid: number; bondsMovingAverage: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the bonds penalty for a subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the bonds penalty.
     *
     * @param {number} netuid
     * @param {number} bondsPenalty
     **/
    sudoSetBondsPenalty: GenericTxCall<
      Rv,
      (
        netuid: number,
        bondsPenalty: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetBondsPenalty";
            params: { netuid: number; bondsPenalty: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the maximum registrations per block for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the maximum registrations per block.
     *
     * @param {number} netuid
     * @param {number} maxRegistrationsPerBlock
     **/
    sudoSetMaxRegistrationsPerBlock: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxRegistrationsPerBlock: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMaxRegistrationsPerBlock";
            params: { netuid: number; maxRegistrationsPerBlock: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the subnet owner cut for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the subnet owner cut.
     *
     * @param {number} subnetOwnerCut
     **/
    sudoSetSubnetOwnerCut: GenericTxCall<
      Rv,
      (subnetOwnerCut: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSubnetOwnerCut";
            params: { subnetOwnerCut: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the network rate limit for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the network rate limit.
     *
     * @param {bigint} rateLimit
     **/
    sudoSetNetworkRateLimit: GenericTxCall<
      Rv,
      (rateLimit: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkRateLimit";
            params: { rateLimit: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the tempo for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the tempo.
     *
     * @param {number} netuid
     * @param {number} tempo
     **/
    sudoSetTempo: GenericTxCall<
      Rv,
      (
        netuid: number,
        tempo: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetTempo";
            params: { netuid: number; tempo: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the total issuance for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the issuance for the network.
     *
     * @param {bigint} totalIssuance
     **/
    sudoSetTotalIssuance: GenericTxCall<
      Rv,
      (totalIssuance: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetTotalIssuance";
            params: { totalIssuance: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the immunity period for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the immunity period for the network.
     *
     * @param {bigint} immunityPeriod
     **/
    sudoSetNetworkImmunityPeriod: GenericTxCall<
      Rv,
      (immunityPeriod: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkImmunityPeriod";
            params: { immunityPeriod: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the min lock cost for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the min lock cost for the network.
     *
     * @param {bigint} lockCost
     **/
    sudoSetNetworkMinLockCost: GenericTxCall<
      Rv,
      (lockCost: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkMinLockCost";
            params: { lockCost: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the subnet limit for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the subnet limit.
     *
     * @param {number} maxSubnets
     **/
    sudoSetSubnetLimit: GenericTxCall<
      Rv,
      (maxSubnets: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSubnetLimit";
            params: { maxSubnets: number };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the lock reduction interval for the network.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the lock reduction interval.
     *
     * @param {bigint} interval
     **/
    sudoSetLockReductionInterval: GenericTxCall<
      Rv,
      (interval: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetLockReductionInterval";
            params: { interval: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the recycled RAO for a subnet.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the recycled RAO.
     *
     * @param {number} netuid
     * @param {bigint} raoRecycled
     **/
    sudoSetRaoRecycled: GenericTxCall<
      Rv,
      (
        netuid: number,
        raoRecycled: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetRaoRecycled";
            params: { netuid: number; raoRecycled: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the weights min stake.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the weights min stake.
     *
     * @param {bigint} minStake
     **/
    sudoSetStakeThreshold: GenericTxCall<
      Rv,
      (minStake: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetStakeThreshold";
            params: { minStake: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the minimum stake required for nominators.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators.
     *
     * @param {bigint} minStake
     **/
    sudoSetNominatorMinRequiredStake: GenericTxCall<
      Rv,
      (minStake: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNominatorMinRequiredStake";
            params: { minStake: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the rate limit for delegate take transactions.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions.
     *
     * @param {bigint} txRateLimit
     **/
    sudoSetTxDelegateTakeRateLimit: GenericTxCall<
      Rv,
      (txRateLimit: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetTxDelegateTakeRateLimit";
            params: { txRateLimit: bigint };
          };
        }
      >
    >;

    /**
     * The extrinsic sets the minimum delegate take.
     * It is only callable by the root account.
     * The extrinsic will call the Subtensor pallet to set the minimum delegate take.
     *
     * @param {number} take
     **/
    sudoSetMinDelegateTake: GenericTxCall<
      Rv,
      (take: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetMinDelegateTake";
            params: { take: number };
          };
        }
      >
    >;

    /**
     * The extrinsic enabled/disables commit/reaveal for a given subnet.
     * It is only callable by the root account or subnet owner.
     * The extrinsic will call the Subtensor pallet to set the value.
     *
     * @param {number} netuid
     * @param {boolean} enabled
     **/
    sudoSetCommitRevealWeightsEnabled: GenericTxCall<
      Rv,
      (
        netuid: number,
        enabled: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetCommitRevealWeightsEnabled";
            params: { netuid: number; enabled: boolean };
          };
        }
      >
    >;

    /**
     * Enables or disables Liquid Alpha for a given subnet.
     *
     * # Parameters
     * - `origin`: The origin of the call, which must be the root account or subnet owner.
     * - `netuid`: The unique identifier for the subnet.
     * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
     *
     * # Weight
     * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
     *
     * @param {number} netuid
     * @param {boolean} enabled
     **/
    sudoSetLiquidAlphaEnabled: GenericTxCall<
      Rv,
      (
        netuid: number,
        enabled: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetLiquidAlphaEnabled";
            params: { netuid: number; enabled: boolean };
          };
        }
      >
    >;

    /**
     * Sets values for liquid alpha
     *
     * @param {number} netuid
     * @param {number} alphaLow
     * @param {number} alphaHigh
     **/
    sudoSetAlphaValues: GenericTxCall<
      Rv,
      (
        netuid: number,
        alphaLow: number,
        alphaHigh: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetAlphaValues";
            params: { netuid: number; alphaLow: number; alphaHigh: number };
          };
        }
      >
    >;

    /**
     * Sets the maximum stake allowed for a specific network.
     *
     * This function allows the root account to set the maximum stake for a given network.
     * It updates the network's maximum stake value and logs the change.
     *
     * # Arguments
     *
     * * `origin` - The origin of the call, which must be the root account.
     * * `netuid` - The unique identifier of the network.
     * * `max_stake` - The new maximum stake value to set.
     *
     * # Returns
     *
     * Returns `Ok(())` if the operation is successful, or an error if it fails.
     *
     * # Example
     *
     *
     * # Notes
     *
     * - This function can only be called by the root account.
     * - The `netuid` should correspond to an existing network.
     *
     * # TODO
     *
     *
     * @param {number} netuid
     * @param {bigint} maxStake
     **/
    sudoSetNetworkMaxStake: GenericTxCall<
      Rv,
      (
        netuid: number,
        maxStake: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetNetworkMaxStake";
            params: { netuid: number; maxStake: bigint };
          };
        }
      >
    >;

    /**
     * Sets the duration of the coldkey swap schedule.
     *
     * This extrinsic allows the root account to set the duration for the coldkey swap schedule.
     * The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `duration` - The new duration for the coldkey swap schedule, in number of blocks.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} duration
     **/
    sudoSetColdkeySwapScheduleDuration: GenericTxCall<
      Rv,
      (duration: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetColdkeySwapScheduleDuration";
            params: { duration: number };
          };
        }
      >
    >;

    /**
     * Sets the duration of the dissolve network schedule.
     *
     * This extrinsic allows the root account to set the duration for the dissolve network schedule.
     * The dissolve network schedule determines how long it takes for a network dissolution operation to complete.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `duration` - The new duration for the dissolve network schedule, in number of blocks.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} duration
     **/
    sudoSetDissolveNetworkScheduleDuration: GenericTxCall<
      Rv,
      (duration: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetDissolveNetworkScheduleDuration";
            params: { duration: number };
          };
        }
      >
    >;

    /**
     * Sets the commit-reveal weights periods for a specific subnet.
     *
     * This extrinsic allows the subnet owner or root account to set the duration (in epochs) during which committed weights must be revealed.
     * The commit-reveal mechanism ensures that users commit weights in advance and reveal them only within a specified period.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the subnet owner or the root account.
     * * `netuid` - The unique identifier of the subnet for which the periods are being set.
     * * `periods` - The number of epochs that define the commit-reveal period.
     *
     * # Errors
     * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
     * * `SubnetDoesNotExist` - If the specified subnet does not exist.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} netuid
     * @param {bigint} interval
     **/
    sudoSetCommitRevealWeightsInterval: GenericTxCall<
      Rv,
      (
        netuid: number,
        interval: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetCommitRevealWeightsInterval";
            params: { netuid: number; interval: bigint };
          };
        }
      >
    >;

    /**
     * Sets the EVM ChainID.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the subnet owner or the root account.
     * * `chainId` - The u64 chain ID
     *
     * # Errors
     * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {bigint} chainId
     **/
    sudoSetEvmChainId: GenericTxCall<
      Rv,
      (chainId: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetEvmChainId";
            params: { chainId: bigint };
          };
        }
      >
    >;

    /**
     * A public interface for `pallet_grandpa::Pallet::schedule_grandpa_change`.
     *
     * Schedule a change in the authorities.
     *
     * The change will be applied at the end of execution of the block `in_blocks` after the
     * current block. This value may be 0, in which case the change is applied at the end of
     * the current block.
     *
     * If the `forced` parameter is defined, this indicates that the current set has been
     * synchronously determined to be offline and that after `in_blocks` the given change
     * should be applied. The given block number indicates the median last finalized block
     * number and it should be used as the canon block when starting the new grandpa voter.
     *
     * No change should be signaled while any change is pending. Returns an error if a change
     * is already pending.
     *
     * @param {Array<[SpConsensusGrandpaAppPublic, bigint]>} nextAuthorities
     * @param {number} inBlocks
     * @param {number | undefined} forced
     **/
    scheduleGrandpaChange: GenericTxCall<
      Rv,
      (
        nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>,
        inBlocks: number,
        forced: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "ScheduleGrandpaChange";
            params: {
              nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
              inBlocks: number;
              forced: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * Enables or disables Liquid Alpha for a given subnet.
     *
     * # Parameters
     * - `origin`: The origin of the call, which must be the root account or subnet owner.
     * - `netuid`: The unique identifier for the subnet.
     * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
     *
     * # Weight
     * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
     *
     * @param {number} netuid
     * @param {boolean} toggle
     **/
    sudoSetToggleTransfer: GenericTxCall<
      Rv,
      (
        netuid: number,
        toggle: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetToggleTransfer";
            params: { netuid: number; toggle: boolean };
          };
        }
      >
    >;

    /**
     * Toggles the enablement of an EVM precompile.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `precompile_id` - The identifier of the EVM precompile to toggle.
     * * `enabled` - The new enablement state of the precompile.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {PalletAdminUtilsPrecompileEnum} precompileId
     * @param {boolean} enabled
     **/
    sudoToggleEvmPrecompile: GenericTxCall<
      Rv,
      (
        precompileId: PalletAdminUtilsPrecompileEnum,
        enabled: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoToggleEvmPrecompile";
            params: {
              precompileId: PalletAdminUtilsPrecompileEnum;
              enabled: boolean;
            };
          };
        }
      >
    >;

    /**
     *
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `alpha` - The new moving alpha value for the SubnetMovingAlpha.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {SubstrateFixedFixedI128} alpha
     **/
    sudoSetSubnetMovingAlpha: GenericTxCall<
      Rv,
      (alpha: SubstrateFixedFixedI128) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSubnetMovingAlpha";
            params: { alpha: SubstrateFixedFixedI128 };
          };
        }
      >
    >;

    /**
     * Change the SubnetOwnerHotkey for a given subnet.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the subnet owner.
     * * `netuid` - The unique identifier for the subnet.
     * * `hotkey` - The new hotkey for the subnet owner.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the subnet owner or root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} netuid
     * @param {AccountId32Like} hotkey
     **/
    sudoSetSubnetOwnerHotkey: GenericTxCall<
      Rv,
      (
        netuid: number,
        hotkey: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSubnetOwnerHotkey";
            params: { netuid: number; hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     *
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `ema_alpha_period` - Number of blocks for EMA price to halve
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} netuid
     * @param {bigint} emaHalving
     **/
    sudoSetEmaPriceHalvingPeriod: GenericTxCall<
      Rv,
      (
        netuid: number,
        emaHalving: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetEmaPriceHalvingPeriod";
            params: { netuid: number; emaHalving: bigint };
          };
        }
      >
    >;

    /**
     *
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `netuid` - The unique identifier for the subnet.
     * * `steepness` - The new steepness for the alpha sigmoid function.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} netuid
     * @param {number} steepness
     **/
    sudoSetAlphaSigmoidSteepness: GenericTxCall<
      Rv,
      (
        netuid: number,
        steepness: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetAlphaSigmoidSteepness";
            params: { netuid: number; steepness: number };
          };
        }
      >
    >;

    /**
     * Enables or disables Yuma3 for a given subnet.
     *
     * # Parameters
     * - `origin`: The origin of the call, which must be the root account or subnet owner.
     * - `netuid`: The unique identifier for the subnet.
     * - `enabled`: A boolean flag to enable or disable Yuma3.
     *
     * # Weight
     * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
     *
     * @param {number} netuid
     * @param {boolean} enabled
     **/
    sudoSetYuma3Enabled: GenericTxCall<
      Rv,
      (
        netuid: number,
        enabled: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetYuma3Enabled";
            params: { netuid: number; enabled: boolean };
          };
        }
      >
    >;

    /**
     * Sets or updates the hotkey account associated with the owner of a specific subnet.
     *
     * This function allows either the root origin or the current subnet owner to set or update
     * the hotkey for a given subnet. The subnet must already exist. To prevent abuse, the call is
     * rate-limited to once per configured interval (default: one week) per subnet.
     *
     * # Parameters
     * - `origin`: The dispatch origin of the call. Must be either root or the current owner of the subnet.
     * - `netuid`: The unique identifier of the subnet whose owner hotkey is being set.
     * - `hotkey`: The new hotkey account to associate with the subnet owner.
     *
     * # Returns
     * - `DispatchResult`: Returns `Ok(())` if the hotkey was successfully set, or an appropriate error otherwise.
     *
     * # Errors
     * - `Error::SubnetNotExists`: If the specified subnet does not exist.
     * - `Error::TxRateLimitExceeded`: If the function is called more frequently than the allowed rate limit.
     *
     * # Access Control
     * Only callable by:
     * - Root origin, or
     * - The coldkey account that owns the subnet.
     *
     * # Storage
     * - Updates [`SubnetOwnerHotkey`] for the given `netuid`.
     * - Reads and updates [`LastRateLimitedBlock`] for rate-limiting.
     * - Reads [`DefaultSetSNOwnerHotkeyRateLimit`] to determine the interval between allowed updates.
     *
     * # Rate Limiting
     * This function is rate-limited to one call per subnet per interval (e.g., one week).
     *
     * @param {number} netuid
     * @param {AccountId32Like} hotkey
     **/
    sudoSetSnOwnerHotkey: GenericTxCall<
      Rv,
      (
        netuid: number,
        hotkey: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSnOwnerHotkey";
            params: { netuid: number; hotkey: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Enables or disables subtoken trading for a given subnet.
     *
     * # Arguments
     * * `origin` - The origin of the call, which must be the root account.
     * * `netuid` - The unique identifier of the subnet.
     * * `subtoken_enabled` - A boolean indicating whether subtoken trading should be enabled or disabled.
     *
     * # Errors
     * * `BadOrigin` - If the caller is not the root account.
     *
     * # Weight
     * Weight is handled by the `#[pallet::weight]` attribute.
     *
     * @param {number} netuid
     * @param {boolean} subtokenEnabled
     **/
    sudoSetSubtokenEnabled: GenericTxCall<
      Rv,
      (
        netuid: number,
        subtokenEnabled: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "AdminUtils";
          palletCall: {
            name: "SudoSetSubtokenEnabled";
            params: { netuid: number; subtokenEnabled: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `SafeMode`'s transaction calls
   **/
  safeMode: {
    /**
     * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
     *
     * Reserves [`Config::EnterDepositAmount`] from the caller's account.
     * Emits an [`Event::Entered`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is already entered.
     * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
     *
     **/
    enter: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "Enter";
          };
        }
      >
    >;

    /**
     * Enter safe-mode by force for a per-origin configured number of blocks.
     *
     * Emits an [`Event::Entered`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is already entered.
     *
     * Can only be called by the [`Config::ForceEnterOrigin`] origin.
     *
     **/
    forceEnter: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ForceEnter";
          };
        }
      >
    >;

    /**
     * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
     *
     * This accumulates on top of the current remaining duration.
     * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
     * Emits an [`Event::Extended`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is entered.
     * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
     *
     * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
     * currency to reserve. This call can be disabled for all origins by configuring
     * [`Config::ExtendDepositAmount`] to `None`.
     *
     **/
    extend: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "Extend";
          };
        }
      >
    >;

    /**
     * Extend the safe-mode by force for a per-origin configured number of blocks.
     *
     * Emits an [`Event::Extended`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is inactive.
     *
     * Can only be called by the [`Config::ForceExtendOrigin`] origin.
     *
     **/
    forceExtend: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ForceExtend";
          };
        }
      >
    >;

    /**
     * Exit safe-mode by force.
     *
     * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
     * Errors with [`Error::Exited`] if the safe-mode is inactive.
     *
     * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
     * after the block height is greater than the [`EnteredUntil`] storage item.
     * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
     * hook.
     *
     **/
    forceExit: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ForceExit";
          };
        }
      >
    >;

    /**
     * Slash a deposit for an account that entered or extended safe-mode at a given
     * historical block.
     *
     * This can only be called while safe-mode is entered.
     *
     * Emits a [`Event::DepositSlashed`] event on success.
     * Errors with [`Error::Entered`] if safe-mode is entered.
     *
     * Can only be called by the [`Config::ForceDepositOrigin`] origin.
     *
     * @param {AccountId32Like} account
     * @param {number} block
     **/
    forceSlashDeposit: GenericTxCall<
      Rv,
      (
        account: AccountId32Like,
        block: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ForceSlashDeposit";
            params: { account: AccountId32Like; block: number };
          };
        }
      >
    >;

    /**
     * Permissionlessly release a deposit for an account that entered safe-mode at a
     * given historical block.
     *
     * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
     * This cannot be called while safe-mode is entered and not until
     * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
     *
     * Emits a [`Event::DepositReleased`] event on success.
     * Errors with [`Error::Entered`] if the safe-mode is entered.
     * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
     * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
     * reserved currency at the block specified.
     *
     * @param {AccountId32Like} account
     * @param {number} block
     **/
    releaseDeposit: GenericTxCall<
      Rv,
      (
        account: AccountId32Like,
        block: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ReleaseDeposit";
            params: { account: AccountId32Like; block: number };
          };
        }
      >
    >;

    /**
     * Force to release a deposit for an account that entered safe-mode at a given
     * historical block.
     *
     * This can be called while safe-mode is still entered.
     *
     * Emits a [`Event::DepositReleased`] event on success.
     * Errors with [`Error::Entered`] if safe-mode is entered.
     * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
     * specified block.
     *
     * Can only be called by the [`Config::ForceDepositOrigin`] origin.
     *
     * @param {AccountId32Like} account
     * @param {number} block
     **/
    forceReleaseDeposit: GenericTxCall<
      Rv,
      (
        account: AccountId32Like,
        block: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "SafeMode";
          palletCall: {
            name: "ForceReleaseDeposit";
            params: { account: AccountId32Like; block: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Ethereum`'s transaction calls
   **/
  ethereum: {
    /**
     * Transact an Ethereum transaction.
     *
     * @param {EthereumTransactionTransactionV2} transaction
     **/
    transact: GenericTxCall<
      Rv,
      (
        transaction: EthereumTransactionTransactionV2,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Ethereum";
          palletCall: {
            name: "Transact";
            params: { transaction: EthereumTransactionTransactionV2 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `EVM`'s transaction calls
   **/
  evm: {
    /**
     * Withdraw balance from EVM into currency/balances pallet.
     *
     * @param {H160} address
     * @param {bigint} value
     **/
    withdraw: GenericTxCall<
      Rv,
      (
        address: H160,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "Withdraw";
            params: { address: H160; value: bigint };
          };
        }
      >
    >;

    /**
     * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
     *
     * @param {H160} source
     * @param {H160} target
     * @param {BytesLike} input
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    call: GenericTxCall<
      Rv,
      (
        source: H160,
        target: H160,
        input: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "Call";
            params: {
              source: H160;
              target: H160;
              input: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     * Issue an EVM create operation. This is similar to a contract creation transaction in
     * Ethereum.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create: GenericTxCall<
      Rv,
      (
        source: H160,
        init: BytesLike,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "Create";
            params: {
              source: H160;
              init: BytesLike;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     * Issue an EVM create2 operation.
     *
     * @param {H160} source
     * @param {BytesLike} init
     * @param {H256} salt
     * @param {U256} value
     * @param {bigint} gasLimit
     * @param {U256} maxFeePerGas
     * @param {U256 | undefined} maxPriorityFeePerGas
     * @param {U256 | undefined} nonce
     * @param {Array<[H160, Array<H256>]>} accessList
     **/
    create2: GenericTxCall<
      Rv,
      (
        source: H160,
        init: BytesLike,
        salt: H256,
        value: U256,
        gasLimit: bigint,
        maxFeePerGas: U256,
        maxPriorityFeePerGas: U256 | undefined,
        nonce: U256 | undefined,
        accessList: Array<[H160, Array<H256>]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "Create2";
            params: {
              source: H160;
              init: BytesLike;
              salt: H256;
              value: U256;
              gasLimit: bigint;
              maxFeePerGas: U256;
              maxPriorityFeePerGas: U256 | undefined;
              nonce: U256 | undefined;
              accessList: Array<[H160, Array<H256>]>;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {Array<H160>} new_
     **/
    setWhitelist: GenericTxCall<
      Rv,
      (new_: Array<H160>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "SetWhitelist";
            params: { new: Array<H160> };
          };
        }
      >
    >;

    /**
     *
     * @param {boolean} disabled
     **/
    disableWhitelist: GenericTxCall<
      Rv,
      (disabled: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Evm";
          palletCall: {
            name: "DisableWhitelist";
            params: { disabled: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `BaseFee`'s transaction calls
   **/
  baseFee: {
    /**
     *
     * @param {U256} fee
     **/
    setBaseFeePerGas: GenericTxCall<
      Rv,
      (fee: U256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "BaseFee";
          palletCall: {
            name: "SetBaseFeePerGas";
            params: { fee: U256 };
          };
        }
      >
    >;

    /**
     *
     * @param {Permill} elasticity
     **/
    setElasticity: GenericTxCall<
      Rv,
      (elasticity: Permill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "BaseFee";
          palletCall: {
            name: "SetElasticity";
            params: { elasticity: Permill };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Drand`'s transaction calls
   **/
  drand: {
    /**
     * Verify and write a pulse from the beacon into the runtime
     *
     * @param {PalletDrandPulsesPayload} pulsesPayload
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    writePulse: GenericTxCall<
      Rv,
      (
        pulsesPayload: PalletDrandPulsesPayload,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Drand";
          palletCall: {
            name: "WritePulse";
            params: {
              pulsesPayload: PalletDrandPulsesPayload;
              signature: SpRuntimeMultiSignature | undefined;
            };
          };
        }
      >
    >;

    /**
     * allows the root user to set the beacon configuration
     * generally this would be called from an offchain worker context.
     * there is no verification of configurations, so be careful with this.
     *
     * * `origin`: the root user
     * * `config`: the beacon configuration
     *
     * @param {PalletDrandBeaconConfigurationPayload} configPayload
     * @param {SpRuntimeMultiSignature | undefined} signature
     **/
    setBeaconConfig: GenericTxCall<
      Rv,
      (
        configPayload: PalletDrandBeaconConfigurationPayload,
        signature: SpRuntimeMultiSignature | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Drand";
          palletCall: {
            name: "SetBeaconConfig";
            params: {
              configPayload: PalletDrandBeaconConfigurationPayload;
              signature: SpRuntimeMultiSignature | undefined;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Crowdloan`'s transaction calls
   **/
  crowdloan: {
    /**
     * Create a crowdloan that will raise funds up to a maximum cap and if successful,
     * will transfer funds to the target address if provided and dispatch the call
     * (using creator origin).
     *
     * The initial deposit will be transfered to the crowdloan account and will be refunded
     * in case the crowdloan fails to raise the cap. Additionally, the creator will pay for
     * the execution of the call.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `deposit`: The initial deposit from the creator.
     * - `min_contribution`: The minimum contribution required to contribute to the crowdloan.
     * - `cap`: The maximum amount of funds that can be raised.
     * - `end`: The block number at which the crowdloan will end.
     * - `call`: The call to dispatch when the crowdloan is finalized.
     * - `target_address`: The address to transfer the raised funds to if provided.
     *
     * @param {bigint} deposit
     * @param {bigint} minContribution
     * @param {bigint} cap
     * @param {number} end
     * @param {NodeSubtensorRuntimeRuntimeCallLike | undefined} call
     * @param {AccountId32Like | undefined} targetAddress
     **/
    create: GenericTxCall<
      Rv,
      (
        deposit: bigint,
        minContribution: bigint,
        cap: bigint,
        end: number,
        call: NodeSubtensorRuntimeRuntimeCallLike | undefined,
        targetAddress: AccountId32Like | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Create";
            params: {
              deposit: bigint;
              minContribution: bigint;
              cap: bigint;
              end: number;
              call: NodeSubtensorRuntimeRuntimeCallLike | undefined;
              targetAddress: AccountId32Like | undefined;
            };
          };
        }
      >
    >;

    /**
     * Contribute to an active crowdloan.
     *
     * The contribution will be transfered to the crowdloan account and will be refunded
     * if the crowdloan fails to raise the cap. If the contribution would raise the amount above the cap,
     * the contribution will be set to the amount that is left to be raised.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to contribute to.
     * - `amount`: The amount to contribute.
     *
     * @param {number} crowdloanId
     * @param {bigint} amount
     **/
    contribute: GenericTxCall<
      Rv,
      (
        crowdloanId: number,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Contribute";
            params: { crowdloanId: number; amount: bigint };
          };
        }
      >
    >;

    /**
     * Withdraw a contribution from an active (not yet finalized or dissolved) crowdloan.
     *
     * Only contributions over the deposit can be withdrawn by the creator.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to withdraw from.
     *
     * @param {number} crowdloanId
     **/
    withdraw: GenericTxCall<
      Rv,
      (crowdloanId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Withdraw";
            params: { crowdloanId: number };
          };
        }
      >
    >;

    /**
     * Finalize a successful crowdloan.
     *
     * The call will transfer the raised amount to the target address if it was provided when the crowdloan was created
     * and dispatch the call that was provided using the creator origin. The CurrentCrowdloanId will be set to the
     * crowdloan id being finalized so the dispatched call can access it temporarily by accessing
     * the `CurrentCrowdloanId` storage item.
     *
     * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to finalize.
     *
     * @param {number} crowdloanId
     **/
    finalize: GenericTxCall<
      Rv,
      (crowdloanId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Finalize";
            params: { crowdloanId: number };
          };
        }
      >
    >;

    /**
     * Refund a failed crowdloan.
     *
     * The call will try to refund all contributors (excluding the creator) up to the limit defined by the `RefundContributorsLimit`.
     * If the limit is reached, the call will stop and the crowdloan will be marked as partially refunded.
     * It may be needed to dispatch this call multiple times to refund all contributors.
     *
     * The dispatch origin for this call must be _Signed_ and doesn't need to be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to refund.
     *
     * @param {number} crowdloanId
     **/
    refund: GenericTxCall<
      Rv,
      (crowdloanId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Refund";
            params: { crowdloanId: number };
          };
        }
      >
    >;

    /**
     * Dissolve a crowdloan.
     *
     * The crowdloan will be removed from the storage.
     * All contributions must have been refunded before the crowdloan can be dissolved (except the creator's one).
     *
     * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to dissolve.
     *
     * @param {number} crowdloanId
     **/
    dissolve: GenericTxCall<
      Rv,
      (crowdloanId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "Dissolve";
            params: { crowdloanId: number };
          };
        }
      >
    >;

    /**
     * Update the minimum contribution of a non-finalized crowdloan.
     *
     * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to update the minimum contribution of.
     * - `new_min_contribution`: The new minimum contribution.
     *
     * @param {number} crowdloanId
     * @param {bigint} newMinContribution
     **/
    updateMinContribution: GenericTxCall<
      Rv,
      (
        crowdloanId: number,
        newMinContribution: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "UpdateMinContribution";
            params: { crowdloanId: number; newMinContribution: bigint };
          };
        }
      >
    >;

    /**
     * Update the end block of a non-finalized crowdloan.
     *
     * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to update the end block of.
     * - `new_end`: The new end block.
     *
     * @param {number} crowdloanId
     * @param {number} newEnd
     **/
    updateEnd: GenericTxCall<
      Rv,
      (
        crowdloanId: number,
        newEnd: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "UpdateEnd";
            params: { crowdloanId: number; newEnd: number };
          };
        }
      >
    >;

    /**
     * Update the cap of a non-finalized crowdloan.
     *
     * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
     *
     * Parameters:
     * - `crowdloan_id`: The id of the crowdloan to update the cap of.
     * - `new_cap`: The new cap.
     *
     * @param {number} crowdloanId
     * @param {bigint} newCap
     **/
    updateCap: GenericTxCall<
      Rv,
      (
        crowdloanId: number,
        newCap: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Crowdloan";
          palletCall: {
            name: "UpdateCap";
            params: { crowdloanId: number; newCap: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
