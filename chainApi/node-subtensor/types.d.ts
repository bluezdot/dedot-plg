// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  FixedBytes,
  Result,
  H160,
  Bytes,
  U256,
  Permill,
  BytesLike,
  MultiAddress,
  MultiAddressLike,
  AccountId32Like,
  Era,
  Header,
  UncheckedExtrinsic,
  FixedArray,
} from "dedot/codecs";

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = {
  phase: Phase;
  event: NodeSubtensorRuntimeRuntimeEvent;
  topics: Array<H256>;
};

export type NodeSubtensorRuntimeRuntimeEvent =
  | { pallet: "System"; palletEvent: FrameSystemEvent }
  | { pallet: "Grandpa"; palletEvent: PalletGrandpaEvent }
  | { pallet: "Balances"; palletEvent: PalletBalancesEvent }
  | { pallet: "TransactionPayment"; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: "SubtensorModule"; palletEvent: PalletSubtensorEvent }
  | { pallet: "Triumvirate"; palletEvent: PalletCollectiveEvent }
  | { pallet: "TriumvirateMembers"; palletEvent: PalletMembershipEvent }
  | { pallet: "SenateMembers"; palletEvent: PalletMembershipEvent }
  | { pallet: "Utility"; palletEvent: PalletUtilityEvent }
  | { pallet: "Sudo"; palletEvent: PalletSudoEvent }
  | { pallet: "Multisig"; palletEvent: PalletMultisigEvent }
  | { pallet: "Preimage"; palletEvent: PalletPreimageEvent }
  | { pallet: "Scheduler"; palletEvent: PalletSchedulerEvent }
  | { pallet: "Proxy"; palletEvent: PalletProxyEvent }
  | { pallet: "Registry"; palletEvent: PalletRegistryEvent }
  | { pallet: "Commitments"; palletEvent: PalletCommitmentsEvent }
  | { pallet: "AdminUtils"; palletEvent: PalletAdminUtilsEvent }
  | { pallet: "SafeMode"; palletEvent: PalletSafeModeEvent }
  | { pallet: "Ethereum"; palletEvent: PalletEthereumEvent }
  | { pallet: "Evm"; palletEvent: PalletEvmEvent }
  | { pallet: "BaseFee"; palletEvent: PalletBaseFeeEvent }
  | { pallet: "Drand"; palletEvent: PalletDrandEvent }
  | { pallet: "Crowdloan"; palletEvent: PalletCrowdloanEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: "ExtrinsicSuccess"; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | {
      name: "ExtrinsicFailed";
      data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo };
    }
  /**
   * `:code` was updated.
   **/
  | { name: "CodeUpdated" }
  /**
   * A new account was created.
   **/
  | { name: "NewAccount"; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: "KilledAccount"; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: "Remarked"; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | {
      name: "UpgradeAuthorized";
      data: { codeHash: H256; checkVersion: boolean };
    };

export type FrameSupportDispatchDispatchClass =
  | "Normal"
  | "Operational"
  | "Mandatory";

export type FrameSupportDispatchPays = "Yes" | "No";

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  /**
   * New authority set has been applied.
   **/
  | {
      name: "NewAuthorities";
      data: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> };
    }
  /**
   * Current authority set has been paused.
   **/
  | { name: "Paused" }
  /**
   * Current authority set has been resumed.
   **/
  | { name: "Resumed" };

export type SpConsensusGrandpaAppPublic = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: "Endowed"; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: "DustLost"; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | {
      name: "Transfer";
      data: { from: AccountId32; to: AccountId32; amount: bigint };
    }
  /**
   * A balance was set by root.
   **/
  | { name: "BalanceSet"; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: "Reserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: "Unreserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: "ReserveRepatriated";
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: "Deposit"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: "Withdraw"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: "Slashed"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: "Minted"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: "Burned"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: "Suspended"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: "Restored"; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: "Upgraded"; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: "Issued"; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: "Rescinded"; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: "Locked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: "Unlocked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: "Frozen"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: "Thawed"; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: "TotalIssuanceForced"; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = "Free" | "Reserved";

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  {
    name: "TransactionFeePaid";
    data: { who: AccountId32; actualFee: bigint; tip: bigint };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSubtensorEvent =
  /**
   * a new network is added.
   **/
  | { name: "NetworkAdded"; data: [number, number] }
  /**
   * a network is removed.
   **/
  | { name: "NetworkRemoved"; data: number }
  /**
   * stake has been transferred from the a coldkey account onto the hotkey staking account.
   **/
  | {
      name: "StakeAdded";
      data: [AccountId32, AccountId32, bigint, bigint, number, bigint];
    }
  /**
   * stake has been removed from the hotkey staking account onto the coldkey account.
   **/
  | {
      name: "StakeRemoved";
      data: [AccountId32, AccountId32, bigint, bigint, number, bigint];
    }
  /**
   * stake has been transferred from the coldkey account onto the hotkey staking account (at the end of the block)
   **/
  | {
      name: "AggregatedStakeAdded";
      data: [AccountId32, AccountId32, number, bigint];
    }
  /**
   * adding aggregated stake has failed
   **/
  | {
      name: "FailedToAddAggregatedStake";
      data: [AccountId32, AccountId32, number, bigint];
    }
  /**
   * limited stake has been transferred from the coldkey account onto the hotkey staking account (at the end of the block)
   **/
  | {
      name: "AggregatedLimitedStakeAdded";
      data: [AccountId32, AccountId32, number, bigint, bigint, boolean];
    }
  /**
   * adding limited aggregated stake has failed
   **/
  | {
      name: "FailedToAddAggregatedLimitedStake";
      data: [AccountId32, AccountId32, number, bigint, bigint, boolean];
    }
  /**
   * stake has been removed from the hotkey staking account into the coldkey account (at the end of the block).
   **/
  | {
      name: "AggregatedStakeRemoved";
      data: [AccountId32, AccountId32, number, bigint];
    }
  /**
   * removing aggregated stake has failed
   **/
  | {
      name: "FailedToRemoveAggregatedStake";
      data: [AccountId32, AccountId32, number, bigint];
    }
  /**
   * aggregated limited stake has been removed from the hotkey staking account into the coldkey account (at the end of the block).
   **/
  | {
      name: "AggregatedLimitedStakeRemoved";
      data: [AccountId32, AccountId32, number, bigint, bigint, boolean];
    }
  /**
   * removing limited aggregated stake has failed
   **/
  | {
      name: "FailedToRemoveAggregatedLimitedStake";
      data: [AccountId32, AccountId32, number, bigint, bigint, boolean];
    }
  /**
   * aggregated unstake_all operation has succeeded
   **/
  | { name: "AggregatedUnstakeAllSucceeded"; data: [AccountId32, AccountId32] }
  /**
   * aggregated unstake_all operation has failed
   **/
  | { name: "AggregatedUnstakeAllFailed"; data: [AccountId32, AccountId32] }
  /**
   * aggregated unstake_all_alpha operation has succeeded
   **/
  | {
      name: "AggregatedUnstakeAllAlphaSucceeded";
      data: [AccountId32, AccountId32];
    }
  /**
   * aggregated unstake_all_alpha operation has failed
   **/
  | {
      name: "AggregatedUnstakeAllAlphaFailed";
      data: [AccountId32, AccountId32];
    }
  /**
   * stake has been moved from origin (hotkey, subnet ID) to destination (hotkey, subnet ID) of this amount (in TAO).
   **/
  | {
      name: "StakeMoved";
      data: [AccountId32, AccountId32, number, AccountId32, number, bigint];
    }
  /**
   * a caller successfully sets their weights on a subnetwork.
   **/
  | { name: "WeightsSet"; data: [number, number] }
  /**
   * a new neuron account has been registered to the chain.
   **/
  | { name: "NeuronRegistered"; data: [number, number, AccountId32] }
  /**
   * multiple uids have been concurrently registered.
   **/
  | { name: "BulkNeuronsRegistered"; data: [number, number] }
  /**
   * FIXME: Not used yet
   **/
  | { name: "BulkBalancesSet"; data: [number, number] }
  /**
   * max allowed uids has been set for a subnetwork.
   **/
  | { name: "MaxAllowedUidsSet"; data: [number, number] }
  /**
   * the max weight limit has been set for a subnetwork.
   **/
  | { name: "MaxWeightLimitSet"; data: [number, number] }
  /**
   * the difficulty has been set for a subnet.
   **/
  | { name: "DifficultySet"; data: [number, bigint] }
  /**
   * the adjustment interval is set for a subnet.
   **/
  | { name: "AdjustmentIntervalSet"; data: [number, number] }
  /**
   * registration per interval is set for a subnet.
   **/
  | { name: "RegistrationPerIntervalSet"; data: [number, number] }
  /**
   * we set max registrations per block.
   **/
  | { name: "MaxRegistrationsPerBlockSet"; data: [number, number] }
  /**
   * an activity cutoff is set for a subnet.
   **/
  | { name: "ActivityCutoffSet"; data: [number, number] }
  /**
   * Rho value is set.
   **/
  | { name: "RhoSet"; data: [number, number] }
  /**
   * steepness of the sigmoid used to compute alpha values.
   **/
  | { name: "AlphaSigmoidSteepnessSet"; data: [number, number] }
  /**
   * Kappa is set for a subnet.
   **/
  | { name: "KappaSet"; data: [number, number] }
  /**
   * minimum allowed weight is set for a subnet.
   **/
  | { name: "MinAllowedWeightSet"; data: [number, number] }
  /**
   * the validator pruning length has been set.
   **/
  | { name: "ValidatorPruneLenSet"; data: [number, bigint] }
  /**
   * the scaling law power has been set for a subnet.
   **/
  | { name: "ScalingLawPowerSet"; data: [number, number] }
  /**
   * weights set rate limit has been set for a subnet.
   **/
  | { name: "WeightsSetRateLimitSet"; data: [number, bigint] }
  /**
   * immunity period is set for a subnet.
   **/
  | { name: "ImmunityPeriodSet"; data: [number, number] }
  /**
   * bonds moving average is set for a subnet.
   **/
  | { name: "BondsMovingAverageSet"; data: [number, bigint] }
  /**
   * bonds penalty is set for a subnet.
   **/
  | { name: "BondsPenaltySet"; data: [number, number] }
  /**
   * bonds reset is set for a subnet.
   **/
  | { name: "BondsResetOnSet"; data: [number, boolean] }
  /**
   * setting the max number of allowed validators on a subnet.
   **/
  | { name: "MaxAllowedValidatorsSet"; data: [number, number] }
  /**
   * the axon server information is added to the network.
   **/
  | { name: "AxonServed"; data: [number, AccountId32] }
  /**
   * the prometheus server information is added to the network.
   **/
  | { name: "PrometheusServed"; data: [number, AccountId32] }
  /**
   * a hotkey has become a delegate.
   **/
  | { name: "DelegateAdded"; data: [AccountId32, AccountId32, number] }
  /**
   * the default take is set.
   **/
  | { name: "DefaultTakeSet"; data: number }
  /**
   * weights version key is set for a network.
   **/
  | { name: "WeightsVersionKeySet"; data: [number, bigint] }
  /**
   * setting min difficulty on a network.
   **/
  | { name: "MinDifficultySet"; data: [number, bigint] }
  /**
   * setting max difficulty on a network.
   **/
  | { name: "MaxDifficultySet"; data: [number, bigint] }
  /**
   * setting the prometheus serving rate limit.
   **/
  | { name: "ServingRateLimitSet"; data: [number, bigint] }
  /**
   * setting burn on a network.
   **/
  | { name: "BurnSet"; data: [number, bigint] }
  /**
   * setting max burn on a network.
   **/
  | { name: "MaxBurnSet"; data: [number, bigint] }
  /**
   * setting min burn on a network.
   **/
  | { name: "MinBurnSet"; data: [number, bigint] }
  /**
   * setting the transaction rate limit.
   **/
  | { name: "TxRateLimitSet"; data: bigint }
  /**
   * setting the delegate take transaction rate limit.
   **/
  | { name: "TxDelegateTakeRateLimitSet"; data: bigint }
  /**
   * setting the childkey take transaction rate limit.
   **/
  | { name: "TxChildKeyTakeRateLimitSet"; data: bigint }
  /**
   * minimum childkey take set
   **/
  | { name: "MinChildKeyTakeSet"; data: number }
  /**
   * maximum childkey take set
   **/
  | { name: "MaxChildKeyTakeSet"; data: number }
  /**
   * childkey take set
   **/
  | { name: "ChildKeyTakeSet"; data: [AccountId32, number] }
  /**
   * a sudo call is done.
   **/
  | { name: "Sudid"; data: Result<[], DispatchError> }
  /**
   * registration is allowed/disallowed for a subnet.
   **/
  | { name: "RegistrationAllowed"; data: [number, boolean] }
  /**
   * POW registration is allowed/disallowed for a subnet.
   **/
  | { name: "PowRegistrationAllowed"; data: [number, boolean] }
  /**
   * setting tempo on a network
   **/
  | { name: "TempoSet"; data: [number, number] }
  /**
   * setting the RAO recycled for registration.
   **/
  | { name: "RaoRecycledForRegistrationSet"; data: [number, bigint] }
  /**
   * min stake is set for validators to set weights.
   **/
  | { name: "StakeThresholdSet"; data: bigint }
  /**
   * setting the minimum required stake amount for senate registration.
   **/
  | { name: "SenateRequiredStakePercentSet"; data: bigint }
  /**
   * setting the adjustment alpha on a subnet.
   **/
  | { name: "AdjustmentAlphaSet"; data: [number, bigint] }
  /**
   * the faucet it called on the test net.
   **/
  | { name: "Faucet"; data: [AccountId32, bigint] }
  /**
   * the subnet owner cut is set.
   **/
  | { name: "SubnetOwnerCutSet"; data: number }
  /**
   * the network creation rate limit is set.
   **/
  | { name: "NetworkRateLimitSet"; data: bigint }
  /**
   * the network immunity period is set.
   **/
  | { name: "NetworkImmunityPeriodSet"; data: bigint }
  /**
   * the network minimum locking cost is set.
   **/
  | { name: "NetworkMinLockCostSet"; data: bigint }
  /**
   * the maximum number of subnets is set
   * the lock cost reduction is set
   **/
  | { name: "NetworkLockCostReductionIntervalSet"; data: bigint }
  /**
   * the take for a delegate is decreased.
   **/
  | { name: "TakeDecreased"; data: [AccountId32, AccountId32, number] }
  /**
   * the take for a delegate is increased.
   **/
  | { name: "TakeIncreased"; data: [AccountId32, AccountId32, number] }
  /**
   * the hotkey is swapped
   **/
  | {
      name: "HotkeySwapped";
      data: {
        /**
         * the account ID of coldkey
         **/
        coldkey: AccountId32;

        /**
         * the account ID of old hotkey
         **/
        oldHotkey: AccountId32;

        /**
         * the account ID of new hotkey
         **/
        newHotkey: AccountId32;
      };
    }
  /**
   * maximum delegate take is set by sudo/admin transaction
   **/
  | { name: "MaxDelegateTakeSet"; data: number }
  /**
   * minimum delegate take is set by sudo/admin transaction
   **/
  | { name: "MinDelegateTakeSet"; data: number }
  /**
   * a member of the senate is adjusted
   **/
  | {
      name: "SenateAdjusted";
      data: {
        /**
         * the account ID of the old senate member, if any
         **/
        oldMember?: AccountId32 | undefined;

        /**
         * the account ID of the new senate member
         **/
        newMember: AccountId32;
      };
    }
  /**
   * A coldkey has been swapped
   **/
  | {
      name: "ColdkeySwapped";
      data: {
        /**
         * the account ID of old coldkey
         **/
        oldColdkey: AccountId32;

        /**
         * the account ID of new coldkey
         **/
        newColdkey: AccountId32;

        /**
         * the swap cost
         **/
        swapCost: bigint;
      };
    }
  /**
   * All balance of a hotkey has been unstaked and transferred to a new coldkey
   **/
  | {
      name: "AllBalanceUnstakedAndTransferredToNewColdkey";
      data: {
        /**
         * The account ID of the current coldkey
         **/
        currentColdkey: AccountId32;

        /**
         * The account ID of the new coldkey
         **/
        newColdkey: AccountId32;

        /**
         * The total balance of the hotkey
         **/
        totalBalance: bigint;
      };
    }
  /**
   * A coldkey swap has been scheduled
   **/
  | {
      name: "ColdkeySwapScheduled";
      data: {
        /**
         * The account ID of the old coldkey
         **/
        oldColdkey: AccountId32;

        /**
         * The account ID of the new coldkey
         **/
        newColdkey: AccountId32;

        /**
         * The arbitration block for the coldkey swap
         **/
        executionBlock: number;

        /**
         * The swap cost
         **/
        swapCost: bigint;
      };
    }
  /**
   * The arbitration period has been extended
   **/
  | {
      name: "ArbitrationPeriodExtended";
      data: {
        /**
         * The account ID of the coldkey
         **/
        coldkey: AccountId32;
      };
    }
  /**
   * Setting of children of a hotkey have been scheduled
   **/
  | {
      name: "SetChildrenScheduled";
      data: [AccountId32, number, bigint, Array<[bigint, AccountId32]>];
    }
  /**
   * The children of a hotkey have been set
   **/
  | {
      name: "SetChildren";
      data: [AccountId32, number, Array<[bigint, AccountId32]>];
    }
  /**
   * The identity of a coldkey has been set
   **/
  | { name: "ChainIdentitySet"; data: AccountId32 }
  /**
   * The identity of a subnet has been set
   **/
  | { name: "SubnetIdentitySet"; data: number }
  /**
   * The identity of a subnet has been removed
   **/
  | { name: "SubnetIdentityRemoved"; data: number }
  /**
   * A dissolve network extrinsic scheduled.
   **/
  | {
      name: "DissolveNetworkScheduled";
      data: {
        /**
         * The account ID schedule the dissolve network extrisnic
         **/
        account: AccountId32;

        /**
         * network ID will be dissolved
         **/
        netuid: number;

        /**
         * extrinsic execution block number
         **/
        executionBlock: number;
      };
    }
  /**
   * The duration of schedule coldkey swap has been set
   **/
  | { name: "ColdkeySwapScheduleDurationSet"; data: number }
  /**
   * The duration of dissolve network has been set
   **/
  | { name: "DissolveNetworkScheduleDurationSet"; data: number }
  /**
   * Commit-reveal v3 weights have been successfully committed.
   *
   * - **who**: The account ID of the user committing the weights.
   * - **netuid**: The network identifier.
   * - **commit_hash**: The hash representing the committed weights.
   **/
  | { name: "Crv3WeightsCommitted"; data: [AccountId32, number, H256] }
  /**
   * Weights have been successfully committed.
   *
   * - **who**: The account ID of the user committing the weights.
   * - **netuid**: The network identifier.
   * - **commit_hash**: The hash representing the committed weights.
   **/
  | { name: "WeightsCommitted"; data: [AccountId32, number, H256] }
  /**
   * Weights have been successfully revealed.
   *
   * - **who**: The account ID of the user revealing the weights.
   * - **netuid**: The network identifier.
   * - **commit_hash**: The hash of the revealed weights.
   **/
  | { name: "WeightsRevealed"; data: [AccountId32, number, H256] }
  /**
   * Weights have been successfully batch revealed.
   *
   * - **who**: The account ID of the user revealing the weights.
   * - **netuid**: The network identifier.
   * - **revealed_hashes**: A vector of hashes representing each revealed weight set.
   **/
  | { name: "WeightsBatchRevealed"; data: [AccountId32, number, Array<H256>] }
  /**
   * A batch of weights (or commits) have been force-set.
   *
   * - **netuids**: The netuids these weights were successfully set/committed for.
   * - **who**: The hotkey that set this batch.
   **/
  | { name: "BatchWeightsCompleted"; data: [Array<number>, AccountId32] }
  /**
   * A batch extrinsic completed but with some errors.
   **/
  | { name: "BatchCompletedWithErrors" }
  /**
   * A weight set among a batch of weights failed.
   *
   * - **error**: The dispatch error emitted by the failed item.
   **/
  | { name: "BatchWeightItemFailed"; data: DispatchError }
  /**
   * Stake has been transferred from one coldkey to another on the same subnet.
   * Parameters:
   * (origin_coldkey, destination_coldkey, hotkey, origin_netuid, destination_netuid, amount)
   **/
  | {
      name: "StakeTransferred";
      data: [AccountId32, AccountId32, AccountId32, number, number, bigint];
    }
  /**
   * Stake has been swapped from one subnet to another for the same coldkey-hotkey pair.
   *
   * Parameters:
   * (coldkey, hotkey, origin_netuid, destination_netuid, amount)
   **/
  | {
      name: "StakeSwapped";
      data: [AccountId32, AccountId32, number, number, bigint];
    }
  /**
   * Event called when transfer is toggled on a subnet.
   *
   * Parameters:
   * (netuid, bool)
   **/
  | { name: "TransferToggle"; data: [number, boolean] }
  /**
   * The owner hotkey for a subnet has been set.
   *
   * Parameters:
   * (netuid, new_hotkey)
   **/
  | { name: "SubnetOwnerHotkeySet"; data: [number, AccountId32] }
  /**
   * FirstEmissionBlockNumber is set via start call extrinsic
   *
   * Parameters:
   * netuid
   * block number
   **/
  | { name: "FirstEmissionBlockNumberSet"; data: [number, bigint] }
  /**
   * Alpha has been recycled, reducing AlphaOut on a subnet.
   *
   * Parameters:
   * (coldkey, hotkey, amount, subnet_id)
   **/
  | { name: "AlphaRecycled"; data: [AccountId32, AccountId32, bigint, number] }
  /**
   * Alpha have been burned without reducing AlphaOut.
   *
   * Parameters:
   * (coldkey, hotkey, amount, subnet_id)
   **/
  | { name: "AlphaBurned"; data: [AccountId32, AccountId32, bigint, number] }
  /**
   * An EVM key has been associated with a hotkey.
   **/
  | {
      name: "EvmKeyAssociated";
      data: {
        /**
         * The subnet that the hotkey belongs to.
         **/
        netuid: number;

        /**
         * The hotkey associated with the EVM key.
         **/
        hotkey: AccountId32;

        /**
         * The EVM key being associated with the hotkey.
         **/
        evmKey: H160;

        /**
         * The block where the association happened.
         **/
        blockAssociated: bigint;
      };
    }
  /**
   * CRV3 Weights have been successfully revealed.
   *
   * - **netuid**: The network identifier.
   * - **who**: The account ID of the user revealing the weights.
   **/
  | { name: "Crv3WeightsRevealed"; data: [number, AccountId32] }
  /**
   * Commit-Reveal periods has been successfully set.
   *
   * - **netuid**: The network identifier.
   * - **periods**: The number of epochs before the reveal.
   **/
  | { name: "CommitRevealPeriodsSet"; data: [number, bigint] }
  /**
   * Commit-Reveal has been successfully toggled.
   *
   * - **netuid**: The network identifier.
   * - **Enabled**: Is Commit-Reveal enabled.
   **/
  | { name: "CommitRevealEnabled"; data: [number, boolean] }
  /**
   * the hotkey is swapped
   **/
  | {
      name: "HotkeySwappedOnSubnet";
      data: {
        /**
         * the account ID of coldkey
         **/
        coldkey: AccountId32;

        /**
         * the account ID of old hotkey
         **/
        oldHotkey: AccountId32;

        /**
         * the account ID of new hotkey
         **/
        newHotkey: AccountId32;

        /**
         * the subnet ID
         **/
        netuid: number;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | {
      name: "Proposed";
      data: {
        /**
         * The account that proposed the motion.
         **/
        account: AccountId32;

        /**
         * The index of the proposal.
         **/
        proposalIndex: number;

        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;

        /**
         * The threshold of member for the proposal.
         **/
        threshold: number;
      };
    }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | {
      name: "Voted";
      data: {
        /**
         * The account that voted.
         **/
        account: AccountId32;

        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;

        /**
         * Whether the account voted aye.
         **/
        voted: boolean;

        /**
         * The number of yes votes.
         **/
        yes: number;

        /**
         * The number of no votes.
         **/
        no: number;
      };
    }
  /**
   * A motion was approved by the required threshold.
   **/
  | {
      name: "Approved";
      data: {
        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;
      };
    }
  /**
   * A motion was not approved by the required threshold.
   **/
  | {
      name: "Disapproved";
      data: {
        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;
      };
    }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | {
      name: "Executed";
      data: {
        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;

        /**
         * The result of the execution.
         **/
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | {
      name: "MemberExecuted";
      data: {
        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;

        /**
         * The result of the execution.
         **/
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | {
      name: "Closed";
      data: {
        /**
         * The hash of the proposal.
         **/
        proposalHash: H256;

        /**
         * Whether the proposal was approved.
         **/
        yes: number;

        /**
         * Whether the proposal was rejected.
         **/
        no: number;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | "MemberAdded"
  /**
   * The given member was removed; see the transaction for who.
   **/
  | "MemberRemoved"
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | "MembersSwapped"
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | "MembersReset"
  /**
   * One of the members' keys changed.
   **/
  | "KeyChanged"
  /**
   * Phantom member, never used.
   **/
  | "Dummy";

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: "BatchInterrupted"; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: "BatchCompleted" }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: "BatchCompletedWithErrors" }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: "ItemCompleted" }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: "ItemFailed"; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: "DispatchedAs"; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  /**
   * A sudo call just took place.
   **/
  | {
      name: "Sudid";
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    }
  /**
   * The sudo key has been updated.
   **/
  | {
      name: "KeyChanged";
      data: {
        /**
         * The old sudo key (if one was previously set).
         **/
        old?: AccountId32 | undefined;

        /**
         * The new sudo key (if one was set).
         **/
        new: AccountId32;
      };
    }
  /**
   * The key was permanently removed.
   **/
  | { name: "KeyRemoved" }
  /**
   * A [sudo_as](Pallet::sudo_as) call just took place.
   **/
  | {
      name: "SudoAsDone";
      data: {
        /**
         * The result of the call made by the sudo user.
         **/
        sudoResult: Result<[], DispatchError>;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | {
      name: "NewMultisig";
      data: {
        approving: AccountId32;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: "MultisigApproval";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: "MultisigExecuted";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: "MultisigCancelled";
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: "Noted"; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: "Requested"; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: "Cleared"; data: { hash: H256 } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: "Scheduled"; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: "Canceled"; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: "Dispatched";
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: "RetrySet";
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        period: number;
        retries: number;
      };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | {
      name: "RetryCancelled";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | {
      name: "CallUnavailable";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | {
      name: "PeriodicFailed";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | {
      name: "RetryFailed";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | {
      name: "PermanentlyOverweight";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: "ProxyExecuted"; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: "PureCreated";
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: SubtensorRuntimeCommonProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | {
      name: "Announced";
      data: { real: AccountId32; proxy: AccountId32; callHash: H256 };
    }
  /**
   * A proxy was added.
   **/
  | {
      name: "ProxyAdded";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: "ProxyRemoved";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    };

export type SubtensorRuntimeCommonProxyType =
  | "Any"
  | "Owner"
  | "NonCritical"
  | "NonTransfer"
  | "Senate"
  | "NonFungibile"
  | "Triumvirate"
  | "Governance"
  | "Staking"
  | "Registration"
  | "Transfer"
  | "SmallTransfer"
  | "RootWeights"
  | "ChildKeys"
  | "SudoUncheckedSetCode"
  | "SwapHotkey";

/**
 * The `Event` enum of this pallet
 **/
export type PalletRegistryEvent =
  /**
   * Emitted when a user registers an identity
   **/
  | {
      name: "IdentitySet";
      data: {
        /**
         * The account that registered the identity
         **/
        who: AccountId32;
      };
    }
  /**
   * Emitted when a user dissolves an identity
   **/
  | {
      name: "IdentityDissolved";
      data: {
        /**
         * The account that dissolved the identity
         **/
        who: AccountId32;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCommitmentsEvent =
  /**
   * A commitment was set
   **/
  | {
      name: "Commitment";
      data: {
        /**
         * The netuid of the commitment
         **/
        netuid: number;

        /**
         * The account
         **/
        who: AccountId32;
      };
    }
  /**
   * A timelock-encrypted commitment was set
   **/
  | {
      name: "TimelockCommitment";
      data: {
        /**
         * The netuid of the commitment
         **/
        netuid: number;

        /**
         * The account
         **/
        who: AccountId32;

        /**
         * The drand round to reveal
         **/
        revealRound: bigint;
      };
    }
  /**
   * A timelock-encrypted commitment was auto-revealed
   **/
  | {
      name: "CommitmentRevealed";
      data: {
        /**
         * The netuid of the commitment
         **/
        netuid: number;

        /**
         * The account
         **/
        who: AccountId32;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAdminUtilsEvent =
  /**
   * Event emitted when a precompile operation is updated.
   **/
  | {
      name: "PrecompileUpdated";
      data: {
        /**
         * The type of precompile operation being updated.
         **/
        precompileId: PalletAdminUtilsPrecompileEnum;

        /**
         * Indicates if the precompile operation is enabled or not.
         **/
        enabled: boolean;
      };
    }
  /**
   * Event emitted when the Yuma3 enable is toggled.
   **/
  | {
      name: "Yuma3EnableToggled";
      data: {
        /**
         * The network identifier.
         **/
        netuid: number;

        /**
         * Indicates if the Yuma3 enable was enabled or disabled.
         **/
        enabled: boolean;
      };
    };

export type PalletAdminUtilsPrecompileEnum =
  | "BalanceTransfer"
  | "Staking"
  | "Subnet"
  | "Metagraph"
  | "Neuron"
  | "UidLookup";

/**
 * The `Event` enum of this pallet
 **/
export type PalletSafeModeEvent =
  /**
   * The safe-mode was entered until inclusively this block.
   **/
  | { name: "Entered"; data: { until: number } }
  /**
   * The safe-mode was extended until inclusively this block.
   **/
  | { name: "Extended"; data: { until: number } }
  /**
   * Exited the safe-mode for a specific reason.
   **/
  | { name: "Exited"; data: { reason: PalletSafeModeExitReason } }
  /**
   * An account reserved funds for either entering or extending the safe-mode.
   **/
  | { name: "DepositPlaced"; data: { account: AccountId32; amount: bigint } }
  /**
   * An account had a reserve released that was reserved.
   **/
  | { name: "DepositReleased"; data: { account: AccountId32; amount: bigint } }
  /**
   * An account had reserve slashed that was reserved.
   **/
  | { name: "DepositSlashed"; data: { account: AccountId32; amount: bigint } }
  /**
   * Could not hold funds for entering or extending the safe-mode.
   *
   * This error comes from the underlying `Currency`.
   **/
  | { name: "CannotDeposit" }
  /**
   * Could not release funds for entering or extending the safe-mode.
   *
   * This error comes from the underlying `Currency`.
   **/
  | { name: "CannotRelease" };

export type PalletSafeModeExitReason = "Timeout" | "Force";

/**
 * The `Event` enum of this pallet
 **/
export type PalletEthereumEvent =
  /**
   * An ethereum transaction was successfully executed.
   **/
  {
    name: "Executed";
    data: {
      from: H160;
      to: H160;
      transactionHash: H256;
      exitReason: EvmCoreErrorExitReason;
      extraData: Bytes;
    };
  };

export type EvmCoreErrorExitReason =
  | { type: "Succeed"; value: EvmCoreErrorExitSucceed }
  | { type: "Error"; value: EvmCoreErrorExitError }
  | { type: "Revert"; value: EvmCoreErrorExitRevert }
  | { type: "Fatal"; value: EvmCoreErrorExitFatal };

export type EvmCoreErrorExitSucceed = "Stopped" | "Returned" | "Suicided";

export type EvmCoreErrorExitError =
  | { type: "StackUnderflow" }
  | { type: "StackOverflow" }
  | { type: "InvalidJump" }
  | { type: "InvalidRange" }
  | { type: "DesignatedInvalid" }
  | { type: "CallTooDeep" }
  | { type: "CreateCollision" }
  | { type: "CreateContractLimit" }
  | { type: "InvalidCode"; value: EvmCoreOpcode }
  | { type: "OutOfOffset" }
  | { type: "OutOfGas" }
  | { type: "OutOfFund" }
  | { type: "PcUnderflow" }
  | { type: "CreateEmpty" }
  | { type: "Other"; value: string }
  | { type: "MaxNonce" };

export type EvmCoreOpcode = number;

export type EvmCoreErrorExitRevert = "Reverted";

export type EvmCoreErrorExitFatal =
  | { type: "NotSupported" }
  | { type: "UnhandledInterrupt" }
  | { type: "CallErrorAsFatal"; value: EvmCoreErrorExitError }
  | { type: "Other"; value: string };

/**
 * The `Event` enum of this pallet
 **/
export type PalletEvmEvent =
  /**
   * Ethereum events from contracts.
   **/
  | { name: "Log"; data: { log: EthereumLog } }
  /**
   * A contract has been created at given address.
   **/
  | { name: "Created"; data: { address: H160 } }
  /**
   * A contract was attempted to be created, but the execution failed.
   **/
  | { name: "CreatedFailed"; data: { address: H160 } }
  /**
   * A contract has been executed successfully with states applied.
   **/
  | { name: "Executed"; data: { address: H160 } }
  /**
   * A contract has been executed with errors. States are reverted with only gas fees applied.
   **/
  | { name: "ExecutedFailed"; data: { address: H160 } };

export type EthereumLog = { address: H160; topics: Array<H256>; data: Bytes };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBaseFeeEvent =
  | { name: "NewBaseFeePerGas"; data: { fee: U256 } }
  | { name: "BaseFeeOverflow" }
  | { name: "NewElasticity"; data: { elasticity: Permill } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDrandEvent =
  | { name: "BeaconConfigChanged" }
  /**
   * Successfully set a new pulse(s).
   **/
  | { name: "NewPulse"; data: { rounds: Array<bigint> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCrowdloanEvent =
  /**
   * A crowdloan was created.
   **/
  | {
      name: "Created";
      data: {
        crowdloanId: number;
        creator: AccountId32;
        end: number;
        cap: bigint;
      };
    }
  /**
   * A contribution was made to an active crowdloan.
   **/
  | {
      name: "Contributed";
      data: { crowdloanId: number; contributor: AccountId32; amount: bigint };
    }
  /**
   * A contribution was withdrawn from a failed crowdloan.
   **/
  | {
      name: "Withdrew";
      data: { crowdloanId: number; contributor: AccountId32; amount: bigint };
    }
  /**
   * A refund was partially processed for a failed crowdloan.
   **/
  | { name: "PartiallyRefunded"; data: { crowdloanId: number } }
  /**
   * A refund was fully processed for a failed crowdloan.
   **/
  | { name: "AllRefunded"; data: { crowdloanId: number } }
  /**
   * A crowdloan was finalized, funds were transferred and the call was dispatched.
   **/
  | { name: "Finalized"; data: { crowdloanId: number } }
  /**
   * A crowdloan was dissolved.
   **/
  | { name: "Dissolved"; data: { crowdloanId: number } }
  /**
   * The minimum contribution was updated.
   **/
  | {
      name: "MinContributionUpdated";
      data: { crowdloanId: number; newMinContribution: bigint };
    }
  /**
   * The end was updated.
   **/
  | { name: "EndUpdated"; data: { crowdloanId: number; newEnd: number } }
  /**
   * The cap was updated.
   **/
  | { name: "CapUpdated"; data: { crowdloanId: number; newCap: bigint } };

export type FrameSystemLastRuntimeUpgradeInfo = {
  specVersion: number;
  specName: string;
};

export type FrameSystemCodeUpgradeAuthorization = {
  codeHash: H256;
  checkVersion: boolean;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: "Remark"; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: "SetCode"; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: "SetStorage"; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: "KillStorage"; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: "KillPrefix"; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: "RemarkWithEvent"; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: "Remark"; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: "SetCode"; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: "SetStorage"; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: "KillStorage"; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: "KillPrefix"; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: "RemarkWithEvent"; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = {
  max: FrameSupportDispatchPerDispatchClassU32;
};

export type FrameSupportDispatchPerDispatchClassU32 = {
  normal: number;
  operational: number;
  mandatory: number;
};

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | "InvalidSpecName"
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | "SpecVersionNeedsToIncrease"
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | "FailedToExtractRuntimeVersion"
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | "NonDefaultComposite"
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | "NonZeroRefCount"
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | "CallFiltered"
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | "MultiBlockMigrationsOngoing"
  /**
   * No upgrade authorized.
   **/
  | "NothingAuthorized"
  /**
   * The submitted code is not authorized.
   **/
  | "Unauthorized";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: "Set"; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: "Set"; params: { now: bigint } };

export type SpConsensusAuraSr25519AppSr25519Public = FixedBytes<32>;

export type SpConsensusSlotsSlot = bigint;

export type PalletGrandpaStoredState =
  | { type: "Live" }
  | { type: "PendingPause"; value: { scheduledAt: number; delay: number } }
  | { type: "Paused" }
  | { type: "PendingResume"; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpCoreVoid;
      };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpCoreVoid;
      };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | {
      name: "NoteStalled";
      params: { delay: number; bestFinalizedBlockNumber: number };
    };

export type PalletGrandpaCallLike =
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   **/
  | {
      name: "ReportEquivocation";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpCoreVoid;
      };
    }
  /**
   * Report voter equivocation/misbehavior. This method will verify the
   * equivocation proof and validate the given key ownership proof
   * against the extracted offender. If both are valid, the offence
   * will be reported.
   *
   * This extrinsic must be called unsigned and it is expected that only
   * block authors will call it (validated in `ValidateUnsigned`), as such
   * if the block author is defined it will be defined as the equivocation
   * reporter.
   **/
  | {
      name: "ReportEquivocationUnsigned";
      params: {
        equivocationProof: SpConsensusGrandpaEquivocationProof;
        keyOwnerProof: SpCoreVoid;
      };
    }
  /**
   * Note that the current authority set of the GRANDPA finality gadget has stalled.
   *
   * This will trigger a forced authority set change at the beginning of the next session, to
   * be enacted `delay` blocks after that. The `delay` should be high enough to safely assume
   * that the block signalling the forced change will not be re-orged e.g. 1000 blocks.
   * The block production rate (which may be slowed down because of finality lagging) should
   * be taken into account when choosing the `delay`. The GRANDPA voters based on the new
   * authority will start voting on top of `best_finalized_block_number` for new finalized
   * blocks. `best_finalized_block_number` should be the highest of the latest finalized
   * block of all validators of the new authority set.
   *
   * Only callable by root.
   **/
  | {
      name: "NoteStalled";
      params: { delay: number; bestFinalizedBlockNumber: number };
    };

export type SpConsensusGrandpaEquivocationProof = {
  setId: bigint;
  equivocation: SpConsensusGrandpaEquivocation;
};

export type SpConsensusGrandpaEquivocation =
  | { type: "Prevote"; value: FinalityGrandpaEquivocation }
  | { type: "Precommit"; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = {
  targetHash: H256;
  targetNumber: number;
};

export type SpCoreVoid = null;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | "PauseFailed"
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | "ResumeFailed"
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | "ChangePending"
  /**
   * Cannot signal forced change so soon after last.
   **/
  | "TooSoon"
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidKeyOwnershipProof"
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | "InvalidEquivocationProof"
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | "DuplicateOffenceReport";

export type PalletBalancesBalanceLock = {
  id: FixedBytes<8>;
  amount: bigint;
  reasons: PalletBalancesReasons;
};

export type PalletBalancesReasons = "Fee" | "Misc" | "All";

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type FrameSupportTokensMiscIdAmount = {
  id: NodeSubtensorRuntimeRuntimeHoldReason;
  amount: bigint;
};

export type NodeSubtensorRuntimeRuntimeHoldReason =
  | { type: "Preimage"; value: PalletPreimageHoldReason }
  | { type: "Registry"; value: PalletRegistryHoldReason }
  | { type: "SafeMode"; value: PalletSafeModeHoldReason };

export type PalletPreimageHoldReason = "Preimage";

export type PalletRegistryHoldReason = "RegistryIdentity";

export type PalletSafeModeHoldReason = "EnterOrExtend";

export type FrameSupportTokensMiscIdAmountRuntimeFreezeReason = {
  id: NodeSubtensorRuntimeRuntimeFreezeReason;
  amount: bigint;
};

export type NodeSubtensorRuntimeRuntimeFreezeReason = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddress; value: bigint };
    }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | {
      name: "ForceTransfer";
      params: { source: MultiAddress; dest: MultiAddress; value: bigint };
    }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: "TransferKeepAlive"; params: { dest: MultiAddress; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: "TransferAll"; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: "ForceUnreserve"; params: { who: MultiAddress; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: "ForceSetBalance"; params: { who: MultiAddress; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: "Burn"; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | {
      name: "ForceTransfer";
      params: {
        source: MultiAddressLike;
        dest: MultiAddressLike;
        value: bigint;
      };
    }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | {
      name: "TransferKeepAlive";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | {
      name: "TransferAll";
      params: { dest: MultiAddressLike; keepAlive: boolean };
    }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | {
      name: "ForceUnreserve";
      params: { who: MultiAddressLike; amount: bigint };
    }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | {
      name: "ForceSetBalance";
      params: { who: MultiAddressLike; newFree: bigint };
    }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: "Burn"; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesAdjustmentDirection = "Increase" | "Decrease";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | "VestingBalance"
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | "LiquidityRestrictions"
  /**
   * Balance too low to send value.
   **/
  | "InsufficientBalance"
  /**
   * Value too low to create account due to existential deposit.
   **/
  | "ExistentialDeposit"
  /**
   * Transfer/payment would kill account.
   **/
  | "Expendability"
  /**
   * A vesting schedule already exists for this account.
   **/
  | "ExistingVestingSchedule"
  /**
   * Beneficiary account must pre-exist.
   **/
  | "DeadAccount"
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | "TooManyReserves"
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | "TooManyHolds"
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | "TooManyFreezes"
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | "IssuanceDeactivated"
  /**
   * The delta cannot be zero.
   **/
  | "DeltaZero";

export type PalletTransactionPaymentReleases = "V1Ancient" | "V2";

export type PalletSubtensorStakeJob =
  | {
      type: "AddStake";
      value: {
        hotkey: AccountId32;
        coldkey: AccountId32;
        netuid: number;
        stakeToBeAdded: bigint;
      };
    }
  | {
      type: "RemoveStake";
      value: {
        hotkey: AccountId32;
        coldkey: AccountId32;
        netuid: number;
        alphaUnstaked: bigint;
      };
    }
  | {
      type: "AddStakeLimit";
      value: {
        coldkey: AccountId32;
        hotkey: AccountId32;
        netuid: number;
        stakeToBeAdded: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  | {
      type: "RemoveStakeLimit";
      value: {
        coldkey: AccountId32;
        hotkey: AccountId32;
        netuid: number;
        alphaUnstaked: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  | { type: "UnstakeAll"; value: { coldkey: AccountId32; hotkey: AccountId32 } }
  | {
      type: "UnstakeAllAlpha";
      value: { coldkey: AccountId32; hotkey: AccountId32 };
    };

export type SubstrateFixedFixedI128 = { bits: bigint };

export type TypenumUintUInt = { msb: TypenumUintUIntUInt; lsb: TypenumBitB0 };

export type TypenumUintUIntUInt = {
  msb: TypenumUintUIntUInt;
  lsb: TypenumBitB0;
};

export type TypenumUintUIntUInt = {
  msb: TypenumUintUIntUInt;
  lsb: TypenumBitB0;
};

export type TypenumUintUIntUInt = {
  msb: TypenumUintUIntUInt;
  lsb: TypenumBitB0;
};

export type TypenumUintUIntUInt = {
  msb: TypenumUintUIntUTerm;
  lsb: TypenumBitB0;
};

export type TypenumUintUIntUTerm = { msb: TypenumUintUTerm; lsb: TypenumBitB1 };

export type TypenumUintUTerm = {};

export type TypenumBitB1 = {};

export type TypenumBitB0 = {};

export type SubstrateFixedFixedU128 = { bits: bigint };

export type TypenumUintUIntUInt = { msb: TypenumUintUInt; lsb: TypenumBitB0 };

export type PalletSubtensorRateLimitKey = {
  type: "SetSNOwnerHotkey";
  value: number;
};

export type PalletSubtensorAxonInfo = {
  block: bigint;
  version: number;
  ip: bigint;
  port: number;
  ipType: number;
  protocol: number;
  placeholder1: number;
  placeholder2: number;
};

export type PalletSubtensorNeuronCertificate = {
  publicKey: Bytes;
  algorithm: number;
};

export type PalletSubtensorPrometheusInfo = {
  block: bigint;
  version: number;
  ip: bigint;
  port: number;
  ipType: number;
};

export type PalletSubtensorChainIdentity = {
  name: Bytes;
  url: Bytes;
  image: Bytes;
  discord: Bytes;
  description: Bytes;
  additional: Bytes;
};

export type PalletSubtensorChainIdentityV2 = {
  name: Bytes;
  url: Bytes;
  githubRepo: Bytes;
  image: Bytes;
  discord: Bytes;
  description: Bytes;
  additional: Bytes;
};

export type PalletSubtensorSubnetIdentity = {
  subnetName: Bytes;
  githubRepo: Bytes;
  subnetContact: Bytes;
};

export type PalletSubtensorSubnetIdentityV2 = {
  subnetName: Bytes;
  githubRepo: Bytes;
  subnetContact: Bytes;
  subnetUrl: Bytes;
  discord: Bytes;
  description: Bytes;
  additional: Bytes;
};

/**
 * Dispatchable functions allow users to interact with the pallet and invoke state changes.
 * These functions materialize as "extrinsics", which are often compared to transactions.
 * Dispatchable functions must be annotated with a weight and must return a DispatchResult.
 **/
export type PalletSubtensorCall =
  /**
   * --- Sets the caller weights for the incentive mechanism. The call can be
   * made from the hotkey account so is potentially insecure, however, the damage
   * of changing weights is minimal if caught early. This function includes all the
   * checks that the passed weights meet the requirements. Stored as u16s they represent
   * rational values in the range [0,1] which sum to 1 and can be interpreted as
   * probabilities. The specific weights determine how inflation propagates outward
   * from this peer.
   *
   * Note: The 16 bit integers weights should represent 1.0 as the max u16.
   * However, the function normalizes all integers to u16_max anyway. This means that if the sum of all
   * elements is larger or smaller than the amount of elements * u16_max, all elements
   * will be corrected for this deviation.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuid` (u16):
   * - The network uid we are setting these weights on.
   *
   * * `dests` (Vec<u16>):
   * - The edge endpoint for the weight, i.e. j for w_ij.
   *
   * * 'weights' (Vec<u16>):
   * - The u16 integer encoded weights. Interpreted as rational
   * values in the range [0,1]. They must sum to in32::MAX.
   *
   * * 'version_key' ( u64 ):
   * - The network version key to check if the validator is up to date.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'WeightVecNotEqualSize':
   * - Attempting to set weights with uids not of same length.
   *
   * * 'DuplicateUids':
   * - Attempting to set weights with duplicate uids.
   *
   * * 'UidsLengthExceedUidsInSubNet':
   * - Attempting to set weights above the max allowed uids.
   *
   * * 'UidVecContainInvalidOne':
   * - Attempting to set weights with invalid uids.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'MaxWeightExceeded':
   * - Attempting to set weights with max value exceeding limit.
   **/
  | {
      name: "SetWeights";
      params: {
        netuid: number;
        dests: Array<number>;
        weights: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * --- Allows a hotkey to set weights for multiple netuids as a batch.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuids` (Vec<Compact<u16>>):
   * - The network uids we are setting these weights on.
   *
   * * `weights` (Vec<Vec<(Compact<u16>, Compact<u16>)>):
   * - The weights to set for each network. [(uid, weight), ...]
   *
   * * `version_keys` (Vec<Compact<u64>>):
   * - The network version keys to check if the validator is up to date.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   * * BatchWeightsCompleted;
   * - On success of the batch.
   * * BatchCompletedWithErrors;
   * - On failure of any of the weights in the batch.
   * * BatchWeightItemFailed;
   * - On failure for each failed item in the batch.
   *
   **/
  | {
      name: "BatchSetWeights";
      params: {
        netuids: Array<number>;
        weights: Array<Array<[number, number]>>;
        versionKeys: Array<bigint>;
      };
    }
  /**
   * ---- Used to commit a hash of your weight values to later be revealed.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the committing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `commit_hash` (`H256`):
   * - The hash representing the committed weights.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to commit when the commit-reveal mechanism is disabled.
   *
   * * `TooManyUnrevealedCommits`:
   * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
   *
   **/
  | { name: "CommitWeights"; params: { netuid: number; commitHash: H256 } }
  /**
   * --- Allows a hotkey to commit weight hashes for multiple netuids as a batch.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuids` (Vec<Compact<u16>>):
   * - The network uids we are setting these weights on.
   *
   * * `commit_hashes` (Vec<H256>):
   * - The commit hashes to commit.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   * * BatchWeightsCompleted;
   * - On success of the batch.
   * * BatchCompletedWithErrors;
   * - On failure of any of the weights in the batch.
   * * BatchWeightItemFailed;
   * - On failure for each failed item in the batch.
   *
   **/
  | {
      name: "BatchCommitWeights";
      params: { netuids: Array<number>; commitHashes: Array<H256> };
    }
  /**
   * ---- Used to reveal the weights for a previously committed hash.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the revealing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `uids` (`Vec<u16>`):
   * - The uids for the weights being revealed.
   *
   * * `values` (`Vec<u16>`):
   * - The values of the weights being revealed.
   *
   * * `salt` (`Vec<u16>`):
   * - The salt used to generate the commit hash.
   *
   * * `version_key` (`u64`):
   * - The network version key.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
   *
   * * `NoWeightsCommitFound`:
   * - Attempting to reveal weights without an existing commit.
   *
   * * `ExpiredWeightCommit`:
   * - Attempting to reveal a weight commit that has expired.
   *
   * * `RevealTooEarly`:
   * - Attempting to reveal weights outside the valid reveal period.
   *
   * * `InvalidRevealCommitHashNotMatch`:
   * - The revealed hash does not match any committed hash.
   *
   **/
  | {
      name: "RevealWeights";
      params: {
        netuid: number;
        uids: Array<number>;
        values: Array<number>;
        salt: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * ---- Used to commit encrypted commit-reveal v3 weight values to later be revealed.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The committing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `commit` (`Vec<u8>`):
   * - The encrypted compressed commit.
   * The steps for this are:
   * 1. Instantiate [`WeightsTlockPayload`]
   * 2. Serialize it using the `parity_scale_codec::Encode` trait
   * 3. Encrypt it following the steps (here)[https://github.com/ideal-lab5/tle/blob/f8e6019f0fb02c380ebfa6b30efb61786dede07b/timelock/src/tlock.rs#L283-L336]
   * to produce a [`TLECiphertext<TinyBLS381>`] type.
   * 4. Serialize and compress using the `ark-serialize` `CanonicalSerialize` trait.
   *
   * * reveal_round (`u64`):
   * - The drand reveal round which will be avaliable during epoch `n+1` from the current
   * epoch.
   *
   * # Raises:
   * * `CommitRevealV3Disabled`:
   * - Attempting to commit when the commit-reveal mechanism is disabled.
   *
   * * `TooManyUnrevealedCommits`:
   * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
   *
   **/
  | {
      name: "CommitCrv3Weights";
      params: { netuid: number; commit: Bytes; revealRound: bigint };
    }
  /**
   * ---- The implementation for batch revealing committed weights.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the revealing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `uids_list` (`Vec<Vec<u16>>`):
   * - A list of uids for each set of weights being revealed.
   *
   * * `values_list` (`Vec<Vec<u16>>`):
   * - A list of values for each set of weights being revealed.
   *
   * * `salts_list` (`Vec<Vec<u16>>`):
   * - A list of salts used to generate the commit hashes.
   *
   * * `version_keys` (`Vec<u64>`):
   * - A list of network version keys.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
   *
   * * `NoWeightsCommitFound`:
   * - Attempting to reveal weights without an existing commit.
   *
   * * `ExpiredWeightCommit`:
   * - Attempting to reveal a weight commit that has expired.
   *
   * * `RevealTooEarly`:
   * - Attempting to reveal weights outside the valid reveal period.
   *
   * * `InvalidRevealCommitHashNotMatch`:
   * - The revealed hash does not match any committed hash.
   *
   * * `InvalidInputLengths`:
   * - The input vectors are of mismatched lengths.
   **/
  | {
      name: "BatchRevealWeights";
      params: {
        netuid: number;
        uidsList: Array<Array<number>>;
        valuesList: Array<Array<number>>;
        saltsList: Array<Array<number>>;
        versionKeys: Array<bigint>;
      };
    }
  /**
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuid` (u16):
   * - The network uid we are setting these weights on.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey associated with the operation and the calling coldkey.
   *
   * * `dests` (Vec<u16>):
   * - The edge endpoint for the weight, i.e. j for w_ij.
   *
   * * 'weights' (Vec<u16>):
   * - The u16 integer encoded weights. Interpreted as rational
   * values in the range [0,1]. They must sum to in32::MAX.
   *
   * * 'version_key' ( u64 ):
   * - The network version key to check if the validator is up to date.
   *
   * # Event:
   *
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   *
   * # Raises:
   *
   * * NonAssociatedColdKey;
   * - Attempting to set weights on a non-associated cold key.
   *
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRootSubnet':
   * - Attempting to set weights on a subnet that is not the root network.
   *
   * * 'WeightVecNotEqualSize':
   * - Attempting to set weights with uids not of same length.
   *
   * * 'UidVecContainInvalidOne':
   * - Attempting to set weights with invalid uids.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'IncorrectWeightVersionKey':
   * - Attempting to set weights with the incorrect network version key.
   *
   * * 'SettingWeightsTooFast':
   * - Attempting to set weights too fast.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'MaxWeightExceeded':
   * - Attempting to set weights with max value exceeding limit.
   *
   **/
  | {
      name: "SetTaoWeights";
      params: {
        netuid: number;
        hotkey: AccountId32;
        dests: Array<number>;
        weights: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * --- Sets the key as a delegate.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'take' (u64):
   * - The stake proportion that this hotkey takes from delegations.
   *
   * # Event:
   * * DelegateAdded;
   * - On successfully setting a hotkey as a delegate.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldket.
   *
   **/
  | { name: "BecomeDelegate"; params: { hotkey: AccountId32 } }
  /**
   * --- Allows delegates to decrease its take value.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'netuid' (u16):
   * - Subnet ID to decrease take for
   *
   * * 'take' (u16):
   * - The new stake proportion that this hotkey takes from delegations.
   * The new value can be between 0 and 11_796 and should be strictly
   * lower than the previous value. It T is the new value (rational number),
   * the the parameter is calculated as [65535 * T]. For example, 1% would be
   * [0.01 * 65535] = [655.35] = 655
   *
   * # Event:
   * * TakeDecreased;
   * - On successfully setting a decreased take for this hotkey.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldkey.
   *
   * * 'DelegateTakeTooLow':
   * - The delegate is setting a take which is not lower than the previous.
   *
   **/
  | { name: "DecreaseTake"; params: { hotkey: AccountId32; take: number } }
  /**
   * --- Allows delegates to increase its take value. This call is rate-limited.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'take' (u16):
   * - The new stake proportion that this hotkey takes from delegations.
   * The new value can be between 0 and 11_796 and should be strictly
   * greater than the previous value. T is the new value (rational number),
   * the the parameter is calculated as [65535 * T]. For example, 1% would be
   * [0.01 * 65535] = [655.35] = 655
   *
   * # Event:
   * * TakeIncreased;
   * - On successfully setting a increased take for this hotkey.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldkey.
   *
   * * 'DelegateTakeTooHigh':
   * - The delegate is setting a take which is not greater than the previous.
   *
   **/
  | { name: "IncreaseTake"; params: { hotkey: AccountId32; take: number } }
  /**
   * --- Adds stake to a hotkey. The call is made from a coldkey account.
   * This delegates stake to the hotkey.
   *
   * Note: the coldkey account may own the hotkey, in which case they are
   * delegating to themselves.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_staked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * # Event:
   * * StakeAdded;
   * - On the successfully adding stake to a global account.
   *
   * # Raises:
   * * 'NotEnoughBalanceToStake':
   * - Not enough balance on the coldkey to add onto the global account.
   *
   * * 'NonAssociatedColdKey':
   * - The calling coldkey is not associated with this hotkey.
   *
   * * 'BalanceWithdrawalError':
   * - Errors stemming from transaction pallet.
   *
   **/
  | {
      name: "AddStake";
      params: { hotkey: AccountId32; netuid: number; amountStaked: bigint };
    }
  /**
   * Remove stake from the staking account. The call must be made
   * from the coldkey account attached to the neuron metadata. Only this key
   * has permission to make staking and unstaking requests.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_unstaked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * 'NotRegistered':
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * 'NonAssociatedColdKey':
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * 'NotEnoughStakeToWithdraw':
   * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
   *
   **/
  | {
      name: "RemoveStake";
      params: { hotkey: AccountId32; netuid: number; amountUnstaked: bigint };
    }
  /**
   * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
   * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u64):
   * - The bittensor version identifier.
   *
   * * 'ip' (u64):
   * - The endpoint ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The endpoint port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The endpoint ip version as a u8, 4 or 6.
   *
   * * 'protocol' (u8):
   * - UDP:1 or TCP:0
   *
   * * 'placeholder1' (u8):
   * - Placeholder for further extra params.
   *
   * * 'placeholder2' (u8):
   * - Placeholder for further extra params.
   *
   * # Event:
   * * AxonServed;
   * - On successfully serving the axon info.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'InvalidIpType':
   * - The ip type is not 4 or 6.
   *
   * * 'InvalidIpAddress':
   * - The numerically encoded ip address does not resolve to a proper ip.
   *
   * * 'ServingRateLimitExceeded':
   * - Attempting to set prometheus information withing the rate limit min.
   *
   **/
  | {
      name: "ServeAxon";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
        protocol: number;
        placeholder1: number;
        placeholder2: number;
      };
    }
  /**
   * Same as `serve_axon` but takes a certificate as an extra optional argument.
   * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
   * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u64):
   * - The bittensor version identifier.
   *
   * * 'ip' (u64):
   * - The endpoint ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The endpoint port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The endpoint ip version as a u8, 4 or 6.
   *
   * * 'protocol' (u8):
   * - UDP:1 or TCP:0
   *
   * * 'placeholder1' (u8):
   * - Placeholder for further extra params.
   *
   * * 'placeholder2' (u8):
   * - Placeholder for further extra params.
   *
   * * 'certificate' (Vec<u8>):
   * - TLS certificate for inter neuron communitation.
   *
   * # Event:
   * * AxonServed;
   * - On successfully serving the axon info.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'InvalidIpType':
   * - The ip type is not 4 or 6.
   *
   * * 'InvalidIpAddress':
   * - The numerically encoded ip address does not resolve to a proper ip.
   *
   * * 'ServingRateLimitExceeded':
   * - Attempting to set prometheus information withing the rate limit min.
   *
   **/
  | {
      name: "ServeAxonTls";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
        protocol: number;
        placeholder1: number;
        placeholder2: number;
        certificate: Bytes;
      };
    }
  /**
   * ---- Set prometheus information for the neuron.
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u16):
   * - The bittensor version identifier.
   *
   * * 'ip' (u128):
   * - The prometheus ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The prometheus port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The ip type v4 or v6.
   *
   **/
  | {
      name: "ServePrometheus";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
      };
    }
  /**
   * ---- Registers a new neuron to the subnetwork.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'block_number' ( u64 ):
   * - Block hash used to prove work done.
   *
   * * 'nonce' ( u64 ):
   * - Positive integer nonce used in POW.
   *
   * * 'work' ( Vec<u8> ):
   * - Vector encoded bytes representing work done.
   *
   * * 'hotkey' ( T::AccountId ):
   * - Hotkey to be registered to the network.
   *
   * * 'coldkey' ( T::AccountId ):
   * - Associated coldkey account.
   *
   * # Event:
   * * NeuronRegistered;
   * - On successfully registering a uid to a neuron slot on a subnetwork.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to register to a non existent network.
   *
   * * 'TooManyRegistrationsThisBlock':
   * - This registration exceeds the total allowed on this network this block.
   *
   * * 'HotKeyAlreadyRegisteredInSubNet':
   * - The hotkey is already registered on this network.
   *
   * * 'InvalidWorkBlock':
   * - The work has been performed on a stale, future, or non existent block.
   *
   * * 'InvalidDifficulty':
   * - The work does not match the difficulty.
   *
   * * 'InvalidSeal':
   * - The seal is incorrect.
   *
   **/
  | {
      name: "Register";
      params: {
        netuid: number;
        blockNumber: bigint;
        nonce: bigint;
        work: Bytes;
        hotkey: AccountId32;
        coldkey: AccountId32;
      };
    }
  /**
   * Register the hotkey to root network
   **/
  | { name: "RootRegister"; params: { hotkey: AccountId32 } }
  /**
   * Attempt to adjust the senate membership to include a hotkey
   **/
  | { name: "AdjustSenate"; params: { hotkey: AccountId32 } }
  /**
   * User register a new subnetwork via burning token
   **/
  | { name: "BurnedRegister"; params: { netuid: number; hotkey: AccountId32 } }
  /**
   * The extrinsic for user to change its hotkey in subnet or all subnets.
   **/
  | {
      name: "SwapHotkey";
      params: {
        hotkey: AccountId32;
        newHotkey: AccountId32;
        netuid?: number | undefined;
      };
    }
  /**
   * The extrinsic for user to change the coldkey associated with their account.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, must be signed by the old coldkey.
   * * `old_coldkey` - The current coldkey associated with the account.
   * * `new_coldkey` - The new coldkey to be associated with the account.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
   *
   * # Weight
   *
   * Weight is calculated based on the number of database reads and writes.
   **/
  | {
      name: "SwapColdkey";
      params: {
        oldColdkey: AccountId32;
        newColdkey: AccountId32;
        swapCost: bigint;
      };
    }
  /**
   * Sets the childkey take for a given hotkey.
   *
   * This function allows a coldkey to set the childkey take for a given hotkey.
   * The childkey take determines the proportion of stake that the hotkey keeps for itself
   * when distributing stake to its children.
   *
   * # Arguments:
   * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
   * - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey for which the childkey take will be set.
   *
   * * `take` (u16):
   * - The new childkey take value. This is a percentage represented as a value between 0 and 10000,
   * where 10000 represents 100%.
   *
   * # Events:
   * * `ChildkeyTakeSet`:
   * - On successfully setting the childkey take for a hotkey.
   *
   * # Errors:
   * * `NonAssociatedColdKey`:
   * - The coldkey does not own the hotkey.
   * * `InvalidChildkeyTake`:
   * - The provided take value is invalid (greater than the maximum allowed take).
   * * `TxChildkeyTakeRateLimitExceeded`:
   * - The rate limit for changing childkey take has been exceeded.
   *
   **/
  | {
      name: "SetChildkeyTake";
      params: { hotkey: AccountId32; netuid: number; take: number };
    }
  /**
   * Sets the transaction rate limit for changing childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `tx_rate_limit` - The new rate limit in blocks.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetTxChildkeyTakeRateLimit"; params: { txRateLimit: bigint } }
  /**
   * Sets the minimum allowed childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `take` - The new minimum childkey take value.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetMinChildkeyTake"; params: { take: number } }
  /**
   * Sets the maximum allowed childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `take` - The new maximum childkey take value.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetMaxChildkeyTake"; params: { take: number } }
  /**
   * Authenticates a council proposal and dispatches a function call with `Root` origin.
   *
   * The dispatch origin for this call must be a council majority.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: "Sudo"; params: { call: NodeSubtensorRuntimeRuntimeCall } }
  /**
   * Authenticates a council proposal and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * user to specify the weight of the call.
   *
   * The dispatch origin for this call must be a council majority.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "SudoUncheckedWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCall;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * User vote on a proposal
   **/
  | {
      name: "Vote";
      params: {
        hotkey: AccountId32;
        proposal: H256;
        index: number;
        approve: boolean;
      };
    }
  /**
   * User register a new subnetwork
   **/
  | { name: "RegisterNetwork"; params: { hotkey: AccountId32 } }
  /**
   * Facility extrinsic for user to get taken from faucet
   * It is only available when pow-faucet feature enabled
   * Just deployed in testnet and devnet for testing purpose
   **/
  | {
      name: "Faucet";
      params: { blockNumber: bigint; nonce: bigint; work: Bytes };
    }
  /**
   * Remove a user's subnetwork
   * The caller must be the owner of the network
   **/
  | {
      name: "DissolveNetwork";
      params: { coldkey: AccountId32; netuid: number };
    }
  /**
   * Set a single child for a given hotkey on a specified network.
   *
   * This function allows a coldkey to set a single child for a given hotkey on a specified network.
   * The proportion of the hotkey's stake to be allocated to the child is also specified.
   *
   * # Arguments:
   * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
   * - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey which will be assigned the child.
   *
   * * `child` (T::AccountId):
   * - The child which will be assigned to the hotkey.
   *
   * * `netuid` (u16):
   * - The u16 network identifier where the childkey will exist.
   *
   * * `proportion` (u64):
   * - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized.
   *
   * # Events:
   * * `ChildAddedSingular`:
   * - On successfully registering a child to a hotkey.
   *
   * # Errors:
   * * `SubNetworkDoesNotExist`:
   * - Attempting to register to a non-existent network.
   * * `RegistrationNotPermittedOnRootSubnet`:
   * - Attempting to register a child on the root network.
   * * `NonAssociatedColdKey`:
   * - The coldkey does not own the hotkey or the child is the same as the hotkey.
   * * `HotKeyAccountNotExists`:
   * - The hotkey account does not exist.
   *
   * # Detailed Explanation of Checks:
   * 1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey.
   * 2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root.
   * 3. **Network Existence Check**: Ensures that the specified network exists.
   * 4. **Ownership Verification**: Ensures that the coldkey owns the hotkey.
   * 5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists.
   * 6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey.
   * 7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children.
   * 8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child.
   **/
  | {
      name: "SetChildren";
      params: {
        hotkey: AccountId32;
        netuid: number;
        children: Array<[bigint, AccountId32]>;
      };
    }
  /**
   * Schedules a coldkey swap operation to be executed at a future block.
   *
   * This function allows a user to schedule the swapping of their coldkey to a new one
   * at a specified future block. The swap is not executed immediately but is scheduled
   * to occur at the specified block number.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, which should be signed by the current coldkey owner.
   * * `new_coldkey` - The account ID of the new coldkey that will replace the current one.
   * * `when` - The block number at which the coldkey swap should be executed.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful.
   *
   * # Errors
   *
   * This function may return an error if:
   * * The origin is not signed.
   * * The scheduling fails due to conflicts or system constraints.
   *
   * # Notes
   *
   * - The actual swap is not performed by this function. It merely schedules the swap operation.
   * - The weight of this call is set to a fixed value and may need adjustment based on benchmarking.
   *
   * # TODO
   *
   * - Implement proper weight calculation based on the complexity of the operation.
   * - Consider adding checks to prevent scheduling too far into the future.
   * TODO: Benchmark this call
   **/
  | { name: "ScheduleSwapColdkey"; params: { newColdkey: AccountId32 } }
  /**
   * Schedule the dissolution of a network at a specified block number.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, must be signed by the sender.
   * * `netuid` - The u16 network identifier to be dissolved.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
   *
   * # Weight
   *
   * Weight is calculated based on the number of database reads and writes.
   **/
  | { name: "ScheduleDissolveNetwork"; params: { netuid: number } }
  /**
   * ---- Set prometheus information for the neuron.
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u16):
   * - The bittensor version identifier.
   *
   * * 'ip' (u128):
   * - The prometheus ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The prometheus port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The ip type v4 or v6.
   *
   **/
  | {
      name: "SetIdentity";
      params: {
        name: Bytes;
        url: Bytes;
        githubRepo: Bytes;
        image: Bytes;
        discord: Bytes;
        description: Bytes;
        additional: Bytes;
      };
    }
  /**
   * ---- Set the identity information for a subnet.
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the calling coldkey, which must be the owner of the subnet.
   *
   * * `netuid` (u16):
   * - The unique network identifier of the subnet.
   *
   * * `subnet_name` (Vec<u8>):
   * - The name of the subnet.
   *
   * * `github_repo` (Vec<u8>):
   * - The GitHub repository associated with the subnet identity.
   *
   * * `subnet_contact` (Vec<u8>):
   * - The contact information for the subnet.
   **/
  | {
      name: "SetSubnetIdentity";
      params: {
        netuid: number;
        subnetName: Bytes;
        githubRepo: Bytes;
        subnetContact: Bytes;
        subnetUrl: Bytes;
        discord: Bytes;
        description: Bytes;
        additional: Bytes;
      };
    }
  /**
   * User register a new subnetwork
   **/
  | {
      name: "RegisterNetworkWithIdentity";
      params: {
        hotkey: AccountId32;
        identity?: PalletSubtensorSubnetIdentityV2 | undefined;
      };
    }
  /**
   * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The associated hotkey account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * `NotRegistered`:
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * `NonAssociatedColdKey`:
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * `NotEnoughStakeToWithdraw`:
   * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
   *
   * * `TxRateLimitExceeded`:
   * - Thrown if key has hit transaction rate limit
   **/
  | { name: "UnstakeAll"; params: { hotkey: AccountId32 } }
  /**
   * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The associated hotkey account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * `NotRegistered`:
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * `NonAssociatedColdKey`:
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * `NotEnoughStakeToWithdraw`:
   * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
   *
   * * `TxRateLimitExceeded`:
   * - Thrown if key has hit transaction rate limit
   **/
  | { name: "UnstakeAllAlpha"; params: { hotkey: AccountId32 } }
  /**
   * ---- The implementation for the extrinsic move_stake: Moves specified amount of stake from a hotkey to another across subnets.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `origin_hotkey` (T::AccountId):
   * - The hotkey account to move stake from.
   *
   * * `destination_hotkey` (T::AccountId):
   * - The hotkey account to move stake to.
   *
   * * `origin_netuid` (T::AccountId):
   * - The subnet ID to move stake from.
   *
   * * `destination_netuid` (T::AccountId):
   * - The subnet ID to move stake to.
   *
   * * `alpha_amount` (T::AccountId):
   * - The alpha stake amount to move.
   *
   **/
  | {
      name: "MoveStake";
      params: {
        originHotkey: AccountId32;
        destinationHotkey: AccountId32;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * Transfers a specified amount of stake from one coldkey to another, optionally across subnets,
   * while keeping the same hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the `origin_coldkey`.
   * * `destination_coldkey` - The coldkey to which the stake is transferred.
   * * `hotkey` - The hotkey associated with the stake.
   * * `origin_netuid` - The network/subnet ID to move stake from.
   * * `destination_netuid` - The network/subnet ID to move stake to (for cross-subnet transfer).
   * * `alpha_amount` - The amount of stake to transfer.
   *
   * # Errors
   * Returns an error if:
   * * The origin is not signed by the correct coldkey.
   * * Either subnet does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(origin_coldkey, hotkey, origin_netuid)`.
   * * The transfer amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeTransferred` event on success.
   **/
  | {
      name: "TransferStake";
      params: {
        destinationColdkey: AccountId32;
        hotkey: AccountId32;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey whose stake is being swapped.
   * * `origin_netuid` - The network/subnet ID from which stake is removed.
   * * `destination_netuid` - The network/subnet ID to which stake is added.
   * * `alpha_amount` - The amount of stake to swap.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
   * * Either `origin_netuid` or `destination_netuid` does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
   * * The swap amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeSwapped` event on success.
   **/
  | {
      name: "SwapStake";
      params: {
        hotkey: AccountId32;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * --- Adds stake to a hotkey on a subnet with a price limit.
   * This extrinsic allows to specify the limit price for alpha token
   * at which or better (lower) the staking should execute.
   *
   * In case if slippage occurs and the price shall move beyond the limit
   * price, the staking order may execute only partially or not execute
   * at all.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_staked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * * 'limit_price' (u64):
   * - The limit price expressed in units of RAO per one Alpha.
   *
   * * 'allow_partial' (bool):
   * - Allows partial execution of the amount. If set to false, this becomes
   * fill or kill type or order.
   *
   * # Event:
   * * StakeAdded;
   * - On the successfully adding stake to a global account.
   *
   * # Raises:
   * * 'NotEnoughBalanceToStake':
   * - Not enough balance on the coldkey to add onto the global account.
   *
   * * 'NonAssociatedColdKey':
   * - The calling coldkey is not associated with this hotkey.
   *
   * * 'BalanceWithdrawalError':
   * - Errors stemming from transaction pallet.
   *
   **/
  | {
      name: "AddStakeLimit";
      params: {
        hotkey: AccountId32;
        netuid: number;
        amountStaked: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * --- Removes stake from a hotkey on a subnet with a price limit.
   * This extrinsic allows to specify the limit price for alpha token
   * at which or better (higher) the staking should execute.
   *
   * In case if slippage occurs and the price shall move beyond the limit
   * price, the staking order may execute only partially or not execute
   * at all.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_unstaked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * * 'limit_price' (u64):
   * - The limit price expressed in units of RAO per one Alpha.
   *
   * * 'allow_partial' (bool):
   * - Allows partial execution of the amount. If set to false, this becomes
   * fill or kill type or order.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * 'NotRegistered':
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * 'NonAssociatedColdKey':
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * 'NotEnoughStakeToWithdraw':
   * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
   *
   **/
  | {
      name: "RemoveStakeLimit";
      params: {
        hotkey: AccountId32;
        netuid: number;
        amountUnstaked: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey whose stake is being swapped.
   * * `origin_netuid` - The network/subnet ID from which stake is removed.
   * * `destination_netuid` - The network/subnet ID to which stake is added.
   * * `alpha_amount` - The amount of stake to swap.
   * * `limit_price` - The limit price expressed in units of RAO per one Alpha.
   * * `allow_partial` - Allows partial execution of the amount. If set to false, this becomes fill or kill type or order.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
   * * Either `origin_netuid` or `destination_netuid` does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
   * * The swap amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeSwapped` event on success.
   **/
  | {
      name: "SwapStakeLimit";
      params: {
        hotkey: AccountId32;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * Attempts to associate a hotkey with a coldkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey to associate with the coldkey.
   *
   * # Note
   * Will charge based on the weight even if the hotkey is already associated with a coldkey.
   **/
  | { name: "TryAssociateHotkey"; params: { hotkey: AccountId32 } }
  /**
   * Initiates a call on a subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be signed by the subnet owner.
   * * `netuid` - The unique identifier of the subnet on which the call is being initiated.
   *
   * # Events
   * Emits a `FirstEmissionBlockNumberSet` event on success.
   **/
  | { name: "StartCall"; params: { netuid: number } }
  /**
   * Attempts to associate a hotkey with an EVM key.
   *
   * The signature will be checked to see if the recovered public key matches the `evm_key` provided.
   *
   * The EVM key is expected to sign the message according to this formula to produce the signature:
   * ```text
   * keccak_256(hotkey ++ keccak_256(block_number))
   * ```
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `netuid` - The netuid that the `hotkey` belongs to.
   * * `hotkey` - The hotkey associated with the `origin`.
   * * `evm_key` - The EVM key to associate with the `hotkey`.
   * * `block_number` - The block number used in the `signature`.
   * * `signature` - A signed message by the `evm_key` containing the `hotkey` and the hashed `block_number`.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed.
   * * The hotkey is not owned by the origin coldkey.
   * * The hotkey does not belong to the subnet identified by the netuid.
   * * The EVM key cannot be recovered from the signature.
   * * The EVM key recovered from the signature does not match the given EVM key.
   *
   * # Events
   * May emit a `EvmKeyAssociated` event on success
   **/
  | {
      name: "AssociateEvmKey";
      params: {
        netuid: number;
        hotkey: AccountId32;
        evmKey: H160;
        blockNumber: bigint;
        signature: FixedBytes<65>;
      };
    }
  /**
   * Recycles alpha from a cold/hot key pair, reducing AlphaOut on a subnet
   *
   * # Arguments
   * * `origin` - The origin of the call (must be signed by the coldkey)
   * * `hotkey` - The hotkey account
   * * `amount` - The amount of alpha to recycle
   * * `netuid` - The subnet ID
   *
   * # Events
   * Emits a `TokensRecycled` event on success.
   **/
  | {
      name: "RecycleAlpha";
      params: { hotkey: AccountId32; amount: bigint; netuid: number };
    }
  /**
   * Burns alpha from a cold/hot key pair without reducing `AlphaOut`
   *
   * # Arguments
   * * `origin` - The origin of the call (must be signed by the coldkey)
   * * `hotkey` - The hotkey account
   * * `amount` - The amount of alpha to burn
   * * `netuid` - The subnet ID
   *
   * # Events
   * Emits a `TokensBurned` event on success.
   **/
  | {
      name: "BurnAlpha";
      params: { hotkey: AccountId32; amount: bigint; netuid: number };
    }
  /**
   * Sets the pending childkey cooldown (in blocks). Root only.
   **/
  | { name: "SetPendingChildkeyCooldown"; params: { cooldown: bigint } };

export type PalletSubtensorCallLike =
  /**
   * --- Sets the caller weights for the incentive mechanism. The call can be
   * made from the hotkey account so is potentially insecure, however, the damage
   * of changing weights is minimal if caught early. This function includes all the
   * checks that the passed weights meet the requirements. Stored as u16s they represent
   * rational values in the range [0,1] which sum to 1 and can be interpreted as
   * probabilities. The specific weights determine how inflation propagates outward
   * from this peer.
   *
   * Note: The 16 bit integers weights should represent 1.0 as the max u16.
   * However, the function normalizes all integers to u16_max anyway. This means that if the sum of all
   * elements is larger or smaller than the amount of elements * u16_max, all elements
   * will be corrected for this deviation.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuid` (u16):
   * - The network uid we are setting these weights on.
   *
   * * `dests` (Vec<u16>):
   * - The edge endpoint for the weight, i.e. j for w_ij.
   *
   * * 'weights' (Vec<u16>):
   * - The u16 integer encoded weights. Interpreted as rational
   * values in the range [0,1]. They must sum to in32::MAX.
   *
   * * 'version_key' ( u64 ):
   * - The network version key to check if the validator is up to date.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'WeightVecNotEqualSize':
   * - Attempting to set weights with uids not of same length.
   *
   * * 'DuplicateUids':
   * - Attempting to set weights with duplicate uids.
   *
   * * 'UidsLengthExceedUidsInSubNet':
   * - Attempting to set weights above the max allowed uids.
   *
   * * 'UidVecContainInvalidOne':
   * - Attempting to set weights with invalid uids.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'MaxWeightExceeded':
   * - Attempting to set weights with max value exceeding limit.
   **/
  | {
      name: "SetWeights";
      params: {
        netuid: number;
        dests: Array<number>;
        weights: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * --- Allows a hotkey to set weights for multiple netuids as a batch.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuids` (Vec<Compact<u16>>):
   * - The network uids we are setting these weights on.
   *
   * * `weights` (Vec<Vec<(Compact<u16>, Compact<u16>)>):
   * - The weights to set for each network. [(uid, weight), ...]
   *
   * * `version_keys` (Vec<Compact<u64>>):
   * - The network version keys to check if the validator is up to date.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   * * BatchWeightsCompleted;
   * - On success of the batch.
   * * BatchCompletedWithErrors;
   * - On failure of any of the weights in the batch.
   * * BatchWeightItemFailed;
   * - On failure for each failed item in the batch.
   *
   **/
  | {
      name: "BatchSetWeights";
      params: {
        netuids: Array<number>;
        weights: Array<Array<[number, number]>>;
        versionKeys: Array<bigint>;
      };
    }
  /**
   * ---- Used to commit a hash of your weight values to later be revealed.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the committing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `commit_hash` (`H256`):
   * - The hash representing the committed weights.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to commit when the commit-reveal mechanism is disabled.
   *
   * * `TooManyUnrevealedCommits`:
   * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
   *
   **/
  | { name: "CommitWeights"; params: { netuid: number; commitHash: H256 } }
  /**
   * --- Allows a hotkey to commit weight hashes for multiple netuids as a batch.
   *
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuids` (Vec<Compact<u16>>):
   * - The network uids we are setting these weights on.
   *
   * * `commit_hashes` (Vec<H256>):
   * - The commit hashes to commit.
   *
   * # Event:
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   * * BatchWeightsCompleted;
   * - On success of the batch.
   * * BatchCompletedWithErrors;
   * - On failure of any of the weights in the batch.
   * * BatchWeightItemFailed;
   * - On failure for each failed item in the batch.
   *
   **/
  | {
      name: "BatchCommitWeights";
      params: { netuids: Array<number>; commitHashes: Array<H256> };
    }
  /**
   * ---- Used to reveal the weights for a previously committed hash.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the revealing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `uids` (`Vec<u16>`):
   * - The uids for the weights being revealed.
   *
   * * `values` (`Vec<u16>`):
   * - The values of the weights being revealed.
   *
   * * `salt` (`Vec<u16>`):
   * - The salt used to generate the commit hash.
   *
   * * `version_key` (`u64`):
   * - The network version key.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
   *
   * * `NoWeightsCommitFound`:
   * - Attempting to reveal weights without an existing commit.
   *
   * * `ExpiredWeightCommit`:
   * - Attempting to reveal a weight commit that has expired.
   *
   * * `RevealTooEarly`:
   * - Attempting to reveal weights outside the valid reveal period.
   *
   * * `InvalidRevealCommitHashNotMatch`:
   * - The revealed hash does not match any committed hash.
   *
   **/
  | {
      name: "RevealWeights";
      params: {
        netuid: number;
        uids: Array<number>;
        values: Array<number>;
        salt: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * ---- Used to commit encrypted commit-reveal v3 weight values to later be revealed.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The committing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `commit` (`Vec<u8>`):
   * - The encrypted compressed commit.
   * The steps for this are:
   * 1. Instantiate [`WeightsTlockPayload`]
   * 2. Serialize it using the `parity_scale_codec::Encode` trait
   * 3. Encrypt it following the steps (here)[https://github.com/ideal-lab5/tle/blob/f8e6019f0fb02c380ebfa6b30efb61786dede07b/timelock/src/tlock.rs#L283-L336]
   * to produce a [`TLECiphertext<TinyBLS381>`] type.
   * 4. Serialize and compress using the `ark-serialize` `CanonicalSerialize` trait.
   *
   * * reveal_round (`u64`):
   * - The drand reveal round which will be avaliable during epoch `n+1` from the current
   * epoch.
   *
   * # Raises:
   * * `CommitRevealV3Disabled`:
   * - Attempting to commit when the commit-reveal mechanism is disabled.
   *
   * * `TooManyUnrevealedCommits`:
   * - Attempting to commit when the user has more than the allowed limit of unrevealed commits.
   *
   **/
  | {
      name: "CommitCrv3Weights";
      params: { netuid: number; commit: BytesLike; revealRound: bigint };
    }
  /**
   * ---- The implementation for batch revealing committed weights.
   *
   * # Args:
   * * `origin`: (`<T as frame_system::Config>::RuntimeOrigin`):
   * - The signature of the revealing hotkey.
   *
   * * `netuid` (`u16`):
   * - The u16 network identifier.
   *
   * * `uids_list` (`Vec<Vec<u16>>`):
   * - A list of uids for each set of weights being revealed.
   *
   * * `values_list` (`Vec<Vec<u16>>`):
   * - A list of values for each set of weights being revealed.
   *
   * * `salts_list` (`Vec<Vec<u16>>`):
   * - A list of salts used to generate the commit hashes.
   *
   * * `version_keys` (`Vec<u64>`):
   * - A list of network version keys.
   *
   * # Raises:
   * * `CommitRevealDisabled`:
   * - Attempting to reveal weights when the commit-reveal mechanism is disabled.
   *
   * * `NoWeightsCommitFound`:
   * - Attempting to reveal weights without an existing commit.
   *
   * * `ExpiredWeightCommit`:
   * - Attempting to reveal a weight commit that has expired.
   *
   * * `RevealTooEarly`:
   * - Attempting to reveal weights outside the valid reveal period.
   *
   * * `InvalidRevealCommitHashNotMatch`:
   * - The revealed hash does not match any committed hash.
   *
   * * `InvalidInputLengths`:
   * - The input vectors are of mismatched lengths.
   **/
  | {
      name: "BatchRevealWeights";
      params: {
        netuid: number;
        uidsList: Array<Array<number>>;
        valuesList: Array<Array<number>>;
        saltsList: Array<Array<number>>;
        versionKeys: Array<bigint>;
      };
    }
  /**
   * # Args:
   * * `origin`: (<T as frame_system::Config>Origin):
   * - The caller, a hotkey who wishes to set their weights.
   *
   * * `netuid` (u16):
   * - The network uid we are setting these weights on.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey associated with the operation and the calling coldkey.
   *
   * * `dests` (Vec<u16>):
   * - The edge endpoint for the weight, i.e. j for w_ij.
   *
   * * 'weights' (Vec<u16>):
   * - The u16 integer encoded weights. Interpreted as rational
   * values in the range [0,1]. They must sum to in32::MAX.
   *
   * * 'version_key' ( u64 ):
   * - The network version key to check if the validator is up to date.
   *
   * # Event:
   *
   * * WeightsSet;
   * - On successfully setting the weights on chain.
   *
   * # Raises:
   *
   * * NonAssociatedColdKey;
   * - Attempting to set weights on a non-associated cold key.
   *
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRootSubnet':
   * - Attempting to set weights on a subnet that is not the root network.
   *
   * * 'WeightVecNotEqualSize':
   * - Attempting to set weights with uids not of same length.
   *
   * * 'UidVecContainInvalidOne':
   * - Attempting to set weights with invalid uids.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'IncorrectWeightVersionKey':
   * - Attempting to set weights with the incorrect network version key.
   *
   * * 'SettingWeightsTooFast':
   * - Attempting to set weights too fast.
   *
   * * 'WeightVecLengthIsLow':
   * - Attempting to set weights with fewer weights than min.
   *
   * * 'MaxWeightExceeded':
   * - Attempting to set weights with max value exceeding limit.
   *
   **/
  | {
      name: "SetTaoWeights";
      params: {
        netuid: number;
        hotkey: AccountId32Like;
        dests: Array<number>;
        weights: Array<number>;
        versionKey: bigint;
      };
    }
  /**
   * --- Sets the key as a delegate.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'take' (u64):
   * - The stake proportion that this hotkey takes from delegations.
   *
   * # Event:
   * * DelegateAdded;
   * - On successfully setting a hotkey as a delegate.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldket.
   *
   **/
  | { name: "BecomeDelegate"; params: { hotkey: AccountId32Like } }
  /**
   * --- Allows delegates to decrease its take value.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'netuid' (u16):
   * - Subnet ID to decrease take for
   *
   * * 'take' (u16):
   * - The new stake proportion that this hotkey takes from delegations.
   * The new value can be between 0 and 11_796 and should be strictly
   * lower than the previous value. It T is the new value (rational number),
   * the the parameter is calculated as [65535 * T]. For example, 1% would be
   * [0.01 * 65535] = [655.35] = 655
   *
   * # Event:
   * * TakeDecreased;
   * - On successfully setting a decreased take for this hotkey.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldkey.
   *
   * * 'DelegateTakeTooLow':
   * - The delegate is setting a take which is not lower than the previous.
   *
   **/
  | { name: "DecreaseTake"; params: { hotkey: AccountId32Like; take: number } }
  /**
   * --- Allows delegates to increase its take value. This call is rate-limited.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The hotkey we are delegating (must be owned by the coldkey.)
   *
   * * 'take' (u16):
   * - The new stake proportion that this hotkey takes from delegations.
   * The new value can be between 0 and 11_796 and should be strictly
   * greater than the previous value. T is the new value (rational number),
   * the the parameter is calculated as [65535 * T]. For example, 1% would be
   * [0.01 * 65535] = [655.35] = 655
   *
   * # Event:
   * * TakeIncreased;
   * - On successfully setting a increased take for this hotkey.
   *
   * # Raises:
   * * 'NotRegistered':
   * - The hotkey we are delegating is not registered on the network.
   *
   * * 'NonAssociatedColdKey':
   * - The hotkey we are delegating is not owned by the calling coldkey.
   *
   * * 'DelegateTakeTooHigh':
   * - The delegate is setting a take which is not greater than the previous.
   *
   **/
  | { name: "IncreaseTake"; params: { hotkey: AccountId32Like; take: number } }
  /**
   * --- Adds stake to a hotkey. The call is made from a coldkey account.
   * This delegates stake to the hotkey.
   *
   * Note: the coldkey account may own the hotkey, in which case they are
   * delegating to themselves.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_staked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * # Event:
   * * StakeAdded;
   * - On the successfully adding stake to a global account.
   *
   * # Raises:
   * * 'NotEnoughBalanceToStake':
   * - Not enough balance on the coldkey to add onto the global account.
   *
   * * 'NonAssociatedColdKey':
   * - The calling coldkey is not associated with this hotkey.
   *
   * * 'BalanceWithdrawalError':
   * - Errors stemming from transaction pallet.
   *
   **/
  | {
      name: "AddStake";
      params: { hotkey: AccountId32Like; netuid: number; amountStaked: bigint };
    }
  /**
   * Remove stake from the staking account. The call must be made
   * from the coldkey account attached to the neuron metadata. Only this key
   * has permission to make staking and unstaking requests.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_unstaked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * 'NotRegistered':
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * 'NonAssociatedColdKey':
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * 'NotEnoughStakeToWithdraw':
   * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
   *
   **/
  | {
      name: "RemoveStake";
      params: {
        hotkey: AccountId32Like;
        netuid: number;
        amountUnstaked: bigint;
      };
    }
  /**
   * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
   * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u64):
   * - The bittensor version identifier.
   *
   * * 'ip' (u64):
   * - The endpoint ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The endpoint port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The endpoint ip version as a u8, 4 or 6.
   *
   * * 'protocol' (u8):
   * - UDP:1 or TCP:0
   *
   * * 'placeholder1' (u8):
   * - Placeholder for further extra params.
   *
   * * 'placeholder2' (u8):
   * - Placeholder for further extra params.
   *
   * # Event:
   * * AxonServed;
   * - On successfully serving the axon info.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'InvalidIpType':
   * - The ip type is not 4 or 6.
   *
   * * 'InvalidIpAddress':
   * - The numerically encoded ip address does not resolve to a proper ip.
   *
   * * 'ServingRateLimitExceeded':
   * - Attempting to set prometheus information withing the rate limit min.
   *
   **/
  | {
      name: "ServeAxon";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
        protocol: number;
        placeholder1: number;
        placeholder2: number;
      };
    }
  /**
   * Same as `serve_axon` but takes a certificate as an extra optional argument.
   * Serves or updates axon /prometheus information for the neuron associated with the caller. If the caller is
   * already registered the metadata is updated. If the caller is not registered this call throws NotRegistered.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u64):
   * - The bittensor version identifier.
   *
   * * 'ip' (u64):
   * - The endpoint ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The endpoint port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The endpoint ip version as a u8, 4 or 6.
   *
   * * 'protocol' (u8):
   * - UDP:1 or TCP:0
   *
   * * 'placeholder1' (u8):
   * - Placeholder for further extra params.
   *
   * * 'placeholder2' (u8):
   * - Placeholder for further extra params.
   *
   * * 'certificate' (Vec<u8>):
   * - TLS certificate for inter neuron communitation.
   *
   * # Event:
   * * AxonServed;
   * - On successfully serving the axon info.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to set weights on a non-existent network.
   *
   * * 'NotRegistered':
   * - Attempting to set weights from a non registered account.
   *
   * * 'InvalidIpType':
   * - The ip type is not 4 or 6.
   *
   * * 'InvalidIpAddress':
   * - The numerically encoded ip address does not resolve to a proper ip.
   *
   * * 'ServingRateLimitExceeded':
   * - Attempting to set prometheus information withing the rate limit min.
   *
   **/
  | {
      name: "ServeAxonTls";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
        protocol: number;
        placeholder1: number;
        placeholder2: number;
        certificate: BytesLike;
      };
    }
  /**
   * ---- Set prometheus information for the neuron.
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u16):
   * - The bittensor version identifier.
   *
   * * 'ip' (u128):
   * - The prometheus ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The prometheus port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The ip type v4 or v6.
   *
   **/
  | {
      name: "ServePrometheus";
      params: {
        netuid: number;
        version: number;
        ip: bigint;
        port: number;
        ipType: number;
      };
    }
  /**
   * ---- Registers a new neuron to the subnetwork.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'block_number' ( u64 ):
   * - Block hash used to prove work done.
   *
   * * 'nonce' ( u64 ):
   * - Positive integer nonce used in POW.
   *
   * * 'work' ( Vec<u8> ):
   * - Vector encoded bytes representing work done.
   *
   * * 'hotkey' ( T::AccountId ):
   * - Hotkey to be registered to the network.
   *
   * * 'coldkey' ( T::AccountId ):
   * - Associated coldkey account.
   *
   * # Event:
   * * NeuronRegistered;
   * - On successfully registering a uid to a neuron slot on a subnetwork.
   *
   * # Raises:
   * * 'SubNetworkDoesNotExist':
   * - Attempting to register to a non existent network.
   *
   * * 'TooManyRegistrationsThisBlock':
   * - This registration exceeds the total allowed on this network this block.
   *
   * * 'HotKeyAlreadyRegisteredInSubNet':
   * - The hotkey is already registered on this network.
   *
   * * 'InvalidWorkBlock':
   * - The work has been performed on a stale, future, or non existent block.
   *
   * * 'InvalidDifficulty':
   * - The work does not match the difficulty.
   *
   * * 'InvalidSeal':
   * - The seal is incorrect.
   *
   **/
  | {
      name: "Register";
      params: {
        netuid: number;
        blockNumber: bigint;
        nonce: bigint;
        work: BytesLike;
        hotkey: AccountId32Like;
        coldkey: AccountId32Like;
      };
    }
  /**
   * Register the hotkey to root network
   **/
  | { name: "RootRegister"; params: { hotkey: AccountId32Like } }
  /**
   * Attempt to adjust the senate membership to include a hotkey
   **/
  | { name: "AdjustSenate"; params: { hotkey: AccountId32Like } }
  /**
   * User register a new subnetwork via burning token
   **/
  | {
      name: "BurnedRegister";
      params: { netuid: number; hotkey: AccountId32Like };
    }
  /**
   * The extrinsic for user to change its hotkey in subnet or all subnets.
   **/
  | {
      name: "SwapHotkey";
      params: {
        hotkey: AccountId32Like;
        newHotkey: AccountId32Like;
        netuid?: number | undefined;
      };
    }
  /**
   * The extrinsic for user to change the coldkey associated with their account.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, must be signed by the old coldkey.
   * * `old_coldkey` - The current coldkey associated with the account.
   * * `new_coldkey` - The new coldkey to be associated with the account.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
   *
   * # Weight
   *
   * Weight is calculated based on the number of database reads and writes.
   **/
  | {
      name: "SwapColdkey";
      params: {
        oldColdkey: AccountId32Like;
        newColdkey: AccountId32Like;
        swapCost: bigint;
      };
    }
  /**
   * Sets the childkey take for a given hotkey.
   *
   * This function allows a coldkey to set the childkey take for a given hotkey.
   * The childkey take determines the proportion of stake that the hotkey keeps for itself
   * when distributing stake to its children.
   *
   * # Arguments:
   * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
   * - The signature of the calling coldkey. Setting childkey take can only be done by the coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey for which the childkey take will be set.
   *
   * * `take` (u16):
   * - The new childkey take value. This is a percentage represented as a value between 0 and 10000,
   * where 10000 represents 100%.
   *
   * # Events:
   * * `ChildkeyTakeSet`:
   * - On successfully setting the childkey take for a hotkey.
   *
   * # Errors:
   * * `NonAssociatedColdKey`:
   * - The coldkey does not own the hotkey.
   * * `InvalidChildkeyTake`:
   * - The provided take value is invalid (greater than the maximum allowed take).
   * * `TxChildkeyTakeRateLimitExceeded`:
   * - The rate limit for changing childkey take has been exceeded.
   *
   **/
  | {
      name: "SetChildkeyTake";
      params: { hotkey: AccountId32Like; netuid: number; take: number };
    }
  /**
   * Sets the transaction rate limit for changing childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `tx_rate_limit` - The new rate limit in blocks.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetTxChildkeyTakeRateLimit"; params: { txRateLimit: bigint } }
  /**
   * Sets the minimum allowed childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `take` - The new minimum childkey take value.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetMinChildkeyTake"; params: { take: number } }
  /**
   * Sets the maximum allowed childkey take.
   *
   * This function can only be called by the root origin.
   *
   * # Arguments:
   * * `origin` - The origin of the call, must be root.
   * * `take` - The new maximum childkey take value.
   *
   * # Errors:
   * * `BadOrigin` - If the origin is not root.
   *
   **/
  | { name: "SudoSetMaxChildkeyTake"; params: { take: number } }
  /**
   * Authenticates a council proposal and dispatches a function call with `Root` origin.
   *
   * The dispatch origin for this call must be a council majority.
   *
   * ## Complexity
   * - O(1).
   **/
  | { name: "Sudo"; params: { call: NodeSubtensorRuntimeRuntimeCallLike } }
  /**
   * Authenticates a council proposal and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * user to specify the weight of the call.
   *
   * The dispatch origin for this call must be a council majority.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "SudoUncheckedWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * User vote on a proposal
   **/
  | {
      name: "Vote";
      params: {
        hotkey: AccountId32Like;
        proposal: H256;
        index: number;
        approve: boolean;
      };
    }
  /**
   * User register a new subnetwork
   **/
  | { name: "RegisterNetwork"; params: { hotkey: AccountId32Like } }
  /**
   * Facility extrinsic for user to get taken from faucet
   * It is only available when pow-faucet feature enabled
   * Just deployed in testnet and devnet for testing purpose
   **/
  | {
      name: "Faucet";
      params: { blockNumber: bigint; nonce: bigint; work: BytesLike };
    }
  /**
   * Remove a user's subnetwork
   * The caller must be the owner of the network
   **/
  | {
      name: "DissolveNetwork";
      params: { coldkey: AccountId32Like; netuid: number };
    }
  /**
   * Set a single child for a given hotkey on a specified network.
   *
   * This function allows a coldkey to set a single child for a given hotkey on a specified network.
   * The proportion of the hotkey's stake to be allocated to the child is also specified.
   *
   * # Arguments:
   * * `origin` (<T as frame_system::Config>::RuntimeOrigin):
   * - The signature of the calling coldkey. Setting a hotkey child can only be done by the coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The hotkey which will be assigned the child.
   *
   * * `child` (T::AccountId):
   * - The child which will be assigned to the hotkey.
   *
   * * `netuid` (u16):
   * - The u16 network identifier where the childkey will exist.
   *
   * * `proportion` (u64):
   * - Proportion of the hotkey's stake to be given to the child, the value must be u64 normalized.
   *
   * # Events:
   * * `ChildAddedSingular`:
   * - On successfully registering a child to a hotkey.
   *
   * # Errors:
   * * `SubNetworkDoesNotExist`:
   * - Attempting to register to a non-existent network.
   * * `RegistrationNotPermittedOnRootSubnet`:
   * - Attempting to register a child on the root network.
   * * `NonAssociatedColdKey`:
   * - The coldkey does not own the hotkey or the child is the same as the hotkey.
   * * `HotKeyAccountNotExists`:
   * - The hotkey account does not exist.
   *
   * # Detailed Explanation of Checks:
   * 1. **Signature Verification**: Ensures that the caller has signed the transaction, verifying the coldkey.
   * 2. **Root Network Check**: Ensures that the delegation is not on the root network, as child hotkeys are not valid on the root.
   * 3. **Network Existence Check**: Ensures that the specified network exists.
   * 4. **Ownership Verification**: Ensures that the coldkey owns the hotkey.
   * 5. **Hotkey Account Existence Check**: Ensures that the hotkey account already exists.
   * 6. **Child-Hotkey Distinction**: Ensures that the child is not the same as the hotkey.
   * 7. **Old Children Cleanup**: Removes the hotkey from the parent list of its old children.
   * 8. **New Children Assignment**: Assigns the new child to the hotkey and updates the parent list for the new child.
   **/
  | {
      name: "SetChildren";
      params: {
        hotkey: AccountId32Like;
        netuid: number;
        children: Array<[bigint, AccountId32Like]>;
      };
    }
  /**
   * Schedules a coldkey swap operation to be executed at a future block.
   *
   * This function allows a user to schedule the swapping of their coldkey to a new one
   * at a specified future block. The swap is not executed immediately but is scheduled
   * to occur at the specified block number.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, which should be signed by the current coldkey owner.
   * * `new_coldkey` - The account ID of the new coldkey that will replace the current one.
   * * `when` - The block number at which the coldkey swap should be executed.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating whether the scheduling was successful.
   *
   * # Errors
   *
   * This function may return an error if:
   * * The origin is not signed.
   * * The scheduling fails due to conflicts or system constraints.
   *
   * # Notes
   *
   * - The actual swap is not performed by this function. It merely schedules the swap operation.
   * - The weight of this call is set to a fixed value and may need adjustment based on benchmarking.
   *
   * # TODO
   *
   * - Implement proper weight calculation based on the complexity of the operation.
   * - Consider adding checks to prevent scheduling too far into the future.
   * TODO: Benchmark this call
   **/
  | { name: "ScheduleSwapColdkey"; params: { newColdkey: AccountId32Like } }
  /**
   * Schedule the dissolution of a network at a specified block number.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, must be signed by the sender.
   * * `netuid` - The u16 network identifier to be dissolved.
   *
   * # Returns
   *
   * Returns a `DispatchResultWithPostInfo` indicating success or failure of the operation.
   *
   * # Weight
   *
   * Weight is calculated based on the number of database reads and writes.
   **/
  | { name: "ScheduleDissolveNetwork"; params: { netuid: number } }
  /**
   * ---- Set prometheus information for the neuron.
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the calling hotkey.
   *
   * * 'netuid' (u16):
   * - The u16 network identifier.
   *
   * * 'version' (u16):
   * - The bittensor version identifier.
   *
   * * 'ip' (u128):
   * - The prometheus ip information as a u128 encoded integer.
   *
   * * 'port' (u16):
   * - The prometheus port information as a u16 encoded integer.
   *
   * * 'ip_type' (u8):
   * - The ip type v4 or v6.
   *
   **/
  | {
      name: "SetIdentity";
      params: {
        name: BytesLike;
        url: BytesLike;
        githubRepo: BytesLike;
        image: BytesLike;
        discord: BytesLike;
        description: BytesLike;
        additional: BytesLike;
      };
    }
  /**
   * ---- Set the identity information for a subnet.
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the calling coldkey, which must be the owner of the subnet.
   *
   * * `netuid` (u16):
   * - The unique network identifier of the subnet.
   *
   * * `subnet_name` (Vec<u8>):
   * - The name of the subnet.
   *
   * * `github_repo` (Vec<u8>):
   * - The GitHub repository associated with the subnet identity.
   *
   * * `subnet_contact` (Vec<u8>):
   * - The contact information for the subnet.
   **/
  | {
      name: "SetSubnetIdentity";
      params: {
        netuid: number;
        subnetName: BytesLike;
        githubRepo: BytesLike;
        subnetContact: BytesLike;
        subnetUrl: BytesLike;
        discord: BytesLike;
        description: BytesLike;
        additional: BytesLike;
      };
    }
  /**
   * User register a new subnetwork
   **/
  | {
      name: "RegisterNetworkWithIdentity";
      params: {
        hotkey: AccountId32Like;
        identity?: PalletSubtensorSubnetIdentityV2 | undefined;
      };
    }
  /**
   * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The associated hotkey account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * `NotRegistered`:
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * `NonAssociatedColdKey`:
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * `NotEnoughStakeToWithdraw`:
   * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
   *
   * * `TxRateLimitExceeded`:
   * - Thrown if key has hit transaction rate limit
   **/
  | { name: "UnstakeAll"; params: { hotkey: AccountId32Like } }
  /**
   * ---- The implementation for the extrinsic unstake_all: Removes all stake from a hotkey account across all subnets and adds it onto a coldkey.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `hotkey` (T::AccountId):
   * - The associated hotkey account.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * `NotRegistered`:
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * `NonAssociatedColdKey`:
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * `NotEnoughStakeToWithdraw`:
   * - Thrown if there is not enough stake on the hotkey to withdraw this amount.
   *
   * * `TxRateLimitExceeded`:
   * - Thrown if key has hit transaction rate limit
   **/
  | { name: "UnstakeAllAlpha"; params: { hotkey: AccountId32Like } }
  /**
   * ---- The implementation for the extrinsic move_stake: Moves specified amount of stake from a hotkey to another across subnets.
   *
   * # Args:
   * * `origin` - (<T as frame_system::Config>::Origin):
   * - The signature of the caller's coldkey.
   *
   * * `origin_hotkey` (T::AccountId):
   * - The hotkey account to move stake from.
   *
   * * `destination_hotkey` (T::AccountId):
   * - The hotkey account to move stake to.
   *
   * * `origin_netuid` (T::AccountId):
   * - The subnet ID to move stake from.
   *
   * * `destination_netuid` (T::AccountId):
   * - The subnet ID to move stake to.
   *
   * * `alpha_amount` (T::AccountId):
   * - The alpha stake amount to move.
   *
   **/
  | {
      name: "MoveStake";
      params: {
        originHotkey: AccountId32Like;
        destinationHotkey: AccountId32Like;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * Transfers a specified amount of stake from one coldkey to another, optionally across subnets,
   * while keeping the same hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the `origin_coldkey`.
   * * `destination_coldkey` - The coldkey to which the stake is transferred.
   * * `hotkey` - The hotkey associated with the stake.
   * * `origin_netuid` - The network/subnet ID to move stake from.
   * * `destination_netuid` - The network/subnet ID to move stake to (for cross-subnet transfer).
   * * `alpha_amount` - The amount of stake to transfer.
   *
   * # Errors
   * Returns an error if:
   * * The origin is not signed by the correct coldkey.
   * * Either subnet does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(origin_coldkey, hotkey, origin_netuid)`.
   * * The transfer amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeTransferred` event on success.
   **/
  | {
      name: "TransferStake";
      params: {
        destinationColdkey: AccountId32Like;
        hotkey: AccountId32Like;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey whose stake is being swapped.
   * * `origin_netuid` - The network/subnet ID from which stake is removed.
   * * `destination_netuid` - The network/subnet ID to which stake is added.
   * * `alpha_amount` - The amount of stake to swap.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
   * * Either `origin_netuid` or `destination_netuid` does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
   * * The swap amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeSwapped` event on success.
   **/
  | {
      name: "SwapStake";
      params: {
        hotkey: AccountId32Like;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
      };
    }
  /**
   * --- Adds stake to a hotkey on a subnet with a price limit.
   * This extrinsic allows to specify the limit price for alpha token
   * at which or better (lower) the staking should execute.
   *
   * In case if slippage occurs and the price shall move beyond the limit
   * price, the staking order may execute only partially or not execute
   * at all.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_staked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * * 'limit_price' (u64):
   * - The limit price expressed in units of RAO per one Alpha.
   *
   * * 'allow_partial' (bool):
   * - Allows partial execution of the amount. If set to false, this becomes
   * fill or kill type or order.
   *
   * # Event:
   * * StakeAdded;
   * - On the successfully adding stake to a global account.
   *
   * # Raises:
   * * 'NotEnoughBalanceToStake':
   * - Not enough balance on the coldkey to add onto the global account.
   *
   * * 'NonAssociatedColdKey':
   * - The calling coldkey is not associated with this hotkey.
   *
   * * 'BalanceWithdrawalError':
   * - Errors stemming from transaction pallet.
   *
   **/
  | {
      name: "AddStakeLimit";
      params: {
        hotkey: AccountId32Like;
        netuid: number;
        amountStaked: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * --- Removes stake from a hotkey on a subnet with a price limit.
   * This extrinsic allows to specify the limit price for alpha token
   * at which or better (higher) the staking should execute.
   *
   * In case if slippage occurs and the price shall move beyond the limit
   * price, the staking order may execute only partially or not execute
   * at all.
   *
   * # Args:
   * * 'origin': (<T as frame_system::Config>Origin):
   * - The signature of the caller's coldkey.
   *
   * * 'hotkey' (T::AccountId):
   * - The associated hotkey account.
   *
   * * 'netuid' (u16):
   * - Subnetwork UID
   *
   * * 'amount_unstaked' (u64):
   * - The amount of stake to be added to the hotkey staking account.
   *
   * * 'limit_price' (u64):
   * - The limit price expressed in units of RAO per one Alpha.
   *
   * * 'allow_partial' (bool):
   * - Allows partial execution of the amount. If set to false, this becomes
   * fill or kill type or order.
   *
   * # Event:
   * * StakeRemoved;
   * - On the successfully removing stake from the hotkey account.
   *
   * # Raises:
   * * 'NotRegistered':
   * - Thrown if the account we are attempting to unstake from is non existent.
   *
   * * 'NonAssociatedColdKey':
   * - Thrown if the coldkey does not own the hotkey we are unstaking from.
   *
   * * 'NotEnoughStakeToWithdraw':
   * - Thrown if there is not enough stake on the hotkey to withdwraw this amount.
   *
   **/
  | {
      name: "RemoveStakeLimit";
      params: {
        hotkey: AccountId32Like;
        netuid: number;
        amountUnstaked: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * Swaps a specified amount of stake from one subnet to another, while keeping the same coldkey and hotkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey whose stake is being swapped.
   * * `origin_netuid` - The network/subnet ID from which stake is removed.
   * * `destination_netuid` - The network/subnet ID to which stake is added.
   * * `alpha_amount` - The amount of stake to swap.
   * * `limit_price` - The limit price expressed in units of RAO per one Alpha.
   * * `allow_partial` - Allows partial execution of the amount. If set to false, this becomes fill or kill type or order.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed by the correct coldkey (i.e., `coldkey_owns_hotkey` fails).
   * * Either `origin_netuid` or `destination_netuid` does not exist.
   * * The hotkey does not exist.
   * * There is insufficient stake on `(coldkey, hotkey, origin_netuid)`.
   * * The swap amount is below the minimum stake requirement.
   *
   * # Events
   * May emit a `StakeSwapped` event on success.
   **/
  | {
      name: "SwapStakeLimit";
      params: {
        hotkey: AccountId32Like;
        originNetuid: number;
        destinationNetuid: number;
        alphaAmount: bigint;
        limitPrice: bigint;
        allowPartial: boolean;
      };
    }
  /**
   * Attempts to associate a hotkey with a coldkey.
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `hotkey` - The hotkey to associate with the coldkey.
   *
   * # Note
   * Will charge based on the weight even if the hotkey is already associated with a coldkey.
   **/
  | { name: "TryAssociateHotkey"; params: { hotkey: AccountId32Like } }
  /**
   * Initiates a call on a subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be signed by the subnet owner.
   * * `netuid` - The unique identifier of the subnet on which the call is being initiated.
   *
   * # Events
   * Emits a `FirstEmissionBlockNumberSet` event on success.
   **/
  | { name: "StartCall"; params: { netuid: number } }
  /**
   * Attempts to associate a hotkey with an EVM key.
   *
   * The signature will be checked to see if the recovered public key matches the `evm_key` provided.
   *
   * The EVM key is expected to sign the message according to this formula to produce the signature:
   * ```text
   * keccak_256(hotkey ++ keccak_256(block_number))
   * ```
   *
   * # Arguments
   * * `origin` - The origin of the transaction, which must be signed by the coldkey that owns the `hotkey`.
   * * `netuid` - The netuid that the `hotkey` belongs to.
   * * `hotkey` - The hotkey associated with the `origin`.
   * * `evm_key` - The EVM key to associate with the `hotkey`.
   * * `block_number` - The block number used in the `signature`.
   * * `signature` - A signed message by the `evm_key` containing the `hotkey` and the hashed `block_number`.
   *
   * # Errors
   * Returns an error if:
   * * The transaction is not signed.
   * * The hotkey is not owned by the origin coldkey.
   * * The hotkey does not belong to the subnet identified by the netuid.
   * * The EVM key cannot be recovered from the signature.
   * * The EVM key recovered from the signature does not match the given EVM key.
   *
   * # Events
   * May emit a `EvmKeyAssociated` event on success
   **/
  | {
      name: "AssociateEvmKey";
      params: {
        netuid: number;
        hotkey: AccountId32Like;
        evmKey: H160;
        blockNumber: bigint;
        signature: FixedBytes<65>;
      };
    }
  /**
   * Recycles alpha from a cold/hot key pair, reducing AlphaOut on a subnet
   *
   * # Arguments
   * * `origin` - The origin of the call (must be signed by the coldkey)
   * * `hotkey` - The hotkey account
   * * `amount` - The amount of alpha to recycle
   * * `netuid` - The subnet ID
   *
   * # Events
   * Emits a `TokensRecycled` event on success.
   **/
  | {
      name: "RecycleAlpha";
      params: { hotkey: AccountId32Like; amount: bigint; netuid: number };
    }
  /**
   * Burns alpha from a cold/hot key pair without reducing `AlphaOut`
   *
   * # Arguments
   * * `origin` - The origin of the call (must be signed by the coldkey)
   * * `hotkey` - The hotkey account
   * * `amount` - The amount of alpha to burn
   * * `netuid` - The subnet ID
   *
   * # Events
   * Emits a `TokensBurned` event on success.
   **/
  | {
      name: "BurnAlpha";
      params: { hotkey: AccountId32Like; amount: bigint; netuid: number };
    }
  /**
   * Sets the pending childkey cooldown (in blocks). Root only.
   **/
  | { name: "SetPendingChildkeyCooldown"; params: { cooldown: bigint } };

export type NodeSubtensorRuntimeRuntimeCall =
  | { pallet: "System"; palletCall: FrameSystemCall }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCall }
  | { pallet: "Grandpa"; palletCall: PalletGrandpaCall }
  | { pallet: "Balances"; palletCall: PalletBalancesCall }
  | { pallet: "SubtensorModule"; palletCall: PalletSubtensorCall }
  | { pallet: "Triumvirate"; palletCall: PalletCollectiveCall }
  | { pallet: "TriumvirateMembers"; palletCall: PalletMembershipCall }
  | { pallet: "SenateMembers"; palletCall: PalletMembershipCall }
  | { pallet: "Utility"; palletCall: PalletUtilityCall }
  | { pallet: "Sudo"; palletCall: PalletSudoCall }
  | { pallet: "Multisig"; palletCall: PalletMultisigCall }
  | { pallet: "Preimage"; palletCall: PalletPreimageCall }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCall }
  | { pallet: "Proxy"; palletCall: PalletProxyCall }
  | { pallet: "Registry"; palletCall: PalletRegistryCall }
  | { pallet: "Commitments"; palletCall: PalletCommitmentsCall }
  | { pallet: "AdminUtils"; palletCall: PalletAdminUtilsCall }
  | { pallet: "SafeMode"; palletCall: PalletSafeModeCall }
  | { pallet: "Ethereum"; palletCall: PalletEthereumCall }
  | { pallet: "Evm"; palletCall: PalletEvmCall }
  | { pallet: "BaseFee"; palletCall: PalletBaseFeeCall }
  | { pallet: "Drand"; palletCall: PalletDrandCall }
  | { pallet: "Crowdloan"; palletCall: PalletCrowdloanCall };

export type NodeSubtensorRuntimeRuntimeCallLike =
  | { pallet: "System"; palletCall: FrameSystemCallLike }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCallLike }
  | { pallet: "Grandpa"; palletCall: PalletGrandpaCallLike }
  | { pallet: "Balances"; palletCall: PalletBalancesCallLike }
  | { pallet: "SubtensorModule"; palletCall: PalletSubtensorCallLike }
  | { pallet: "Triumvirate"; palletCall: PalletCollectiveCallLike }
  | { pallet: "TriumvirateMembers"; palletCall: PalletMembershipCallLike }
  | { pallet: "SenateMembers"; palletCall: PalletMembershipCallLike }
  | { pallet: "Utility"; palletCall: PalletUtilityCallLike }
  | { pallet: "Sudo"; palletCall: PalletSudoCallLike }
  | { pallet: "Multisig"; palletCall: PalletMultisigCallLike }
  | { pallet: "Preimage"; palletCall: PalletPreimageCallLike }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCallLike }
  | { pallet: "Proxy"; palletCall: PalletProxyCallLike }
  | { pallet: "Registry"; palletCall: PalletRegistryCallLike }
  | { pallet: "Commitments"; palletCall: PalletCommitmentsCallLike }
  | { pallet: "AdminUtils"; palletCall: PalletAdminUtilsCallLike }
  | { pallet: "SafeMode"; palletCall: PalletSafeModeCallLike }
  | { pallet: "Ethereum"; palletCall: PalletEthereumCallLike }
  | { pallet: "Evm"; palletCall: PalletEvmCallLike }
  | { pallet: "BaseFee"; palletCall: PalletBaseFeeCallLike }
  | { pallet: "Drand"; palletCall: PalletDrandCallLike }
  | { pallet: "Crowdloan"; palletCall: PalletCrowdloanCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32>;
        prime?: AccountId32 | undefined;
        oldCount: number;
      };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | {
      name: "Execute";
      params: {
        proposal: NodeSubtensorRuntimeRuntimeCall;
        lengthBound: number;
      };
    }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | {
      name: "Propose";
      params: {
        proposal: NodeSubtensorRuntimeRuntimeCall;
        lengthBound: number;
        duration: number;
      };
    }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    };

export type PalletCollectiveCallLike =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32Like>;
        prime?: AccountId32Like | undefined;
        oldCount: number;
      };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | {
      name: "Execute";
      params: {
        proposal: NodeSubtensorRuntimeRuntimeCallLike;
        lengthBound: number;
      };
    }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | {
      name: "Propose";
      params: {
        proposal: NodeSubtensorRuntimeRuntimeCallLike;
        lengthBound: number;
        duration: number;
      };
    }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: "AddMember"; params: { who: MultiAddress } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: "RemoveMember"; params: { who: MultiAddress } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | { name: "SwapMember"; params: { remove: MultiAddress; add: MultiAddress } }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: "ResetMembers"; params: { members: Array<AccountId32> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: "ChangeKey"; params: { new: MultiAddress } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "SetPrime"; params: { who: MultiAddress } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "ClearPrime" };

export type PalletMembershipCallLike =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: "AddMember"; params: { who: MultiAddressLike } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: "RemoveMember"; params: { who: MultiAddressLike } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | {
      name: "SwapMember";
      params: { remove: MultiAddressLike; add: MultiAddressLike };
    }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: "ResetMembers"; params: { members: Array<AccountId32Like> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: "ChangeKey"; params: { new: MultiAddressLike } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "SetPrime"; params: { who: MultiAddressLike } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "ClearPrime" };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: "Batch"; params: { calls: Array<NodeSubtensorRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: NodeSubtensorRuntimeRuntimeCall };
    }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "BatchAll";
      params: { calls: Array<NodeSubtensorRuntimeRuntimeCall> };
    }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "DispatchAs";
      params: {
        asOrigin: NodeSubtensorRuntimeOriginCaller;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "ForceBatch";
      params: { calls: Array<NodeSubtensorRuntimeRuntimeCall> };
    }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | {
      name: "WithWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCall;
        weight: SpWeightsWeightV2Weight;
      };
    };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | {
      name: "Batch";
      params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
    }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: NodeSubtensorRuntimeRuntimeCallLike };
    }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "BatchAll";
      params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "DispatchAs";
      params: {
        asOrigin: NodeSubtensorRuntimeOriginCaller;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "ForceBatch";
      params: { calls: Array<NodeSubtensorRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | {
      name: "WithWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    };

export type NodeSubtensorRuntimeOriginCaller =
  | { type: "System"; value: FrameSupportDispatchRawOrigin }
  | { type: "Triumvirate"; value: PalletCollectiveRawOrigin }
  | { type: "Ethereum"; value: PalletEthereumRawOrigin };

export type FrameSupportDispatchRawOrigin =
  | { type: "Root" }
  | { type: "Signed"; value: AccountId32 }
  | { type: "None" };

export type PalletCollectiveRawOrigin =
  | { type: "Members"; value: [number, number] }
  | { type: "Member"; value: AccountId32 }
  | { type: "Phantom" };

export type PalletEthereumRawOrigin = {
  type: "EthereumTransaction";
  value: H160;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: "Sudo"; params: { call: NodeSubtensorRuntimeRuntimeCall } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "SudoUncheckedWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCall;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: "SetKey"; params: { new: MultiAddress } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "SudoAs";
      params: { who: MultiAddress; call: NodeSubtensorRuntimeRuntimeCall };
    }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: "RemoveKey" };

export type PalletSudoCallLike =
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   **/
  | { name: "Sudo"; params: { call: NodeSubtensorRuntimeRuntimeCallLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Root` origin.
   * This function does not check the weight of the call, and instead allows the
   * Sudo user to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "SudoUncheckedWeight";
      params: {
        call: NodeSubtensorRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo
   * key.
   **/
  | { name: "SetKey"; params: { new: MultiAddressLike } }
  /**
   * Authenticates the sudo key and dispatches a function call with `Signed` origin from
   * a given account.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "SudoAs";
      params: {
        who: MultiAddressLike;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Permanently removes the sudo key.
   *
   * **This cannot be un-done.**
   **/
  | { name: "RemoveKey" };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32>;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: NodeSubtensorRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32Like>;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: NodeSubtensorRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: "NotePreimage"; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: "NotePreimage"; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetry";
      params: { task: [number, number]; retries: number; period: number };
    }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetryNamed";
      params: { id: FixedBytes<32>; retries: number; period: number };
    }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: "CancelRetry"; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: "CancelRetryNamed"; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetry";
      params: { task: [number, number]; retries: number; period: number };
    }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetryNamed";
      params: { id: FixedBytes<32>; retries: number; period: number };
    }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: "CancelRetry"; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: "CancelRetryNamed"; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddress;
        forceProxyType?: SubtensorRuntimeCommonProxyType | undefined;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddress;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddress;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: "RemoveProxies" }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddress;
        proxyType: SubtensorRuntimeCommonProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: "Announce"; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddress; callHash: H256 };
    }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddress; callHash: H256 };
    }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: SubtensorRuntimeCommonProxyType | undefined;
        call: NodeSubtensorRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddressLike;
        forceProxyType?: SubtensorRuntimeCommonProxyType | undefined;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
      };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: "RemoveProxies" }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: SubtensorRuntimeCommonProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddressLike;
        proxyType: SubtensorRuntimeCommonProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: "Announce"; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddressLike; callHash: H256 };
    }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddressLike; callHash: H256 };
    }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: SubtensorRuntimeCommonProxyType | undefined;
        call: NodeSubtensorRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRegistryCall =
  /**
   * Register an identity for an account. This will overwrite any existing identity.
   **/
  | {
      name: "SetIdentity";
      params: { identified: AccountId32; info: PalletRegistryIdentityInfo };
    }
  /**
   * Clear the identity of an account.
   **/
  | { name: "ClearIdentity"; params: { identified: AccountId32 } };

export type PalletRegistryCallLike =
  /**
   * Register an identity for an account. This will overwrite any existing identity.
   **/
  | {
      name: "SetIdentity";
      params: { identified: AccountId32Like; info: PalletRegistryIdentityInfo };
    }
  /**
   * Clear the identity of an account.
   **/
  | { name: "ClearIdentity"; params: { identified: AccountId32Like } };

export type PalletRegistryIdentityInfo = {
  additional: Array<[PalletRegistryData, PalletRegistryData]>;
  display: PalletRegistryData;
  legal: PalletRegistryData;
  web: PalletRegistryData;
  riot: PalletRegistryData;
  email: PalletRegistryData;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: PalletRegistryData;
  twitter: PalletRegistryData;
};

export type PalletRegistryData =
  | { type: "None" }
  | { type: "Raw0"; value: FixedBytes<0> }
  | { type: "Raw1"; value: FixedBytes<1> }
  | { type: "Raw2"; value: FixedBytes<2> }
  | { type: "Raw3"; value: FixedBytes<3> }
  | { type: "Raw4"; value: FixedBytes<4> }
  | { type: "Raw5"; value: FixedBytes<5> }
  | { type: "Raw6"; value: FixedBytes<6> }
  | { type: "Raw7"; value: FixedBytes<7> }
  | { type: "Raw8"; value: FixedBytes<8> }
  | { type: "Raw9"; value: FixedBytes<9> }
  | { type: "Raw10"; value: FixedBytes<10> }
  | { type: "Raw11"; value: FixedBytes<11> }
  | { type: "Raw12"; value: FixedBytes<12> }
  | { type: "Raw13"; value: FixedBytes<13> }
  | { type: "Raw14"; value: FixedBytes<14> }
  | { type: "Raw15"; value: FixedBytes<15> }
  | { type: "Raw16"; value: FixedBytes<16> }
  | { type: "Raw17"; value: FixedBytes<17> }
  | { type: "Raw18"; value: FixedBytes<18> }
  | { type: "Raw19"; value: FixedBytes<19> }
  | { type: "Raw20"; value: FixedBytes<20> }
  | { type: "Raw21"; value: FixedBytes<21> }
  | { type: "Raw22"; value: FixedBytes<22> }
  | { type: "Raw23"; value: FixedBytes<23> }
  | { type: "Raw24"; value: FixedBytes<24> }
  | { type: "Raw25"; value: FixedBytes<25> }
  | { type: "Raw26"; value: FixedBytes<26> }
  | { type: "Raw27"; value: FixedBytes<27> }
  | { type: "Raw28"; value: FixedBytes<28> }
  | { type: "Raw29"; value: FixedBytes<29> }
  | { type: "Raw30"; value: FixedBytes<30> }
  | { type: "Raw31"; value: FixedBytes<31> }
  | { type: "Raw32"; value: FixedBytes<32> }
  | { type: "Raw33"; value: FixedBytes<33> }
  | { type: "Raw34"; value: FixedBytes<34> }
  | { type: "Raw35"; value: FixedBytes<35> }
  | { type: "Raw36"; value: FixedBytes<36> }
  | { type: "Raw37"; value: FixedBytes<37> }
  | { type: "Raw38"; value: FixedBytes<38> }
  | { type: "Raw39"; value: FixedBytes<39> }
  | { type: "Raw40"; value: FixedBytes<40> }
  | { type: "Raw41"; value: FixedBytes<41> }
  | { type: "Raw42"; value: FixedBytes<42> }
  | { type: "Raw43"; value: FixedBytes<43> }
  | { type: "Raw44"; value: FixedBytes<44> }
  | { type: "Raw45"; value: FixedBytes<45> }
  | { type: "Raw46"; value: FixedBytes<46> }
  | { type: "Raw47"; value: FixedBytes<47> }
  | { type: "Raw48"; value: FixedBytes<48> }
  | { type: "Raw49"; value: FixedBytes<49> }
  | { type: "Raw50"; value: FixedBytes<50> }
  | { type: "Raw51"; value: FixedBytes<51> }
  | { type: "Raw52"; value: FixedBytes<52> }
  | { type: "Raw53"; value: FixedBytes<53> }
  | { type: "Raw54"; value: FixedBytes<54> }
  | { type: "Raw55"; value: FixedBytes<55> }
  | { type: "Raw56"; value: FixedBytes<56> }
  | { type: "Raw57"; value: FixedBytes<57> }
  | { type: "Raw58"; value: FixedBytes<58> }
  | { type: "Raw59"; value: FixedBytes<59> }
  | { type: "Raw60"; value: FixedBytes<60> }
  | { type: "Raw61"; value: FixedBytes<61> }
  | { type: "Raw62"; value: FixedBytes<62> }
  | { type: "Raw63"; value: FixedBytes<63> }
  | { type: "Raw64"; value: FixedBytes<64> }
  | { type: "BlakeTwo256"; value: FixedBytes<32> }
  | { type: "Sha256"; value: FixedBytes<32> }
  | { type: "Keccak256"; value: FixedBytes<32> }
  | { type: "ShaThree256"; value: FixedBytes<32> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCommitmentsCall =
  /**
   * Set the commitment for a given netuid
   **/
  | {
      name: "SetCommitment";
      params: { netuid: number; info: PalletCommitmentsCommitmentInfo };
    }
  /**
   * *DEPRECATED* Sudo-set the commitment rate limit
   **/
  | { name: "SetRateLimit"; params: { rateLimitBlocks: number } }
  /**
   * Sudo-set MaxSpace
   **/
  | { name: "SetMaxSpace"; params: { newLimit: number } };

export type PalletCommitmentsCallLike =
  /**
   * Set the commitment for a given netuid
   **/
  | {
      name: "SetCommitment";
      params: { netuid: number; info: PalletCommitmentsCommitmentInfo };
    }
  /**
   * *DEPRECATED* Sudo-set the commitment rate limit
   **/
  | { name: "SetRateLimit"; params: { rateLimitBlocks: number } }
  /**
   * Sudo-set MaxSpace
   **/
  | { name: "SetMaxSpace"; params: { newLimit: number } };

export type PalletCommitmentsCommitmentInfo = {
  fields: Array<PalletCommitmentsData>;
};

export type PalletCommitmentsData =
  | { type: "None" }
  | { type: "Raw0"; value: FixedBytes<0> }
  | { type: "Raw1"; value: FixedBytes<1> }
  | { type: "Raw2"; value: FixedBytes<2> }
  | { type: "Raw3"; value: FixedBytes<3> }
  | { type: "Raw4"; value: FixedBytes<4> }
  | { type: "Raw5"; value: FixedBytes<5> }
  | { type: "Raw6"; value: FixedBytes<6> }
  | { type: "Raw7"; value: FixedBytes<7> }
  | { type: "Raw8"; value: FixedBytes<8> }
  | { type: "Raw9"; value: FixedBytes<9> }
  | { type: "Raw10"; value: FixedBytes<10> }
  | { type: "Raw11"; value: FixedBytes<11> }
  | { type: "Raw12"; value: FixedBytes<12> }
  | { type: "Raw13"; value: FixedBytes<13> }
  | { type: "Raw14"; value: FixedBytes<14> }
  | { type: "Raw15"; value: FixedBytes<15> }
  | { type: "Raw16"; value: FixedBytes<16> }
  | { type: "Raw17"; value: FixedBytes<17> }
  | { type: "Raw18"; value: FixedBytes<18> }
  | { type: "Raw19"; value: FixedBytes<19> }
  | { type: "Raw20"; value: FixedBytes<20> }
  | { type: "Raw21"; value: FixedBytes<21> }
  | { type: "Raw22"; value: FixedBytes<22> }
  | { type: "Raw23"; value: FixedBytes<23> }
  | { type: "Raw24"; value: FixedBytes<24> }
  | { type: "Raw25"; value: FixedBytes<25> }
  | { type: "Raw26"; value: FixedBytes<26> }
  | { type: "Raw27"; value: FixedBytes<27> }
  | { type: "Raw28"; value: FixedBytes<28> }
  | { type: "Raw29"; value: FixedBytes<29> }
  | { type: "Raw30"; value: FixedBytes<30> }
  | { type: "Raw31"; value: FixedBytes<31> }
  | { type: "Raw32"; value: FixedBytes<32> }
  | { type: "Raw33"; value: FixedBytes<33> }
  | { type: "Raw34"; value: FixedBytes<34> }
  | { type: "Raw35"; value: FixedBytes<35> }
  | { type: "Raw36"; value: FixedBytes<36> }
  | { type: "Raw37"; value: FixedBytes<37> }
  | { type: "Raw38"; value: FixedBytes<38> }
  | { type: "Raw39"; value: FixedBytes<39> }
  | { type: "Raw40"; value: FixedBytes<40> }
  | { type: "Raw41"; value: FixedBytes<41> }
  | { type: "Raw42"; value: FixedBytes<42> }
  | { type: "Raw43"; value: FixedBytes<43> }
  | { type: "Raw44"; value: FixedBytes<44> }
  | { type: "Raw45"; value: FixedBytes<45> }
  | { type: "Raw46"; value: FixedBytes<46> }
  | { type: "Raw47"; value: FixedBytes<47> }
  | { type: "Raw48"; value: FixedBytes<48> }
  | { type: "Raw49"; value: FixedBytes<49> }
  | { type: "Raw50"; value: FixedBytes<50> }
  | { type: "Raw51"; value: FixedBytes<51> }
  | { type: "Raw52"; value: FixedBytes<52> }
  | { type: "Raw53"; value: FixedBytes<53> }
  | { type: "Raw54"; value: FixedBytes<54> }
  | { type: "Raw55"; value: FixedBytes<55> }
  | { type: "Raw56"; value: FixedBytes<56> }
  | { type: "Raw57"; value: FixedBytes<57> }
  | { type: "Raw58"; value: FixedBytes<58> }
  | { type: "Raw59"; value: FixedBytes<59> }
  | { type: "Raw60"; value: FixedBytes<60> }
  | { type: "Raw61"; value: FixedBytes<61> }
  | { type: "Raw62"; value: FixedBytes<62> }
  | { type: "Raw63"; value: FixedBytes<63> }
  | { type: "Raw64"; value: FixedBytes<64> }
  | { type: "Raw65"; value: FixedBytes<65> }
  | { type: "Raw66"; value: FixedBytes<66> }
  | { type: "Raw67"; value: FixedBytes<67> }
  | { type: "Raw68"; value: FixedBytes<68> }
  | { type: "Raw69"; value: FixedBytes<69> }
  | { type: "Raw70"; value: FixedBytes<70> }
  | { type: "Raw71"; value: FixedBytes<71> }
  | { type: "Raw72"; value: FixedBytes<72> }
  | { type: "Raw73"; value: FixedBytes<73> }
  | { type: "Raw74"; value: FixedBytes<74> }
  | { type: "Raw75"; value: FixedBytes<75> }
  | { type: "Raw76"; value: FixedBytes<76> }
  | { type: "Raw77"; value: FixedBytes<77> }
  | { type: "Raw78"; value: FixedBytes<78> }
  | { type: "Raw79"; value: FixedBytes<79> }
  | { type: "Raw80"; value: FixedBytes<80> }
  | { type: "Raw81"; value: FixedBytes<81> }
  | { type: "Raw82"; value: FixedBytes<82> }
  | { type: "Raw83"; value: FixedBytes<83> }
  | { type: "Raw84"; value: FixedBytes<84> }
  | { type: "Raw85"; value: FixedBytes<85> }
  | { type: "Raw86"; value: FixedBytes<86> }
  | { type: "Raw87"; value: FixedBytes<87> }
  | { type: "Raw88"; value: FixedBytes<88> }
  | { type: "Raw89"; value: FixedBytes<89> }
  | { type: "Raw90"; value: FixedBytes<90> }
  | { type: "Raw91"; value: FixedBytes<91> }
  | { type: "Raw92"; value: FixedBytes<92> }
  | { type: "Raw93"; value: FixedBytes<93> }
  | { type: "Raw94"; value: FixedBytes<94> }
  | { type: "Raw95"; value: FixedBytes<95> }
  | { type: "Raw96"; value: FixedBytes<96> }
  | { type: "Raw97"; value: FixedBytes<97> }
  | { type: "Raw98"; value: FixedBytes<98> }
  | { type: "Raw99"; value: FixedBytes<99> }
  | { type: "Raw100"; value: FixedBytes<100> }
  | { type: "Raw101"; value: FixedBytes<101> }
  | { type: "Raw102"; value: FixedBytes<102> }
  | { type: "Raw103"; value: FixedBytes<103> }
  | { type: "Raw104"; value: FixedBytes<104> }
  | { type: "Raw105"; value: FixedBytes<105> }
  | { type: "Raw106"; value: FixedBytes<106> }
  | { type: "Raw107"; value: FixedBytes<107> }
  | { type: "Raw108"; value: FixedBytes<108> }
  | { type: "Raw109"; value: FixedBytes<109> }
  | { type: "Raw110"; value: FixedBytes<110> }
  | { type: "Raw111"; value: FixedBytes<111> }
  | { type: "Raw112"; value: FixedBytes<112> }
  | { type: "Raw113"; value: FixedBytes<113> }
  | { type: "Raw114"; value: FixedBytes<114> }
  | { type: "Raw115"; value: FixedBytes<115> }
  | { type: "Raw116"; value: FixedBytes<116> }
  | { type: "Raw117"; value: FixedBytes<117> }
  | { type: "Raw118"; value: FixedBytes<118> }
  | { type: "Raw119"; value: FixedBytes<119> }
  | { type: "Raw120"; value: FixedBytes<120> }
  | { type: "Raw121"; value: FixedBytes<121> }
  | { type: "Raw122"; value: FixedBytes<122> }
  | { type: "Raw123"; value: FixedBytes<123> }
  | { type: "Raw124"; value: FixedBytes<124> }
  | { type: "Raw125"; value: FixedBytes<125> }
  | { type: "Raw126"; value: FixedBytes<126> }
  | { type: "Raw127"; value: FixedBytes<127> }
  | { type: "Raw128"; value: FixedBytes<128> }
  | { type: "BlakeTwo256"; value: FixedBytes<32> }
  | { type: "Sha256"; value: FixedBytes<32> }
  | { type: "Keccak256"; value: FixedBytes<32> }
  | { type: "ShaThree256"; value: FixedBytes<32> }
  | {
      type: "TimelockEncrypted";
      value: { encrypted: Bytes; revealRound: bigint };
    }
  | { type: "ResetBondsFlag" }
  | { type: "BigRaw"; value: Bytes };

/**
 * Dispatchable functions allows users to interact with the pallet and invoke state changes.
 **/
export type PalletAdminUtilsCall =
  /**
   * The extrinsic sets the new authorities for Aura consensus.
   * It is only callable by the root account.
   * The extrinsic will call the Aura pallet to change the authorities.
   **/
  | {
      name: "SwapAuthorities";
      params: { newAuthorities: Array<SpConsensusAuraSr25519AppSr25519Public> };
    }
  /**
   * The extrinsic sets the default take for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the default take.
   **/
  | { name: "SudoSetDefaultTake"; params: { defaultTake: number } }
  /**
   * The extrinsic sets the transaction rate limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the transaction rate limit.
   **/
  | { name: "SudoSetTxRateLimit"; params: { txRateLimit: bigint } }
  /**
   * The extrinsic sets the serving rate limit for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the serving rate limit.
   **/
  | {
      name: "SudoSetServingRateLimit";
      params: { netuid: number; servingRateLimit: bigint };
    }
  /**
   * The extrinsic sets the minimum difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the minimum difficulty.
   **/
  | {
      name: "SudoSetMinDifficulty";
      params: { netuid: number; minDifficulty: bigint };
    }
  /**
   * The extrinsic sets the maximum difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the maximum difficulty.
   **/
  | {
      name: "SudoSetMaxDifficulty";
      params: { netuid: number; maxDifficulty: bigint };
    }
  /**
   * The extrinsic sets the weights version key for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the weights version key.
   **/
  | {
      name: "SudoSetWeightsVersionKey";
      params: { netuid: number; weightsVersionKey: bigint };
    }
  /**
   * The extrinsic sets the weights set rate limit for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the weights set rate limit.
   **/
  | {
      name: "SudoSetWeightsSetRateLimit";
      params: { netuid: number; weightsSetRateLimit: bigint };
    }
  /**
   * The extrinsic sets the adjustment interval for a subnet.
   * It is only callable by the root account, not changeable by the subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment interval.
   **/
  | {
      name: "SudoSetAdjustmentInterval";
      params: { netuid: number; adjustmentInterval: number };
    }
  /**
   * The extrinsic sets the adjustment alpha for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment alpha.
   **/
  | {
      name: "SudoSetAdjustmentAlpha";
      params: { netuid: number; adjustmentAlpha: bigint };
    }
  /**
   * The extrinsic sets the adjustment beta for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment beta.
   **/
  | {
      name: "SudoSetMaxWeightLimit";
      params: { netuid: number; maxWeightLimit: number };
    }
  /**
   * The extrinsic sets the immunity period for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the immunity period.
   **/
  | {
      name: "SudoSetImmunityPeriod";
      params: { netuid: number; immunityPeriod: number };
    }
  /**
   * The extrinsic sets the minimum allowed weights for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the minimum allowed weights.
   **/
  | {
      name: "SudoSetMinAllowedWeights";
      params: { netuid: number; minAllowedWeights: number };
    }
  /**
   * The extrinsic sets the maximum allowed UIDs for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet.
   **/
  | {
      name: "SudoSetMaxAllowedUids";
      params: { netuid: number; maxAllowedUids: number };
    }
  /**
   * The extrinsic sets the kappa for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the kappa.
   **/
  | { name: "SudoSetKappa"; params: { netuid: number; kappa: number } }
  /**
   * The extrinsic sets the rho for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the rho.
   **/
  | { name: "SudoSetRho"; params: { netuid: number; rho: number } }
  /**
   * The extrinsic sets the activity cutoff for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the activity cutoff.
   **/
  | {
      name: "SudoSetActivityCutoff";
      params: { netuid: number; activityCutoff: number };
    }
  /**
   * The extrinsic sets the network registration allowed for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the network registration allowed.
   **/
  | {
      name: "SudoSetNetworkRegistrationAllowed";
      params: { netuid: number; registrationAllowed: boolean };
    }
  /**
   * The extrinsic sets the network PoW registration allowed for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the network PoW registration allowed.
   **/
  | {
      name: "SudoSetNetworkPowRegistrationAllowed";
      params: { netuid: number; registrationAllowed: boolean };
    }
  /**
   * The extrinsic sets the target registrations per interval for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the target registrations per interval.
   **/
  | {
      name: "SudoSetTargetRegistrationsPerInterval";
      params: { netuid: number; targetRegistrationsPerInterval: number };
    }
  /**
   * The extrinsic sets the minimum burn for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum burn.
   **/
  | { name: "SudoSetMinBurn"; params: { netuid: number; minBurn: bigint } }
  /**
   * The extrinsic sets the maximum burn for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the maximum burn.
   **/
  | { name: "SudoSetMaxBurn"; params: { netuid: number; maxBurn: bigint } }
  /**
   * The extrinsic sets the difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the difficulty.
   **/
  | {
      name: "SudoSetDifficulty";
      params: { netuid: number; difficulty: bigint };
    }
  /**
   * The extrinsic sets the maximum allowed validators for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum allowed validators.
   **/
  | {
      name: "SudoSetMaxAllowedValidators";
      params: { netuid: number; maxAllowedValidators: number };
    }
  /**
   * The extrinsic sets the bonds moving average for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the bonds moving average.
   **/
  | {
      name: "SudoSetBondsMovingAverage";
      params: { netuid: number; bondsMovingAverage: bigint };
    }
  /**
   * The extrinsic sets the bonds penalty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the bonds penalty.
   **/
  | {
      name: "SudoSetBondsPenalty";
      params: { netuid: number; bondsPenalty: number };
    }
  /**
   * The extrinsic sets the maximum registrations per block for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum registrations per block.
   **/
  | {
      name: "SudoSetMaxRegistrationsPerBlock";
      params: { netuid: number; maxRegistrationsPerBlock: number };
    }
  /**
   * The extrinsic sets the subnet owner cut for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the subnet owner cut.
   **/
  | { name: "SudoSetSubnetOwnerCut"; params: { subnetOwnerCut: number } }
  /**
   * The extrinsic sets the network rate limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the network rate limit.
   **/
  | { name: "SudoSetNetworkRateLimit"; params: { rateLimit: bigint } }
  /**
   * The extrinsic sets the tempo for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the tempo.
   **/
  | { name: "SudoSetTempo"; params: { netuid: number; tempo: number } }
  /**
   * The extrinsic sets the total issuance for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the issuance for the network.
   **/
  | { name: "SudoSetTotalIssuance"; params: { totalIssuance: bigint } }
  /**
   * The extrinsic sets the immunity period for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the immunity period for the network.
   **/
  | { name: "SudoSetNetworkImmunityPeriod"; params: { immunityPeriod: bigint } }
  /**
   * The extrinsic sets the min lock cost for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the min lock cost for the network.
   **/
  | { name: "SudoSetNetworkMinLockCost"; params: { lockCost: bigint } }
  /**
   * The extrinsic sets the subnet limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the subnet limit.
   **/
  | { name: "SudoSetSubnetLimit"; params: { maxSubnets: number } }
  /**
   * The extrinsic sets the lock reduction interval for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the lock reduction interval.
   **/
  | { name: "SudoSetLockReductionInterval"; params: { interval: bigint } }
  /**
   * The extrinsic sets the recycled RAO for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the recycled RAO.
   **/
  | {
      name: "SudoSetRaoRecycled";
      params: { netuid: number; raoRecycled: bigint };
    }
  /**
   * The extrinsic sets the weights min stake.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the weights min stake.
   **/
  | { name: "SudoSetStakeThreshold"; params: { minStake: bigint } }
  /**
   * The extrinsic sets the minimum stake required for nominators.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators.
   **/
  | { name: "SudoSetNominatorMinRequiredStake"; params: { minStake: bigint } }
  /**
   * The extrinsic sets the rate limit for delegate take transactions.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions.
   **/
  | { name: "SudoSetTxDelegateTakeRateLimit"; params: { txRateLimit: bigint } }
  /**
   * The extrinsic sets the minimum delegate take.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum delegate take.
   **/
  | { name: "SudoSetMinDelegateTake"; params: { take: number } }
  /**
   * The extrinsic enabled/disables commit/reaveal for a given subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the value.
   **/
  | {
      name: "SudoSetCommitRevealWeightsEnabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Enables or disables Liquid Alpha for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetLiquidAlphaEnabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Sets values for liquid alpha
   **/
  | {
      name: "SudoSetAlphaValues";
      params: { netuid: number; alphaLow: number; alphaHigh: number };
    }
  /**
   * Sets the maximum stake allowed for a specific network.
   *
   * This function allows the root account to set the maximum stake for a given network.
   * It updates the network's maximum stake value and logs the change.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier of the network.
   * * `max_stake` - The new maximum stake value to set.
   *
   * # Returns
   *
   * Returns `Ok(())` if the operation is successful, or an error if it fails.
   *
   * # Example
   *
   *
   * # Notes
   *
   * - This function can only be called by the root account.
   * - The `netuid` should correspond to an existing network.
   *
   * # TODO
   *
   **/
  | {
      name: "SudoSetNetworkMaxStake";
      params: { netuid: number; maxStake: bigint };
    }
  /**
   * Sets the duration of the coldkey swap schedule.
   *
   * This extrinsic allows the root account to set the duration for the coldkey swap schedule.
   * The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `duration` - The new duration for the coldkey swap schedule, in number of blocks.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | { name: "SudoSetColdkeySwapScheduleDuration"; params: { duration: number } }
  /**
   * Sets the duration of the dissolve network schedule.
   *
   * This extrinsic allows the root account to set the duration for the dissolve network schedule.
   * The dissolve network schedule determines how long it takes for a network dissolution operation to complete.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `duration` - The new duration for the dissolve network schedule, in number of blocks.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetDissolveNetworkScheduleDuration";
      params: { duration: number };
    }
  /**
   * Sets the commit-reveal weights periods for a specific subnet.
   *
   * This extrinsic allows the subnet owner or root account to set the duration (in epochs) during which committed weights must be revealed.
   * The commit-reveal mechanism ensures that users commit weights in advance and reveal them only within a specified period.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner or the root account.
   * * `netuid` - The unique identifier of the subnet for which the periods are being set.
   * * `periods` - The number of epochs that define the commit-reveal period.
   *
   * # Errors
   * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
   * * `SubnetDoesNotExist` - If the specified subnet does not exist.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetCommitRevealWeightsInterval";
      params: { netuid: number; interval: bigint };
    }
  /**
   * Sets the EVM ChainID.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner or the root account.
   * * `chainId` - The u64 chain ID
   *
   * # Errors
   * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | { name: "SudoSetEvmChainId"; params: { chainId: bigint } }
  /**
   * A public interface for `pallet_grandpa::Pallet::schedule_grandpa_change`.
   *
   * Schedule a change in the authorities.
   *
   * The change will be applied at the end of execution of the block `in_blocks` after the
   * current block. This value may be 0, in which case the change is applied at the end of
   * the current block.
   *
   * If the `forced` parameter is defined, this indicates that the current set has been
   * synchronously determined to be offline and that after `in_blocks` the given change
   * should be applied. The given block number indicates the median last finalized block
   * number and it should be used as the canon block when starting the new grandpa voter.
   *
   * No change should be signaled while any change is pending. Returns an error if a change
   * is already pending.
   **/
  | {
      name: "ScheduleGrandpaChange";
      params: {
        nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
        inBlocks: number;
        forced?: number | undefined;
      };
    }
  /**
   * Enables or disables Liquid Alpha for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetToggleTransfer";
      params: { netuid: number; toggle: boolean };
    }
  /**
   * Toggles the enablement of an EVM precompile.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `precompile_id` - The identifier of the EVM precompile to toggle.
   * * `enabled` - The new enablement state of the precompile.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoToggleEvmPrecompile";
      params: {
        precompileId: PalletAdminUtilsPrecompileEnum;
        enabled: boolean;
      };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `alpha` - The new moving alpha value for the SubnetMovingAlpha.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubnetMovingAlpha";
      params: { alpha: SubstrateFixedFixedI128 };
    }
  /**
   * Change the SubnetOwnerHotkey for a given subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner.
   * * `netuid` - The unique identifier for the subnet.
   * * `hotkey` - The new hotkey for the subnet owner.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the subnet owner or root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubnetOwnerHotkey";
      params: { netuid: number; hotkey: AccountId32 };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `ema_alpha_period` - Number of blocks for EMA price to halve
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetEmaPriceHalvingPeriod";
      params: { netuid: number; emaHalving: bigint };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier for the subnet.
   * * `steepness` - The new steepness for the alpha sigmoid function.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetAlphaSigmoidSteepness";
      params: { netuid: number; steepness: number };
    }
  /**
   * Enables or disables Yuma3 for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Yuma3.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetYuma3Enabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Sets or updates the hotkey account associated with the owner of a specific subnet.
   *
   * This function allows either the root origin or the current subnet owner to set or update
   * the hotkey for a given subnet. The subnet must already exist. To prevent abuse, the call is
   * rate-limited to once per configured interval (default: one week) per subnet.
   *
   * # Parameters
   * - `origin`: The dispatch origin of the call. Must be either root or the current owner of the subnet.
   * - `netuid`: The unique identifier of the subnet whose owner hotkey is being set.
   * - `hotkey`: The new hotkey account to associate with the subnet owner.
   *
   * # Returns
   * - `DispatchResult`: Returns `Ok(())` if the hotkey was successfully set, or an appropriate error otherwise.
   *
   * # Errors
   * - `Error::SubnetNotExists`: If the specified subnet does not exist.
   * - `Error::TxRateLimitExceeded`: If the function is called more frequently than the allowed rate limit.
   *
   * # Access Control
   * Only callable by:
   * - Root origin, or
   * - The coldkey account that owns the subnet.
   *
   * # Storage
   * - Updates [`SubnetOwnerHotkey`] for the given `netuid`.
   * - Reads and updates [`LastRateLimitedBlock`] for rate-limiting.
   * - Reads [`DefaultSetSNOwnerHotkeyRateLimit`] to determine the interval between allowed updates.
   *
   * # Rate Limiting
   * This function is rate-limited to one call per subnet per interval (e.g., one week).
   **/
  | {
      name: "SudoSetSnOwnerHotkey";
      params: { netuid: number; hotkey: AccountId32 };
    }
  /**
   * Enables or disables subtoken trading for a given subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier of the subnet.
   * * `subtoken_enabled` - A boolean indicating whether subtoken trading should be enabled or disabled.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubtokenEnabled";
      params: { netuid: number; subtokenEnabled: boolean };
    };

export type PalletAdminUtilsCallLike =
  /**
   * The extrinsic sets the new authorities for Aura consensus.
   * It is only callable by the root account.
   * The extrinsic will call the Aura pallet to change the authorities.
   **/
  | {
      name: "SwapAuthorities";
      params: { newAuthorities: Array<SpConsensusAuraSr25519AppSr25519Public> };
    }
  /**
   * The extrinsic sets the default take for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the default take.
   **/
  | { name: "SudoSetDefaultTake"; params: { defaultTake: number } }
  /**
   * The extrinsic sets the transaction rate limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the transaction rate limit.
   **/
  | { name: "SudoSetTxRateLimit"; params: { txRateLimit: bigint } }
  /**
   * The extrinsic sets the serving rate limit for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the serving rate limit.
   **/
  | {
      name: "SudoSetServingRateLimit";
      params: { netuid: number; servingRateLimit: bigint };
    }
  /**
   * The extrinsic sets the minimum difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the minimum difficulty.
   **/
  | {
      name: "SudoSetMinDifficulty";
      params: { netuid: number; minDifficulty: bigint };
    }
  /**
   * The extrinsic sets the maximum difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the maximum difficulty.
   **/
  | {
      name: "SudoSetMaxDifficulty";
      params: { netuid: number; maxDifficulty: bigint };
    }
  /**
   * The extrinsic sets the weights version key for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the weights version key.
   **/
  | {
      name: "SudoSetWeightsVersionKey";
      params: { netuid: number; weightsVersionKey: bigint };
    }
  /**
   * The extrinsic sets the weights set rate limit for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the weights set rate limit.
   **/
  | {
      name: "SudoSetWeightsSetRateLimit";
      params: { netuid: number; weightsSetRateLimit: bigint };
    }
  /**
   * The extrinsic sets the adjustment interval for a subnet.
   * It is only callable by the root account, not changeable by the subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment interval.
   **/
  | {
      name: "SudoSetAdjustmentInterval";
      params: { netuid: number; adjustmentInterval: number };
    }
  /**
   * The extrinsic sets the adjustment alpha for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment alpha.
   **/
  | {
      name: "SudoSetAdjustmentAlpha";
      params: { netuid: number; adjustmentAlpha: bigint };
    }
  /**
   * The extrinsic sets the adjustment beta for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the adjustment beta.
   **/
  | {
      name: "SudoSetMaxWeightLimit";
      params: { netuid: number; maxWeightLimit: number };
    }
  /**
   * The extrinsic sets the immunity period for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the immunity period.
   **/
  | {
      name: "SudoSetImmunityPeriod";
      params: { netuid: number; immunityPeriod: number };
    }
  /**
   * The extrinsic sets the minimum allowed weights for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the minimum allowed weights.
   **/
  | {
      name: "SudoSetMinAllowedWeights";
      params: { netuid: number; minAllowedWeights: number };
    }
  /**
   * The extrinsic sets the maximum allowed UIDs for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum allowed UIDs for a subnet.
   **/
  | {
      name: "SudoSetMaxAllowedUids";
      params: { netuid: number; maxAllowedUids: number };
    }
  /**
   * The extrinsic sets the kappa for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the kappa.
   **/
  | { name: "SudoSetKappa"; params: { netuid: number; kappa: number } }
  /**
   * The extrinsic sets the rho for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the rho.
   **/
  | { name: "SudoSetRho"; params: { netuid: number; rho: number } }
  /**
   * The extrinsic sets the activity cutoff for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the activity cutoff.
   **/
  | {
      name: "SudoSetActivityCutoff";
      params: { netuid: number; activityCutoff: number };
    }
  /**
   * The extrinsic sets the network registration allowed for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the network registration allowed.
   **/
  | {
      name: "SudoSetNetworkRegistrationAllowed";
      params: { netuid: number; registrationAllowed: boolean };
    }
  /**
   * The extrinsic sets the network PoW registration allowed for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the network PoW registration allowed.
   **/
  | {
      name: "SudoSetNetworkPowRegistrationAllowed";
      params: { netuid: number; registrationAllowed: boolean };
    }
  /**
   * The extrinsic sets the target registrations per interval for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the target registrations per interval.
   **/
  | {
      name: "SudoSetTargetRegistrationsPerInterval";
      params: { netuid: number; targetRegistrationsPerInterval: number };
    }
  /**
   * The extrinsic sets the minimum burn for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum burn.
   **/
  | { name: "SudoSetMinBurn"; params: { netuid: number; minBurn: bigint } }
  /**
   * The extrinsic sets the maximum burn for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the maximum burn.
   **/
  | { name: "SudoSetMaxBurn"; params: { netuid: number; maxBurn: bigint } }
  /**
   * The extrinsic sets the difficulty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the difficulty.
   **/
  | {
      name: "SudoSetDifficulty";
      params: { netuid: number; difficulty: bigint };
    }
  /**
   * The extrinsic sets the maximum allowed validators for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum allowed validators.
   **/
  | {
      name: "SudoSetMaxAllowedValidators";
      params: { netuid: number; maxAllowedValidators: number };
    }
  /**
   * The extrinsic sets the bonds moving average for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the bonds moving average.
   **/
  | {
      name: "SudoSetBondsMovingAverage";
      params: { netuid: number; bondsMovingAverage: bigint };
    }
  /**
   * The extrinsic sets the bonds penalty for a subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the bonds penalty.
   **/
  | {
      name: "SudoSetBondsPenalty";
      params: { netuid: number; bondsPenalty: number };
    }
  /**
   * The extrinsic sets the maximum registrations per block for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the maximum registrations per block.
   **/
  | {
      name: "SudoSetMaxRegistrationsPerBlock";
      params: { netuid: number; maxRegistrationsPerBlock: number };
    }
  /**
   * The extrinsic sets the subnet owner cut for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the subnet owner cut.
   **/
  | { name: "SudoSetSubnetOwnerCut"; params: { subnetOwnerCut: number } }
  /**
   * The extrinsic sets the network rate limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the network rate limit.
   **/
  | { name: "SudoSetNetworkRateLimit"; params: { rateLimit: bigint } }
  /**
   * The extrinsic sets the tempo for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the tempo.
   **/
  | { name: "SudoSetTempo"; params: { netuid: number; tempo: number } }
  /**
   * The extrinsic sets the total issuance for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the issuance for the network.
   **/
  | { name: "SudoSetTotalIssuance"; params: { totalIssuance: bigint } }
  /**
   * The extrinsic sets the immunity period for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the immunity period for the network.
   **/
  | { name: "SudoSetNetworkImmunityPeriod"; params: { immunityPeriod: bigint } }
  /**
   * The extrinsic sets the min lock cost for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the min lock cost for the network.
   **/
  | { name: "SudoSetNetworkMinLockCost"; params: { lockCost: bigint } }
  /**
   * The extrinsic sets the subnet limit for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the subnet limit.
   **/
  | { name: "SudoSetSubnetLimit"; params: { maxSubnets: number } }
  /**
   * The extrinsic sets the lock reduction interval for the network.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the lock reduction interval.
   **/
  | { name: "SudoSetLockReductionInterval"; params: { interval: bigint } }
  /**
   * The extrinsic sets the recycled RAO for a subnet.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the recycled RAO.
   **/
  | {
      name: "SudoSetRaoRecycled";
      params: { netuid: number; raoRecycled: bigint };
    }
  /**
   * The extrinsic sets the weights min stake.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the weights min stake.
   **/
  | { name: "SudoSetStakeThreshold"; params: { minStake: bigint } }
  /**
   * The extrinsic sets the minimum stake required for nominators.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum stake required for nominators.
   **/
  | { name: "SudoSetNominatorMinRequiredStake"; params: { minStake: bigint } }
  /**
   * The extrinsic sets the rate limit for delegate take transactions.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the rate limit for delegate take transactions.
   **/
  | { name: "SudoSetTxDelegateTakeRateLimit"; params: { txRateLimit: bigint } }
  /**
   * The extrinsic sets the minimum delegate take.
   * It is only callable by the root account.
   * The extrinsic will call the Subtensor pallet to set the minimum delegate take.
   **/
  | { name: "SudoSetMinDelegateTake"; params: { take: number } }
  /**
   * The extrinsic enabled/disables commit/reaveal for a given subnet.
   * It is only callable by the root account or subnet owner.
   * The extrinsic will call the Subtensor pallet to set the value.
   **/
  | {
      name: "SudoSetCommitRevealWeightsEnabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Enables or disables Liquid Alpha for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetLiquidAlphaEnabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Sets values for liquid alpha
   **/
  | {
      name: "SudoSetAlphaValues";
      params: { netuid: number; alphaLow: number; alphaHigh: number };
    }
  /**
   * Sets the maximum stake allowed for a specific network.
   *
   * This function allows the root account to set the maximum stake for a given network.
   * It updates the network's maximum stake value and logs the change.
   *
   * # Arguments
   *
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier of the network.
   * * `max_stake` - The new maximum stake value to set.
   *
   * # Returns
   *
   * Returns `Ok(())` if the operation is successful, or an error if it fails.
   *
   * # Example
   *
   *
   * # Notes
   *
   * - This function can only be called by the root account.
   * - The `netuid` should correspond to an existing network.
   *
   * # TODO
   *
   **/
  | {
      name: "SudoSetNetworkMaxStake";
      params: { netuid: number; maxStake: bigint };
    }
  /**
   * Sets the duration of the coldkey swap schedule.
   *
   * This extrinsic allows the root account to set the duration for the coldkey swap schedule.
   * The coldkey swap schedule determines how long it takes for a coldkey swap operation to complete.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `duration` - The new duration for the coldkey swap schedule, in number of blocks.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | { name: "SudoSetColdkeySwapScheduleDuration"; params: { duration: number } }
  /**
   * Sets the duration of the dissolve network schedule.
   *
   * This extrinsic allows the root account to set the duration for the dissolve network schedule.
   * The dissolve network schedule determines how long it takes for a network dissolution operation to complete.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `duration` - The new duration for the dissolve network schedule, in number of blocks.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetDissolveNetworkScheduleDuration";
      params: { duration: number };
    }
  /**
   * Sets the commit-reveal weights periods for a specific subnet.
   *
   * This extrinsic allows the subnet owner or root account to set the duration (in epochs) during which committed weights must be revealed.
   * The commit-reveal mechanism ensures that users commit weights in advance and reveal them only within a specified period.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner or the root account.
   * * `netuid` - The unique identifier of the subnet for which the periods are being set.
   * * `periods` - The number of epochs that define the commit-reveal period.
   *
   * # Errors
   * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
   * * `SubnetDoesNotExist` - If the specified subnet does not exist.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetCommitRevealWeightsInterval";
      params: { netuid: number; interval: bigint };
    }
  /**
   * Sets the EVM ChainID.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner or the root account.
   * * `chainId` - The u64 chain ID
   *
   * # Errors
   * * `BadOrigin` - If the caller is neither the subnet owner nor the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | { name: "SudoSetEvmChainId"; params: { chainId: bigint } }
  /**
   * A public interface for `pallet_grandpa::Pallet::schedule_grandpa_change`.
   *
   * Schedule a change in the authorities.
   *
   * The change will be applied at the end of execution of the block `in_blocks` after the
   * current block. This value may be 0, in which case the change is applied at the end of
   * the current block.
   *
   * If the `forced` parameter is defined, this indicates that the current set has been
   * synchronously determined to be offline and that after `in_blocks` the given change
   * should be applied. The given block number indicates the median last finalized block
   * number and it should be used as the canon block when starting the new grandpa voter.
   *
   * No change should be signaled while any change is pending. Returns an error if a change
   * is already pending.
   **/
  | {
      name: "ScheduleGrandpaChange";
      params: {
        nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
        inBlocks: number;
        forced?: number | undefined;
      };
    }
  /**
   * Enables or disables Liquid Alpha for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Liquid Alpha.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetToggleTransfer";
      params: { netuid: number; toggle: boolean };
    }
  /**
   * Toggles the enablement of an EVM precompile.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `precompile_id` - The identifier of the EVM precompile to toggle.
   * * `enabled` - The new enablement state of the precompile.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoToggleEvmPrecompile";
      params: {
        precompileId: PalletAdminUtilsPrecompileEnum;
        enabled: boolean;
      };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `alpha` - The new moving alpha value for the SubnetMovingAlpha.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubnetMovingAlpha";
      params: { alpha: SubstrateFixedFixedI128 };
    }
  /**
   * Change the SubnetOwnerHotkey for a given subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the subnet owner.
   * * `netuid` - The unique identifier for the subnet.
   * * `hotkey` - The new hotkey for the subnet owner.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the subnet owner or root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubnetOwnerHotkey";
      params: { netuid: number; hotkey: AccountId32Like };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `ema_alpha_period` - Number of blocks for EMA price to halve
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetEmaPriceHalvingPeriod";
      params: { netuid: number; emaHalving: bigint };
    }
  /**
   *
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier for the subnet.
   * * `steepness` - The new steepness for the alpha sigmoid function.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetAlphaSigmoidSteepness";
      params: { netuid: number; steepness: number };
    }
  /**
   * Enables or disables Yuma3 for a given subnet.
   *
   * # Parameters
   * - `origin`: The origin of the call, which must be the root account or subnet owner.
   * - `netuid`: The unique identifier for the subnet.
   * - `enabled`: A boolean flag to enable or disable Yuma3.
   *
   * # Weight
   * This function has a fixed weight of 0 and is classified as an operational transaction that does not incur any fees.
   **/
  | {
      name: "SudoSetYuma3Enabled";
      params: { netuid: number; enabled: boolean };
    }
  /**
   * Sets or updates the hotkey account associated with the owner of a specific subnet.
   *
   * This function allows either the root origin or the current subnet owner to set or update
   * the hotkey for a given subnet. The subnet must already exist. To prevent abuse, the call is
   * rate-limited to once per configured interval (default: one week) per subnet.
   *
   * # Parameters
   * - `origin`: The dispatch origin of the call. Must be either root or the current owner of the subnet.
   * - `netuid`: The unique identifier of the subnet whose owner hotkey is being set.
   * - `hotkey`: The new hotkey account to associate with the subnet owner.
   *
   * # Returns
   * - `DispatchResult`: Returns `Ok(())` if the hotkey was successfully set, or an appropriate error otherwise.
   *
   * # Errors
   * - `Error::SubnetNotExists`: If the specified subnet does not exist.
   * - `Error::TxRateLimitExceeded`: If the function is called more frequently than the allowed rate limit.
   *
   * # Access Control
   * Only callable by:
   * - Root origin, or
   * - The coldkey account that owns the subnet.
   *
   * # Storage
   * - Updates [`SubnetOwnerHotkey`] for the given `netuid`.
   * - Reads and updates [`LastRateLimitedBlock`] for rate-limiting.
   * - Reads [`DefaultSetSNOwnerHotkeyRateLimit`] to determine the interval between allowed updates.
   *
   * # Rate Limiting
   * This function is rate-limited to one call per subnet per interval (e.g., one week).
   **/
  | {
      name: "SudoSetSnOwnerHotkey";
      params: { netuid: number; hotkey: AccountId32Like };
    }
  /**
   * Enables or disables subtoken trading for a given subnet.
   *
   * # Arguments
   * * `origin` - The origin of the call, which must be the root account.
   * * `netuid` - The unique identifier of the subnet.
   * * `subtoken_enabled` - A boolean indicating whether subtoken trading should be enabled or disabled.
   *
   * # Errors
   * * `BadOrigin` - If the caller is not the root account.
   *
   * # Weight
   * Weight is handled by the `#[pallet::weight]` attribute.
   **/
  | {
      name: "SudoSetSubtokenEnabled";
      params: { netuid: number; subtokenEnabled: boolean };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSafeModeCall =
  /**
   * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
   *
   * Reserves [`Config::EnterDepositAmount`] from the caller's account.
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   **/
  | { name: "Enter" }
  /**
   * Enter safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   *
   * Can only be called by the [`Config::ForceEnterOrigin`] origin.
   **/
  | { name: "ForceEnter" }
  /**
   * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
   *
   * This accumulates on top of the current remaining duration.
   * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   *
   * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
   * currency to reserve. This call can be disabled for all origins by configuring
   * [`Config::ExtendDepositAmount`] to `None`.
   **/
  | { name: "Extend" }
  /**
   * Extend the safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Can only be called by the [`Config::ForceExtendOrigin`] origin.
   **/
  | { name: "ForceExtend" }
  /**
   * Exit safe-mode by force.
   *
   * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
   * after the block height is greater than the [`EnteredUntil`] storage item.
   * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
   * hook.
   **/
  | { name: "ForceExit" }
  /**
   * Slash a deposit for an account that entered or extended safe-mode at a given
   * historical block.
   *
   * This can only be called while safe-mode is entered.
   *
   * Emits a [`Event::DepositSlashed`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | {
      name: "ForceSlashDeposit";
      params: { account: AccountId32; block: number };
    }
  /**
   * Permissionlessly release a deposit for an account that entered safe-mode at a
   * given historical block.
   *
   * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
   * This cannot be called while safe-mode is entered and not until
   * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is entered.
   * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
   * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
   * reserved currency at the block specified.
   **/
  | { name: "ReleaseDeposit"; params: { account: AccountId32; block: number } }
  /**
   * Force to release a deposit for an account that entered safe-mode at a given
   * historical block.
   *
   * This can be called while safe-mode is still entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
   * specified block.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | {
      name: "ForceReleaseDeposit";
      params: { account: AccountId32; block: number };
    };

export type PalletSafeModeCallLike =
  /**
   * Enter safe-mode permissionlessly for [`Config::EnterDuration`] blocks.
   *
   * Reserves [`Config::EnterDepositAmount`] from the caller's account.
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   **/
  | { name: "Enter" }
  /**
   * Enter safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Entered`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is already entered.
   *
   * Can only be called by the [`Config::ForceEnterOrigin`] origin.
   **/
  | { name: "ForceEnter" }
  /**
   * Extend the safe-mode permissionlessly for [`Config::ExtendDuration`] blocks.
   *
   * This accumulates on top of the current remaining duration.
   * Reserves [`Config::ExtendDepositAmount`] from the caller's account.
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is entered.
   * Errors with [`Error::NotConfigured`] if the deposit amount is `None`.
   *
   * This may be called by any signed origin with [`Config::ExtendDepositAmount`] free
   * currency to reserve. This call can be disabled for all origins by configuring
   * [`Config::ExtendDepositAmount`] to `None`.
   **/
  | { name: "Extend" }
  /**
   * Extend the safe-mode by force for a per-origin configured number of blocks.
   *
   * Emits an [`Event::Extended`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Can only be called by the [`Config::ForceExtendOrigin`] origin.
   **/
  | { name: "ForceExtend" }
  /**
   * Exit safe-mode by force.
   *
   * Emits an [`Event::Exited`] with [`ExitReason::Force`] event on success.
   * Errors with [`Error::Exited`] if the safe-mode is inactive.
   *
   * Note: `safe-mode` will be automatically deactivated by [`Pallet::on_initialize`] hook
   * after the block height is greater than the [`EnteredUntil`] storage item.
   * Emits an [`Event::Exited`] with [`ExitReason::Timeout`] event when deactivated in the
   * hook.
   **/
  | { name: "ForceExit" }
  /**
   * Slash a deposit for an account that entered or extended safe-mode at a given
   * historical block.
   *
   * This can only be called while safe-mode is entered.
   *
   * Emits a [`Event::DepositSlashed`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | {
      name: "ForceSlashDeposit";
      params: { account: AccountId32Like; block: number };
    }
  /**
   * Permissionlessly release a deposit for an account that entered safe-mode at a
   * given historical block.
   *
   * The call can be completely disabled by setting [`Config::ReleaseDelay`] to `None`.
   * This cannot be called while safe-mode is entered and not until
   * [`Config::ReleaseDelay`] blocks have passed since safe-mode was entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if the safe-mode is entered.
   * Errors with [`Error::CannotReleaseYet`] if [`Config::ReleaseDelay`] block have not
   * passed since safe-mode was entered. Errors with [`Error::NoDeposit`] if the payee has no
   * reserved currency at the block specified.
   **/
  | {
      name: "ReleaseDeposit";
      params: { account: AccountId32Like; block: number };
    }
  /**
   * Force to release a deposit for an account that entered safe-mode at a given
   * historical block.
   *
   * This can be called while safe-mode is still entered.
   *
   * Emits a [`Event::DepositReleased`] event on success.
   * Errors with [`Error::Entered`] if safe-mode is entered.
   * Errors with [`Error::NoDeposit`] if the payee has no reserved currency at the
   * specified block.
   *
   * Can only be called by the [`Config::ForceDepositOrigin`] origin.
   **/
  | {
      name: "ForceReleaseDeposit";
      params: { account: AccountId32Like; block: number };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEthereumCall =
  /**
   * Transact an Ethereum transaction.
   **/
  {
    name: "Transact";
    params: { transaction: EthereumTransactionTransactionV2 };
  };

export type PalletEthereumCallLike =
  /**
   * Transact an Ethereum transaction.
   **/
  {
    name: "Transact";
    params: { transaction: EthereumTransactionTransactionV2 };
  };

export type EthereumTransactionTransactionV2 =
  | { type: "Legacy"; value: EthereumTransactionLegacyTransaction }
  | { type: "Eip2930"; value: EthereumTransactionEip2930Transaction }
  | { type: "Eip1559"; value: EthereumTransactionEip1559Transaction };

export type EthereumTransactionLegacyTransaction = {
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  signature: EthereumTransactionTransactionSignature;
};

export type EthereumTransactionTransactionAction =
  | { type: "Call"; value: H160 }
  | { type: "Create" };

export type EthereumTransactionTransactionSignature = {
  v: EthereumTransactionTransactionRecoveryId;
  r: H256;
  s: H256;
};

export type EthereumTransactionTransactionRecoveryId = bigint;

export type EthereumTransactionEip2930Transaction = {
  chainId: bigint;
  nonce: U256;
  gasPrice: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

export type EthereumTransactionAccessListItem = {
  address: H160;
  storageKeys: Array<H256>;
};

export type EthereumTransactionEip1559Transaction = {
  chainId: bigint;
  nonce: U256;
  maxPriorityFeePerGas: U256;
  maxFeePerGas: U256;
  gasLimit: U256;
  action: EthereumTransactionTransactionAction;
  value: U256;
  input: Bytes;
  accessList: Array<EthereumTransactionAccessListItem>;
  oddYParity: boolean;
  r: H256;
  s: H256;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletEvmCall =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: "Withdraw"; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: "Call";
      params: {
        source: H160;
        target: H160;
        input: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: "Create";
      params: {
        source: H160;
        init: Bytes;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: "Create2";
      params: {
        source: H160;
        init: Bytes;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  | { name: "SetWhitelist"; params: { new: Array<H160> } }
  | { name: "DisableWhitelist"; params: { disabled: boolean } };

export type PalletEvmCallLike =
  /**
   * Withdraw balance from EVM into currency/balances pallet.
   **/
  | { name: "Withdraw"; params: { address: H160; value: bigint } }
  /**
   * Issue an EVM call operation. This is similar to a message call transaction in Ethereum.
   **/
  | {
      name: "Call";
      params: {
        source: H160;
        target: H160;
        input: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create operation. This is similar to a contract creation transaction in
   * Ethereum.
   **/
  | {
      name: "Create";
      params: {
        source: H160;
        init: BytesLike;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  /**
   * Issue an EVM create2 operation.
   **/
  | {
      name: "Create2";
      params: {
        source: H160;
        init: BytesLike;
        salt: H256;
        value: U256;
        gasLimit: bigint;
        maxFeePerGas: U256;
        maxPriorityFeePerGas?: U256 | undefined;
        nonce?: U256 | undefined;
        accessList: Array<[H160, Array<H256>]>;
      };
    }
  | { name: "SetWhitelist"; params: { new: Array<H160> } }
  | { name: "DisableWhitelist"; params: { disabled: boolean } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBaseFeeCall =
  | { name: "SetBaseFeePerGas"; params: { fee: U256 } }
  | { name: "SetElasticity"; params: { elasticity: Permill } };

export type PalletBaseFeeCallLike =
  | { name: "SetBaseFeePerGas"; params: { fee: U256 } }
  | { name: "SetElasticity"; params: { elasticity: Permill } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDrandCall =
  /**
   * Verify and write a pulse from the beacon into the runtime
   **/
  | {
      name: "WritePulse";
      params: {
        pulsesPayload: PalletDrandPulsesPayload;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * allows the root user to set the beacon configuration
   * generally this would be called from an offchain worker context.
   * there is no verification of configurations, so be careful with this.
   *
   * * `origin`: the root user
   * * `config`: the beacon configuration
   **/
  | {
      name: "SetBeaconConfig";
      params: {
        configPayload: PalletDrandBeaconConfigurationPayload;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    };

export type PalletDrandCallLike =
  /**
   * Verify and write a pulse from the beacon into the runtime
   **/
  | {
      name: "WritePulse";
      params: {
        pulsesPayload: PalletDrandPulsesPayload;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    }
  /**
   * allows the root user to set the beacon configuration
   * generally this would be called from an offchain worker context.
   * there is no verification of configurations, so be careful with this.
   *
   * * `origin`: the root user
   * * `config`: the beacon configuration
   **/
  | {
      name: "SetBeaconConfig";
      params: {
        configPayload: PalletDrandBeaconConfigurationPayload;
        signature?: SpRuntimeMultiSignature | undefined;
      };
    };

export type PalletDrandPulsesPayload = {
  blockNumber: number;
  pulses: Array<PalletDrandPulse>;
  public: SpRuntimeMultiSigner;
};

export type SpRuntimeMultiSigner =
  | { type: "Ed25519"; value: FixedBytes<32> }
  | { type: "Sr25519"; value: FixedBytes<32> }
  | { type: "Ecdsa"; value: FixedBytes<33> };

export type PalletDrandPulse = {
  round: bigint;
  randomness: Bytes;
  signature: Bytes;
};

export type SpRuntimeMultiSignature =
  | { type: "Ed25519"; value: FixedBytes<64> }
  | { type: "Sr25519"; value: FixedBytes<64> }
  | { type: "Ecdsa"; value: FixedBytes<65> };

export type PalletDrandBeaconConfigurationPayload = {
  blockNumber: number;
  config: PalletDrandBeaconConfiguration;
  public: SpRuntimeMultiSigner;
};

export type PalletDrandBeaconConfiguration = {
  publicKey: Bytes;
  period: number;
  genesisTime: number;
  hash: Bytes;
  groupHash: Bytes;
  schemeId: Bytes;
  metadata: PalletDrandMetadata;
};

export type PalletDrandMetadata = { beaconId: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCrowdloanCall =
  /**
   * Create a crowdloan that will raise funds up to a maximum cap and if successful,
   * will transfer funds to the target address if provided and dispatch the call
   * (using creator origin).
   *
   * The initial deposit will be transfered to the crowdloan account and will be refunded
   * in case the crowdloan fails to raise the cap. Additionally, the creator will pay for
   * the execution of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `deposit`: The initial deposit from the creator.
   * - `min_contribution`: The minimum contribution required to contribute to the crowdloan.
   * - `cap`: The maximum amount of funds that can be raised.
   * - `end`: The block number at which the crowdloan will end.
   * - `call`: The call to dispatch when the crowdloan is finalized.
   * - `target_address`: The address to transfer the raised funds to if provided.
   **/
  | {
      name: "Create";
      params: {
        deposit: bigint;
        minContribution: bigint;
        cap: bigint;
        end: number;
        call?: NodeSubtensorRuntimeRuntimeCall | undefined;
        targetAddress?: AccountId32 | undefined;
      };
    }
  /**
   * Contribute to an active crowdloan.
   *
   * The contribution will be transfered to the crowdloan account and will be refunded
   * if the crowdloan fails to raise the cap. If the contribution would raise the amount above the cap,
   * the contribution will be set to the amount that is left to be raised.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to contribute to.
   * - `amount`: The amount to contribute.
   **/
  | { name: "Contribute"; params: { crowdloanId: number; amount: bigint } }
  /**
   * Withdraw a contribution from an active (not yet finalized or dissolved) crowdloan.
   *
   * Only contributions over the deposit can be withdrawn by the creator.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to withdraw from.
   **/
  | { name: "Withdraw"; params: { crowdloanId: number } }
  /**
   * Finalize a successful crowdloan.
   *
   * The call will transfer the raised amount to the target address if it was provided when the crowdloan was created
   * and dispatch the call that was provided using the creator origin. The CurrentCrowdloanId will be set to the
   * crowdloan id being finalized so the dispatched call can access it temporarily by accessing
   * the `CurrentCrowdloanId` storage item.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to finalize.
   **/
  | { name: "Finalize"; params: { crowdloanId: number } }
  /**
   * Refund a failed crowdloan.
   *
   * The call will try to refund all contributors (excluding the creator) up to the limit defined by the `RefundContributorsLimit`.
   * If the limit is reached, the call will stop and the crowdloan will be marked as partially refunded.
   * It may be needed to dispatch this call multiple times to refund all contributors.
   *
   * The dispatch origin for this call must be _Signed_ and doesn't need to be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to refund.
   **/
  | { name: "Refund"; params: { crowdloanId: number } }
  /**
   * Dissolve a crowdloan.
   *
   * The crowdloan will be removed from the storage.
   * All contributions must have been refunded before the crowdloan can be dissolved (except the creator's one).
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to dissolve.
   **/
  | { name: "Dissolve"; params: { crowdloanId: number } }
  /**
   * Update the minimum contribution of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the minimum contribution of.
   * - `new_min_contribution`: The new minimum contribution.
   **/
  | {
      name: "UpdateMinContribution";
      params: { crowdloanId: number; newMinContribution: bigint };
    }
  /**
   * Update the end block of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the end block of.
   * - `new_end`: The new end block.
   **/
  | { name: "UpdateEnd"; params: { crowdloanId: number; newEnd: number } }
  /**
   * Update the cap of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the cap of.
   * - `new_cap`: The new cap.
   **/
  | { name: "UpdateCap"; params: { crowdloanId: number; newCap: bigint } };

export type PalletCrowdloanCallLike =
  /**
   * Create a crowdloan that will raise funds up to a maximum cap and if successful,
   * will transfer funds to the target address if provided and dispatch the call
   * (using creator origin).
   *
   * The initial deposit will be transfered to the crowdloan account and will be refunded
   * in case the crowdloan fails to raise the cap. Additionally, the creator will pay for
   * the execution of the call.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `deposit`: The initial deposit from the creator.
   * - `min_contribution`: The minimum contribution required to contribute to the crowdloan.
   * - `cap`: The maximum amount of funds that can be raised.
   * - `end`: The block number at which the crowdloan will end.
   * - `call`: The call to dispatch when the crowdloan is finalized.
   * - `target_address`: The address to transfer the raised funds to if provided.
   **/
  | {
      name: "Create";
      params: {
        deposit: bigint;
        minContribution: bigint;
        cap: bigint;
        end: number;
        call?: NodeSubtensorRuntimeRuntimeCallLike | undefined;
        targetAddress?: AccountId32Like | undefined;
      };
    }
  /**
   * Contribute to an active crowdloan.
   *
   * The contribution will be transfered to the crowdloan account and will be refunded
   * if the crowdloan fails to raise the cap. If the contribution would raise the amount above the cap,
   * the contribution will be set to the amount that is left to be raised.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to contribute to.
   * - `amount`: The amount to contribute.
   **/
  | { name: "Contribute"; params: { crowdloanId: number; amount: bigint } }
  /**
   * Withdraw a contribution from an active (not yet finalized or dissolved) crowdloan.
   *
   * Only contributions over the deposit can be withdrawn by the creator.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to withdraw from.
   **/
  | { name: "Withdraw"; params: { crowdloanId: number } }
  /**
   * Finalize a successful crowdloan.
   *
   * The call will transfer the raised amount to the target address if it was provided when the crowdloan was created
   * and dispatch the call that was provided using the creator origin. The CurrentCrowdloanId will be set to the
   * crowdloan id being finalized so the dispatched call can access it temporarily by accessing
   * the `CurrentCrowdloanId` storage item.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to finalize.
   **/
  | { name: "Finalize"; params: { crowdloanId: number } }
  /**
   * Refund a failed crowdloan.
   *
   * The call will try to refund all contributors (excluding the creator) up to the limit defined by the `RefundContributorsLimit`.
   * If the limit is reached, the call will stop and the crowdloan will be marked as partially refunded.
   * It may be needed to dispatch this call multiple times to refund all contributors.
   *
   * The dispatch origin for this call must be _Signed_ and doesn't need to be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to refund.
   **/
  | { name: "Refund"; params: { crowdloanId: number } }
  /**
   * Dissolve a crowdloan.
   *
   * The crowdloan will be removed from the storage.
   * All contributions must have been refunded before the crowdloan can be dissolved (except the creator's one).
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to dissolve.
   **/
  | { name: "Dissolve"; params: { crowdloanId: number } }
  /**
   * Update the minimum contribution of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the minimum contribution of.
   * - `new_min_contribution`: The new minimum contribution.
   **/
  | {
      name: "UpdateMinContribution";
      params: { crowdloanId: number; newMinContribution: bigint };
    }
  /**
   * Update the end block of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the end block of.
   * - `new_end`: The new end block.
   **/
  | { name: "UpdateEnd"; params: { crowdloanId: number; newEnd: number } }
  /**
   * Update the cap of a non-finalized crowdloan.
   *
   * The dispatch origin for this call must be _Signed_ and must be the creator of the crowdloan.
   *
   * Parameters:
   * - `crowdloan_id`: The id of the crowdloan to update the cap of.
   * - `new_cap`: The new cap.
   **/
  | { name: "UpdateCap"; params: { crowdloanId: number; newCap: bigint } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSubtensorError =
  /**
   * The subnet does not exist.
   **/
  | "SubNetworkDoesNotExist"
  /**
   * The root network does not exist.
   **/
  | "RootNetworkDoesNotExist"
  /**
   * The user is trying to serve an axon which is not of type 4 (IPv4) or 6 (IPv6).
   **/
  | "InvalidIpType"
  /**
   * An invalid IP address is passed to the serve function.
   **/
  | "InvalidIpAddress"
  /**
   * An invalid port is passed to the serve function.
   **/
  | "InvalidPort"
  /**
   * The hotkey is not registered in subnet
   **/
  | "HotKeyNotRegisteredInSubNet"
  /**
   * The hotkey does not exists
   **/
  | "HotKeyAccountNotExists"
  /**
   * The hotkey is not registered in any subnet.
   **/
  | "HotKeyNotRegisteredInNetwork"
  /**
   * Request to stake, unstake or subscribe is made by a coldkey that is not associated with
   * the hotkey account.
   **/
  | "NonAssociatedColdKey"
  /**
   * DEPRECATED: Stake amount to withdraw is zero.
   * The caller does not have enought stake to perform this action.
   **/
  | "NotEnoughStake"
  /**
   * The caller is requesting removing more stake than there exists in the staking account.
   * See: "[remove_stake()]".
   **/
  | "NotEnoughStakeToWithdraw"
  /**
   * The caller is requesting to set weights but the caller has less than minimum stake
   * required to set weights (less than WeightsMinStake).
   **/
  | "NotEnoughStakeToSetWeights"
  /**
   * The parent hotkey doesn't have enough own stake to set childkeys.
   **/
  | "NotEnoughStakeToSetChildkeys"
  /**
   * The caller is requesting adding more stake than there exists in the coldkey account.
   * See: "[add_stake()]"
   **/
  | "NotEnoughBalanceToStake"
  /**
   * The caller is trying to add stake, but for some reason the requested amount could not be
   * withdrawn from the coldkey account.
   **/
  | "BalanceWithdrawalError"
  /**
   * Unsuccessfully withdraw, balance could be zero (can not make account exist) after
   * withdrawal.
   **/
  | "ZeroBalanceAfterWithdrawn"
  /**
   * The caller is attempting to set non-self weights without being a permitted validator.
   **/
  | "NeuronNoValidatorPermit"
  /**
   * The caller is attempting to set the weight keys and values but these vectors have
   * different size.
   **/
  | "WeightVecNotEqualSize"
  /**
   * The caller is attempting to set weights with duplicate UIDs in the weight matrix.
   **/
  | "DuplicateUids"
  /**
   * The caller is attempting to set weight to at least one UID that does not exist in the
   * metagraph.
   **/
  | "UidVecContainInvalidOne"
  /**
   * The dispatch is attempting to set weights on chain with fewer elements than are allowed.
   **/
  | "WeightVecLengthIsLow"
  /**
   * Number of registrations in this block exceeds the allowed number (i.e., exceeds the
   * subnet hyperparameter "max_regs_per_block").
   **/
  | "TooManyRegistrationsThisBlock"
  /**
   * The caller is requesting registering a neuron which already exists in the active set.
   **/
  | "HotKeyAlreadyRegisteredInSubNet"
  /**
   * The new hotkey is the same as old one
   **/
  | "NewHotKeyIsSameWithOld"
  /**
   * The supplied PoW hash block is in the future or negative.
   **/
  | "InvalidWorkBlock"
  /**
   * The supplied PoW hash block does not meet the network difficulty.
   **/
  | "InvalidDifficulty"
  /**
   * The supplied PoW hash seal does not match the supplied work.
   **/
  | "InvalidSeal"
  /**
   * The dispatch is attempting to set weights on chain with weight value exceeding the
   * MaxWeightLimit (max_weight_limit subnet hyperparameter).
   **/
  | "MaxWeightExceeded"
  /**
   * The hotkey is attempting to become a delegate when the hotkey is already a delegate.
   **/
  | "HotKeyAlreadyDelegate"
  /**
   * A transactor exceeded the rate limit for setting weights.
   **/
  | "SettingWeightsTooFast"
  /**
   * A validator is attempting to set weights from a validator with incorrect weight version.
   **/
  | "IncorrectWeightVersionKey"
  /**
   * An axon or prometheus serving exceeded the rate limit for a registered neuron.
   **/
  | "ServingRateLimitExceeded"
  /**
   * The caller is attempting to set weights with more UIDs than allowed.
   **/
  | "UidsLengthExceedUidsInSubNet"
  /**
   * A transactor exceeded the rate limit for add network transaction.
   **/
  | "NetworkTxRateLimitExceeded"
  /**
   * A transactor exceeded the rate limit for delegate transaction.
   **/
  | "DelegateTxRateLimitExceeded"
  /**
   * A transactor exceeded the rate limit for setting or swapping hotkey.
   **/
  | "HotKeySetTxRateLimitExceeded"
  /**
   * A transactor exceeded the rate limit for staking.
   **/
  | "StakingRateLimitExceeded"
  /**
   * Registration is disabled.
   **/
  | "SubNetRegistrationDisabled"
  /**
   * The number of registration attempts exceeded the allowed number in the interval.
   **/
  | "TooManyRegistrationsThisInterval"
  /**
   * The hotkey is required to be the origin.
   **/
  | "TransactorAccountShouldBeHotKey"
  /**
   * A hotkey is attempting to do something only senate members can do.
   **/
  | "NotSenateMember"
  /**
   * Faucet is disabled.
   **/
  | "FaucetDisabled"
  /**
   * Not a subnet owner.
   **/
  | "NotSubnetOwner"
  /**
   * Operation is not permitted on the root subnet.
   **/
  | "RegistrationNotPermittedOnRootSubnet"
  /**
   * A hotkey with too little stake is attempting to join the root subnet.
   **/
  | "StakeTooLowForRoot"
  /**
   * All subnets are in the immunity period.
   **/
  | "AllNetworksInImmunity"
  /**
   * Not enough balance to pay swapping hotkey.
   **/
  | "NotEnoughBalanceToPaySwapHotKey"
  /**
   * Netuid does not match for setting root network weights.
   **/
  | "NotRootSubnet"
  /**
   * Can not set weights for the root network.
   **/
  | "CanNotSetRootNetworkWeights"
  /**
   * No neuron ID is available.
   **/
  | "NoNeuronIdAvailable"
  /**
   * Delegate take is too low.
   **/
  | "DelegateTakeTooLow"
  /**
   * Delegate take is too high.
   **/
  | "DelegateTakeTooHigh"
  /**
   * No commit found for the provided hotkey+netuid combination when attempting to reveal the
   * weights.
   **/
  | "NoWeightsCommitFound"
  /**
   * Committed hash does not equal the hashed reveal data.
   **/
  | "InvalidRevealCommitHashNotMatch"
  /**
   * Attempting to call set_weights when commit/reveal is enabled
   **/
  | "CommitRevealEnabled"
  /**
   * Attemtping to commit/reveal weights when disabled.
   **/
  | "CommitRevealDisabled"
  /**
   * Not able to join the senate.
   **/
  | "CouldNotJoinSenate"
  /**
   * Attempting to set alpha high/low while disabled
   **/
  | "LiquidAlphaDisabled"
  /**
   * Alpha high is too low: alpha_high > 0.8
   **/
  | "AlphaHighTooLow"
  /**
   * Alpha low is out of range: alpha_low > 0 && alpha_low < 0.8
   **/
  | "AlphaLowOutOfRange"
  /**
   * The coldkey has already been swapped
   **/
  | "ColdKeyAlreadyAssociated"
  /**
   * The coldkey balance is not enough to pay for the swap
   **/
  | "NotEnoughBalanceToPaySwapColdKey"
  /**
   * The coldkey is in arbitration
   **/
  | "ColdkeyIsInArbitration"
  /**
   * Attempting to set an invalid child for a hotkey on a network.
   **/
  | "InvalidChild"
  /**
   * Duplicate child when setting children.
   **/
  | "DuplicateChild"
  /**
   * Proportion overflow when setting children.
   **/
  | "ProportionOverflow"
  /**
   * Too many children MAX 5.
   **/
  | "TooManyChildren"
  /**
   * Default transaction rate limit exceeded.
   **/
  | "TxRateLimitExceeded"
  /**
   * Swap already scheduled.
   **/
  | "SwapAlreadyScheduled"
  /**
   * failed to swap coldkey
   **/
  | "FailedToSchedule"
  /**
   * New coldkey is hotkey
   **/
  | "NewColdKeyIsHotkey"
  /**
   * Childkey take is invalid.
   **/
  | "InvalidChildkeyTake"
  /**
   * Childkey take rate limit exceeded.
   **/
  | "TxChildkeyTakeRateLimitExceeded"
  /**
   * Invalid identity.
   **/
  | "InvalidIdentity"
  /**
   * Trying to register a subnet into a mechanism that does not exist.
   **/
  | "MechanismDoesNotExist"
  /**
   * Trying to unstake your lock amount.
   **/
  | "CannotUnstakeLock"
  /**
   * Trying to perform action on non-existent subnet.
   **/
  | "SubnetNotExists"
  /**
   * Maximum commit limit reached
   **/
  | "TooManyUnrevealedCommits"
  /**
   * Attempted to reveal weights that are expired.
   **/
  | "ExpiredWeightCommit"
  /**
   * Attempted to reveal weights too early.
   **/
  | "RevealTooEarly"
  /**
   * Attempted to batch reveal weights with mismatched vector input lenghts.
   **/
  | "InputLengthsUnequal"
  /**
   * A transactor exceeded the rate limit for setting weights.
   **/
  | "CommittingWeightsTooFast"
  /**
   * Stake amount is too low.
   **/
  | "AmountTooLow"
  /**
   * Not enough liquidity.
   **/
  | "InsufficientLiquidity"
  /**
   * Slippage is too high for the transaction.
   **/
  | "SlippageTooHigh"
  /**
   * Subnet disallows transfer.
   **/
  | "TransferDisallowed"
  /**
   * Activity cutoff is being set too low.
   **/
  | "ActivityCutoffTooLow"
  /**
   * Call is disabled
   **/
  | "CallDisabled"
  /**
   * FirstEmissionBlockNumber is already set.
   **/
  | "FirstEmissionBlockNumberAlreadySet"
  /**
   * need wait for more blocks to accept the start call extrinsic.
   **/
  | "NeedWaitingMoreBlocksToStarCall"
  /**
   * Not enough AlphaOut on the subnet to recycle
   **/
  | "NotEnoughAlphaOutToRecycle"
  /**
   * Cannot burn or recycle TAO from root subnet
   **/
  | "CannotBurnOrRecycleOnRootSubnet"
  /**
   * Public key cannot be recovered.
   **/
  | "UnableToRecoverPublicKey"
  /**
   * Recovered public key is invalid.
   **/
  | "InvalidRecoveredPublicKey"
  /**
   * SubToken disabled now
   **/
  | "SubtokenDisabled"
  /**
   * Too frequent hotkey swap on subnet
   **/
  | "HotKeySwapOnSubnetIntervalNotPassed"
  /**
   * Zero max stake amount
   **/
  | "ZeroMaxStakeAmount"
  /**
   * Invalid netuid duplication
   **/
  | "SameNetuid";

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32>;
  nays: Array<AccountId32>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member of collective
   **/
  | "NotMember"
  /**
   * Duplicate proposals not allowed
   **/
  | "DuplicateProposal"
  /**
   * Proposal must exist
   **/
  | "ProposalNotExists"
  /**
   * Index mismatched the proposal hash
   **/
  | "IndexMismatchProposalHash"
  /**
   * Duplicate vote ignored
   **/
  | "DuplicateVote"
  /**
   * The call to close the proposal was made too early, before the end of the voting
   **/
  | "TooEarlyToCloseProposal"
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | "TooManyActiveProposals"
  /**
   * The given weight-bound for the proposal was too low.
   **/
  | "ProposalWeightLessThanDispatchCallWeight"
  /**
   * The given length-bound for the proposal was too low.
   **/
  | "ProposalLengthBoundLessThanProposalLength"
  /**
   * The given motion duration for the proposal was too low.
   **/
  | "DurationLowerThanConfiguredMotionDuration";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | "AlreadyMember"
  /**
   * Not a member.
   **/
  | "NotMember"
  /**
   * Too many members.
   **/
  | "TooManyMembers";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  "TooManyCalls";

/**
 * Error for the Sudo pallet.
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account.
   **/
  "RequireSudo";

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | "MinimumThreshold"
  /**
   * Call is already approved by this signatory.
   **/
  | "AlreadyApproved"
  /**
   * Call doesn't need any (more) approvals.
   **/
  | "NoApprovalsNeeded"
  /**
   * There are too few signatories in the list.
   **/
  | "TooFewSignatories"
  /**
   * There are too many signatories in the list.
   **/
  | "TooManySignatories"
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | "SignatoriesOutOfOrder"
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | "SenderInSignatories"
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | "NotFound"
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | "NotOwner"
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | "NoTimepoint"
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | "WrongTimepoint"
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | "UnexpectedTimepoint"
  /**
   * The maximum weight information provided was too low.
   **/
  | "MaxWeightTooLow"
  /**
   * The data to be stored is already stored.
   **/
  | "AlreadyStored";

export type PalletPreimageOldRequestStatus =
  | {
      type: "Unrequested";
      value: { deposit: [AccountId32, bigint]; len: number };
    }
  | {
      type: "Requested";
      value: {
        deposit?: [AccountId32, bigint] | undefined;
        count: number;
        len?: number | undefined;
      };
    };

export type PalletPreimageRequestStatus =
  | {
      type: "Unrequested";
      value: {
        ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration];
        len: number;
      };
    }
  | {
      type: "Requested";
      value: {
        maybeTicket?:
          | [AccountId32, FrameSupportTokensFungibleHoldConsideration]
          | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | "TooBig"
  /**
   * Preimage has already been noted on-chain.
   **/
  | "AlreadyNoted"
  /**
   * The user is not authorized to perform this action.
   **/
  | "NotAuthorized"
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | "NotNoted"
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | "Requested"
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | "NotRequested"
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | "TooMany"
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | "TooFew";

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: NodeSubtensorRuntimeOriginCaller;
};

export type FrameSupportPreimagesBounded =
  | { type: "Legacy"; value: { hash: H256 } }
  | { type: "Inline"; value: Bytes }
  | { type: "Lookup"; value: { hash: H256; len: number } };

export type SpRuntimeBlakeTwo256 = {};

export type PalletSchedulerRetryConfig = {
  totalRetries: number;
  remaining: number;
  period: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | "FailedToSchedule"
  /**
   * Cannot find the scheduled call.
   **/
  | "NotFound"
  /**
   * Given target block number is in the past.
   **/
  | "TargetBlockNumberInPast"
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | "RescheduleNoChange"
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | "Named";

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: SubtensorRuntimeCommonProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = {
  real: AccountId32;
  callHash: H256;
  height: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | "TooMany"
  /**
   * Proxy registration not found.
   **/
  | "NotFound"
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | "NotProxy"
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | "Unproxyable"
  /**
   * Account is already a proxy.
   **/
  | "Duplicate"
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | "NoPermission"
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | "Unannounced"
  /**
   * Cannot add self as proxy.
   **/
  | "NoSelfProxy";

export type PalletRegistryRegistration = {
  deposit: bigint;
  info: PalletRegistryIdentityInfo;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRegistryError =
  /**
   * Account attempted to register an identity but does not meet the requirements.
   **/
  | "CannotRegister"
  /**
   * Account passed too many additional fields to their identity
   **/
  | "TooManyFieldsInIdentityInfo"
  /**
   * Account doesn't have a registered identity
   **/
  | "NotRegistered";

export type PalletCommitmentsRegistration = {
  deposit: bigint;
  block: number;
  info: PalletCommitmentsCommitmentInfo;
};

export type PalletCommitmentsUsageTracker = {
  lastEpoch: bigint;
  usedSpace: bigint;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCommitmentsError =
  /**
   * Account passed too many additional fields to their commitment
   **/
  | "TooManyFieldsInCommitmentInfo"
  /**
   * Account is not allowed to make commitments to the chain
   **/
  | "AccountNotAllowedCommit"
  /**
   * Space Limit Exceeded for the current interval
   **/
  | "SpaceLimitExceeded"
  /**
   * Indicates that unreserve returned a leftover, which is unexpected.
   **/
  | "UnexpectedUnreserveLeftover";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAdminUtilsError =
  /**
   * The subnet does not exist, check the netuid parameter
   **/
  | "SubnetDoesNotExist"
  /**
   * The maximum number of subnet validators must be less than the maximum number of allowed UIDs in the subnet.
   **/
  | "MaxValidatorsLargerThanMaxUIds"
  /**
   * The maximum number of subnet validators must be more than the current number of UIDs already in the subnet.
   **/
  | "MaxAllowedUIdsLessThanCurrentUIds"
  /**
   * The maximum value for bonds moving average is reached
   **/
  | "BondsMovingAverageMaxReached";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSafeModeError =
  /**
   * The safe-mode is (already or still) entered.
   **/
  | "Entered"
  /**
   * The safe-mode is (already or still) exited.
   **/
  | "Exited"
  /**
   * This functionality of the pallet is disabled by the configuration.
   **/
  | "NotConfigured"
  /**
   * There is no balance reserved.
   **/
  | "NoDeposit"
  /**
   * The account already has a deposit reserved and can therefore not enter or extend again.
   **/
  | "AlreadyDeposited"
  /**
   * This deposit cannot be released yet.
   **/
  | "CannotReleaseYet"
  /**
   * An error from the underlying `Currency`.
   **/
  | "CurrencyError";

export type FpRpcTransactionStatus = {
  transactionHash: H256;
  transactionIndex: number;
  from: H160;
  to?: H160 | undefined;
  contractAddress?: H160 | undefined;
  logs: Array<EthereumLog>;
  logsBloom: EthbloomBloom;
};

export type EthbloomBloom = FixedBytes<256>;

export type EthereumReceiptReceiptV3 =
  | { type: "Legacy"; value: EthereumReceiptEip658ReceiptData }
  | { type: "Eip2930"; value: EthereumReceiptEip658ReceiptData }
  | { type: "Eip1559"; value: EthereumReceiptEip658ReceiptData };

export type EthereumReceiptEip658ReceiptData = {
  statusCode: number;
  usedGas: U256;
  logsBloom: EthbloomBloom;
  logs: Array<EthereumLog>;
};

export type EthereumBlock = {
  header: EthereumHeader;
  transactions: Array<EthereumTransactionTransactionV2>;
  ommers: Array<EthereumHeader>;
};

export type EthereumHeader = {
  parentHash: H256;
  ommersHash: H256;
  beneficiary: H160;
  stateRoot: H256;
  transactionsRoot: H256;
  receiptsRoot: H256;
  logsBloom: EthbloomBloom;
  difficulty: U256;
  number: U256;
  gasLimit: U256;
  gasUsed: U256;
  timestamp: bigint;
  extraData: Bytes;
  mixHash: H256;
  nonce: EthereumTypesHashH64;
};

export type EthereumTypesHashH64 = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEthereumError =
  /**
   * Signature is invalid.
   **/
  | "InvalidSignature"
  /**
   * Pre-log is present, therefore transact is not allowed.
   **/
  | "PreLogExists";

export type PalletEvmCodeMetadata = { size: bigint; hash: H256 };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletEvmError =
  /**
   * Not enough balance to perform action
   **/
  | "BalanceLow"
  /**
   * Calculating total fee overflowed
   **/
  | "FeeOverflow"
  /**
   * Calculating total payment overflowed
   **/
  | "PaymentOverflow"
  /**
   * Withdraw fee failed
   **/
  | "WithdrawFailed"
  /**
   * Gas price is too low.
   **/
  | "GasPriceTooLow"
  /**
   * Nonce is invalid
   **/
  | "InvalidNonce"
  /**
   * Gas limit is too low.
   **/
  | "GasLimitTooLow"
  /**
   * Gas limit is too high.
   **/
  | "GasLimitTooHigh"
  /**
   * The chain id is invalid.
   **/
  | "InvalidChainId"
  /**
   * the signature is invalid.
   **/
  | "InvalidSignature"
  /**
   * EVM reentrancy
   **/
  | "Reentrancy"
  /**
   * EIP-3607,
   **/
  | "TransactionMustComeFromEOA"
  /**
   * Undefined error.
   **/
  | "Undefined"
  /**
   * Origin is not allowed to perform the operation.
   **/
  | "NotAllowed";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDrandError =
  /**
   * The value retrieved was `None` as no value was previously set.
   **/
  | "NoneValue"
  /**
   * There was an attempt to increment the value in storage over `u32::MAX`.
   **/
  | "StorageOverflow"
  /**
   * failed to connect to the
   **/
  | "DrandConnectionFailure"
  /**
   * the pulse is invalid
   **/
  | "UnverifiedPulse"
  /**
   * the round number did not increment
   **/
  | "InvalidRoundNumber"
  /**
   * the pulse could not be verified
   **/
  | "PulseVerificationError";

export type PalletCrowdloanCrowdloanInfo = {
  creator: AccountId32;
  deposit: bigint;
  minContribution: bigint;
  end: number;
  cap: bigint;
  fundsAccount: AccountId32;
  raised: bigint;
  targetAddress?: AccountId32 | undefined;
  call?: FrameSupportPreimagesBounded | undefined;
  finalized: boolean;
  contributorsCount: number;
};

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCrowdloanError =
  /**
   * The crowdloan initial deposit is too low.
   **/
  | "DepositTooLow"
  /**
   * The crowdloan cap is too low.
   **/
  | "CapTooLow"
  /**
   * The minimum contribution is too low.
   **/
  | "MinimumContributionTooLow"
  /**
   * The crowdloan cannot end in the past.
   **/
  | "CannotEndInPast"
  /**
   * The crowdloan block duration is too short.
   **/
  | "BlockDurationTooShort"
  /**
   * The block duration is too long.
   **/
  | "BlockDurationTooLong"
  /**
   * The account does not have enough balance to pay for the initial deposit/contribution.
   **/
  | "InsufficientBalance"
  /**
   * An overflow occurred.
   **/
  | "Overflow"
  /**
   * The crowdloan id is invalid.
   **/
  | "InvalidCrowdloanId"
  /**
   * The crowdloan cap has been fully raised.
   **/
  | "CapRaised"
  /**
   * The contribution period has ended.
   **/
  | "ContributionPeriodEnded"
  /**
   * The contribution is too low.
   **/
  | "ContributionTooLow"
  /**
   * The origin of this call is invalid.
   **/
  | "InvalidOrigin"
  /**
   * The crowdloan has already been finalized.
   **/
  | "AlreadyFinalized"
  /**
   * The crowdloan contribution period has not ended yet.
   **/
  | "ContributionPeriodNotEnded"
  /**
   * The contributor has no contribution for this crowdloan.
   **/
  | "NoContribution"
  /**
   * The crowdloan cap has not been raised.
   **/
  | "CapNotRaised"
  /**
   * An underflow occurred.
   **/
  | "Underflow"
  /**
   * Call to dispatch was not found in the preimage storage.
   **/
  | "CallUnavailable"
  /**
   * The crowdloan is not ready to be dissolved, it still has contributions.
   **/
  | "NotReadyToDissolve"
  /**
   * The deposit cannot be withdrawn from the crowdloan.
   **/
  | "DepositCannotBeWithdrawn"
  /**
   * The maximum number of contributors has been reached.
   **/
  | "MaxContributorsReached";

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type NodeSubtensorRuntimeCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletTransactionPaymentChargeTransactionPayment = bigint;

export type PalletSubtensorSubtensorSignedExtension = {};

export type NodeSubtensorRuntimeRuntime = {};

export type PalletCommitmentsCommitmentsSignedExtension = {};

export type FrameMetadataHashExtensionCheckMetadataHash = {
  mode: FrameMetadataHashExtensionMode;
};

export type FrameMetadataHashExtensionMode = "Disabled" | "Enabled";

export type SpRuntimeBlock = {
  header: Header;
  extrinsics: Array<FpSelfContainedUncheckedExtrinsic>;
};

export type FpSelfContainedUncheckedExtrinsic = UncheckedExtrinsic;

export type SpRuntimeExtrinsicInclusionMode = "AllExtrinsics" | "OnlyInherents";

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: "Invalid"; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: "Unknown"; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: "Call" }
  | { type: "Payment" }
  | { type: "Future" }
  | { type: "Stale" }
  | { type: "BadProof" }
  | { type: "AncientBirthBlock" }
  | { type: "ExhaustsResources" }
  | { type: "Custom"; value: number }
  | { type: "BadMandatory" }
  | { type: "MandatoryValidation" }
  | { type: "BadSigner" };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: "CannotLookup" }
  | { type: "NoUnsignedValidator" }
  | { type: "Custom"; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = {
  okay: boolean;
  fatalError: boolean;
  errors: SpInherentsInherentData;
};

export type SpRuntimeTransactionValidityTransactionSource =
  | "InBlock"
  | "Local"
  | "External";

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type SpConsensusSlotsSlotDuration = bigint;

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

export type SpRuntimeOpaqueValue = Bytes;

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = {
  baseFee: bigint;
  lenFee: bigint;
  adjustedWeightFee: bigint;
};

export type EvmBackendBasic = { balance: U256; nonce: U256 };

export type FpEvmExecutionInfoV2 = {
  exitReason: EvmCoreErrorExitReason;
  value: Bytes;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type FpEvmUsedGas = { standard: U256; effective: U256 };

export type FpEvmWeightInfo = {
  refTimeLimit?: bigint | undefined;
  proofSizeLimit?: bigint | undefined;
  refTimeUsage?: bigint | undefined;
  proofSizeUsage?: bigint | undefined;
};

export type FpEvmExecutionInfoV2H160 = {
  exitReason: EvmCoreErrorExitReason;
  value: H160;
  usedGas: FpEvmUsedGas;
  weightInfo?: FpEvmWeightInfo | undefined;
  logs: Array<EthereumLog>;
};

export type PalletSubtensorRpcInfoDelegateInfo = {
  delegateSs58: AccountId32;
  take: number;
  nominators: Array<[AccountId32, Array<[number, bigint]>]>;
  ownerSs58: AccountId32;
  registrations: Array<number>;
  validatorPermits: Array<number>;
  returnPer1000: bigint;
  totalDailyReturn: bigint;
};

export type PalletSubtensorRpcInfoNeuronInfo = {
  hotkey: AccountId32;
  coldkey: AccountId32;
  uid: number;
  netuid: number;
  active: boolean;
  axonInfo: PalletSubtensorAxonInfo;
  prometheusInfo: PalletSubtensorPrometheusInfo;
  stake: Array<[AccountId32, bigint]>;
  rank: number;
  emission: bigint;
  incentive: number;
  consensus: number;
  trust: number;
  validatorTrust: number;
  dividends: number;
  lastUpdate: bigint;
  validatorPermit: boolean;
  weights: Array<[number, number]>;
  bonds: Array<[number, number]>;
  pruningScore: number;
};

export type PalletSubtensorRpcInfoNeuronInfoNeuronInfoLite = {
  hotkey: AccountId32;
  coldkey: AccountId32;
  uid: number;
  netuid: number;
  active: boolean;
  axonInfo: PalletSubtensorAxonInfo;
  prometheusInfo: PalletSubtensorPrometheusInfo;
  stake: Array<[AccountId32, bigint]>;
  rank: number;
  emission: bigint;
  incentive: number;
  consensus: number;
  trust: number;
  validatorTrust: number;
  dividends: number;
  lastUpdate: bigint;
  validatorPermit: boolean;
  pruningScore: number;
};

export type PalletSubtensorRpcInfoSubnetInfo = {
  netuid: number;
  rho: number;
  kappa: number;
  difficulty: bigint;
  immunityPeriod: number;
  maxAllowedValidators: number;
  minAllowedWeights: number;
  maxWeightsLimit: number;
  scalingLawPower: number;
  subnetworkN: number;
  maxAllowedUids: number;
  blocksSinceLastStep: bigint;
  tempo: number;
  networkModality: number;
  networkConnect: Array<FixedArray<number, 2>>;
  emissionValues: bigint;
  burn: bigint;
  owner: AccountId32;
};

export type PalletSubtensorRpcInfoSubnetInfoSubnetInfov2 = {
  netuid: number;
  rho: number;
  kappa: number;
  difficulty: bigint;
  immunityPeriod: number;
  maxAllowedValidators: number;
  minAllowedWeights: number;
  maxWeightsLimit: number;
  scalingLawPower: number;
  subnetworkN: number;
  maxAllowedUids: number;
  blocksSinceLastStep: bigint;
  tempo: number;
  networkModality: number;
  networkConnect: Array<FixedArray<number, 2>>;
  emissionValue: bigint;
  burn: bigint;
  owner: AccountId32;
  identity?: PalletSubtensorSubnetIdentityV2 | undefined;
};

export type PalletSubtensorRpcInfoSubnetInfoSubnetHyperparams = {
  rho: number;
  kappa: number;
  immunityPeriod: number;
  minAllowedWeights: number;
  maxWeightsLimit: number;
  tempo: number;
  minDifficulty: bigint;
  maxDifficulty: bigint;
  weightsVersion: bigint;
  weightsRateLimit: bigint;
  adjustmentInterval: number;
  activityCutoff: number;
  registrationAllowed: boolean;
  targetRegsPerInterval: number;
  minBurn: bigint;
  maxBurn: bigint;
  bondsMovingAvg: bigint;
  maxRegsPerBlock: number;
  servingRateLimit: bigint;
  maxValidators: number;
  adjustmentAlpha: bigint;
  difficulty: bigint;
  commitRevealPeriod: bigint;
  commitRevealWeightsEnabled: boolean;
  alphaHigh: number;
  alphaLow: number;
  liquidAlphaEnabled: boolean;
};

export type PalletSubtensorRpcInfoDynamicInfo = {
  netuid: number;
  ownerHotkey: AccountId32;
  ownerColdkey: AccountId32;
  subnetName: Array<number>;
  tokenSymbol: Array<number>;
  tempo: number;
  lastStep: bigint;
  blocksSinceLastStep: bigint;
  emission: bigint;
  alphaIn: bigint;
  alphaOut: bigint;
  taoIn: bigint;
  alphaOutEmission: bigint;
  alphaInEmission: bigint;
  taoInEmission: bigint;
  pendingAlphaEmission: bigint;
  pendingRootEmission: bigint;
  subnetVolume: bigint;
  networkRegisteredAt: bigint;
  subnetIdentity?: PalletSubtensorSubnetIdentityV2 | undefined;
  movingPrice: SubstrateFixedFixedI128;
};

export type PalletSubtensorRpcInfoMetagraph = {
  netuid: number;
  name: Array<number>;
  symbol: Array<number>;
  identity?: PalletSubtensorSubnetIdentityV2 | undefined;
  networkRegisteredAt: bigint;
  ownerHotkey: AccountId32;
  ownerColdkey: AccountId32;
  block: bigint;
  tempo: number;
  lastStep: bigint;
  blocksSinceLastStep: bigint;
  subnetEmission: bigint;
  alphaIn: bigint;
  alphaOut: bigint;
  taoIn: bigint;
  alphaOutEmission: bigint;
  alphaInEmission: bigint;
  taoInEmission: bigint;
  pendingAlphaEmission: bigint;
  pendingRootEmission: bigint;
  subnetVolume: bigint;
  movingPrice: SubstrateFixedFixedI128;
  rho: number;
  kappa: number;
  minAllowedWeights: number;
  maxWeightsLimit: number;
  weightsVersion: bigint;
  weightsRateLimit: bigint;
  activityCutoff: number;
  maxValidators: number;
  numUids: number;
  maxUids: number;
  burn: bigint;
  difficulty: bigint;
  registrationAllowed: boolean;
  powRegistrationAllowed: boolean;
  immunityPeriod: number;
  minDifficulty: bigint;
  maxDifficulty: bigint;
  minBurn: bigint;
  maxBurn: bigint;
  adjustmentAlpha: bigint;
  adjustmentInterval: number;
  targetRegsPerInterval: number;
  maxRegsPerBlock: number;
  servingRateLimit: bigint;
  commitRevealWeightsEnabled: boolean;
  commitRevealPeriod: bigint;
  liquidAlphaEnabled: boolean;
  alphaHigh: number;
  alphaLow: number;
  bondsMovingAvg: bigint;
  hotkeys: Array<AccountId32>;
  coldkeys: Array<AccountId32>;
  identities: Array<PalletSubtensorChainIdentityV2 | undefined>;
  axons: Array<PalletSubtensorAxonInfo>;
  active: Array<boolean>;
  validatorPermit: Array<boolean>;
  pruningScore: Array<number>;
  lastUpdate: Array<bigint>;
  emission: Array<bigint>;
  dividends: Array<number>;
  incentives: Array<number>;
  consensus: Array<number>;
  trust: Array<number>;
  rank: Array<number>;
  blockAtRegistration: Array<bigint>;
  alphaStake: Array<bigint>;
  taoStake: Array<bigint>;
  totalStake: Array<bigint>;
  taoDividendsPerHotkey: Array<[AccountId32, bigint]>;
  alphaDividendsPerHotkey: Array<[AccountId32, bigint]>;
};

export type PalletSubtensorRpcInfoShowSubnetSubnetState = {
  netuid: number;
  hotkeys: Array<AccountId32>;
  coldkeys: Array<AccountId32>;
  active: Array<boolean>;
  validatorPermit: Array<boolean>;
  pruningScore: Array<number>;
  lastUpdate: Array<bigint>;
  emission: Array<bigint>;
  dividends: Array<number>;
  incentives: Array<number>;
  consensus: Array<number>;
  trust: Array<number>;
  rank: Array<number>;
  blockAtRegistration: Array<bigint>;
  alphaStake: Array<bigint>;
  taoStake: Array<bigint>;
  totalStake: Array<bigint>;
  emissionHistory: Array<Array<bigint>>;
};

export type PalletSubtensorRpcInfoMetagraphSelectiveMetagraph = {
  netuid: number;
  name?: Array<number> | undefined;
  symbol?: Array<number> | undefined;
  identity?: PalletSubtensorSubnetIdentityV2 | undefined | undefined;
  networkRegisteredAt?: bigint | undefined;
  ownerHotkey?: AccountId32 | undefined;
  ownerColdkey?: AccountId32 | undefined;
  block?: bigint | undefined;
  tempo?: number | undefined;
  lastStep?: bigint | undefined;
  blocksSinceLastStep?: bigint | undefined;
  subnetEmission?: bigint | undefined;
  alphaIn?: bigint | undefined;
  alphaOut?: bigint | undefined;
  taoIn?: bigint | undefined;
  alphaOutEmission?: bigint | undefined;
  alphaInEmission?: bigint | undefined;
  taoInEmission?: bigint | undefined;
  pendingAlphaEmission?: bigint | undefined;
  pendingRootEmission?: bigint | undefined;
  subnetVolume?: bigint | undefined;
  movingPrice?: SubstrateFixedFixedI128 | undefined;
  rho?: number | undefined;
  kappa?: number | undefined;
  minAllowedWeights?: number | undefined;
  maxWeightsLimit?: number | undefined;
  weightsVersion?: bigint | undefined;
  weightsRateLimit?: bigint | undefined;
  activityCutoff?: number | undefined;
  maxValidators?: number | undefined;
  numUids?: number | undefined;
  maxUids?: number | undefined;
  burn?: bigint | undefined;
  difficulty?: bigint | undefined;
  registrationAllowed?: boolean | undefined;
  powRegistrationAllowed?: boolean | undefined;
  immunityPeriod?: number | undefined;
  minDifficulty?: bigint | undefined;
  maxDifficulty?: bigint | undefined;
  minBurn?: bigint | undefined;
  maxBurn?: bigint | undefined;
  adjustmentAlpha?: bigint | undefined;
  adjustmentInterval?: number | undefined;
  targetRegsPerInterval?: number | undefined;
  maxRegsPerBlock?: number | undefined;
  servingRateLimit?: bigint | undefined;
  commitRevealWeightsEnabled?: boolean | undefined;
  commitRevealPeriod?: bigint | undefined;
  liquidAlphaEnabled?: boolean | undefined;
  alphaHigh?: number | undefined;
  alphaLow?: number | undefined;
  bondsMovingAvg?: bigint | undefined;
  hotkeys?: Array<AccountId32> | undefined;
  coldkeys?: Array<AccountId32> | undefined;
  identities?: Array<PalletSubtensorChainIdentityV2 | undefined> | undefined;
  axons?: Array<PalletSubtensorAxonInfo> | undefined;
  active?: Array<boolean> | undefined;
  validatorPermit?: Array<boolean> | undefined;
  pruningScore?: Array<number> | undefined;
  lastUpdate?: Array<bigint> | undefined;
  emission?: Array<bigint> | undefined;
  dividends?: Array<number> | undefined;
  incentives?: Array<number> | undefined;
  consensus?: Array<number> | undefined;
  trust?: Array<number> | undefined;
  rank?: Array<number> | undefined;
  blockAtRegistration?: Array<bigint> | undefined;
  alphaStake?: Array<bigint> | undefined;
  taoStake?: Array<bigint> | undefined;
  totalStake?: Array<bigint> | undefined;
  taoDividendsPerHotkey?: Array<[AccountId32, bigint]> | undefined;
  alphaDividendsPerHotkey?: Array<[AccountId32, bigint]> | undefined;
};

export type PalletSubtensorRpcInfoStakeInfo = {
  hotkey: AccountId32;
  coldkey: AccountId32;
  netuid: number;
  stake: bigint;
  locked: bigint;
  emission: bigint;
  taoEmission: bigint;
  drain: bigint;
  isRegistered: boolean;
};

export type NodeSubtensorRuntimeRuntimeError =
  | { pallet: "System"; palletError: FrameSystemError }
  | { pallet: "Grandpa"; palletError: PalletGrandpaError }
  | { pallet: "Balances"; palletError: PalletBalancesError }
  | { pallet: "SubtensorModule"; palletError: PalletSubtensorError }
  | { pallet: "Triumvirate"; palletError: PalletCollectiveError }
  | { pallet: "TriumvirateMembers"; palletError: PalletMembershipError }
  | { pallet: "SenateMembers"; palletError: PalletMembershipError }
  | { pallet: "Utility"; palletError: PalletUtilityError }
  | { pallet: "Sudo"; palletError: PalletSudoError }
  | { pallet: "Multisig"; palletError: PalletMultisigError }
  | { pallet: "Preimage"; palletError: PalletPreimageError }
  | { pallet: "Scheduler"; palletError: PalletSchedulerError }
  | { pallet: "Proxy"; palletError: PalletProxyError }
  | { pallet: "Registry"; palletError: PalletRegistryError }
  | { pallet: "Commitments"; palletError: PalletCommitmentsError }
  | { pallet: "AdminUtils"; palletError: PalletAdminUtilsError }
  | { pallet: "SafeMode"; palletError: PalletSafeModeError }
  | { pallet: "Ethereum"; palletError: PalletEthereumError }
  | { pallet: "Evm"; palletError: PalletEvmError }
  | { pallet: "Drand"; palletError: PalletDrandError }
  | { pallet: "Crowdloan"; palletError: PalletCrowdloanError };
