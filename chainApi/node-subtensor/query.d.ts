// Generated by dedot cli

import type {
  GenericChainStorage,
  GenericStorageQuery,
  Callback,
  RpcVersion,
} from "dedot/types";
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedU128,
  BytesLike,
  H160,
  FixedBytes,
  U256,
  Permill,
} from "dedot/codecs";
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  PalletGrandpaStoredState,
  PalletGrandpaStoredPendingChange,
  SpConsensusGrandpaAppPublic,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmount,
  FrameSupportTokensMiscIdAmountRuntimeFreezeReason,
  PalletTransactionPaymentReleases,
  PalletSubtensorStakeJob,
  SubstrateFixedFixedI128,
  SubstrateFixedFixedU128,
  PalletSubtensorRateLimitKey,
  PalletSubtensorAxonInfo,
  PalletSubtensorNeuronCertificate,
  PalletSubtensorPrometheusInfo,
  PalletSubtensorChainIdentity,
  PalletSubtensorChainIdentityV2,
  PalletSubtensorSubnetIdentity,
  PalletSubtensorSubnetIdentityV2,
  NodeSubtensorRuntimeRuntimeCall,
  PalletCollectiveVotes,
  PalletMultisigMultisig,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletRegistryRegistration,
  PalletCommitmentsRegistration,
  PalletCommitmentsUsageTracker,
  PalletAdminUtilsPrecompileEnum,
  EthereumTransactionTransactionV2,
  FpRpcTransactionStatus,
  EthereumReceiptReceiptV3,
  EthereumBlock,
  PalletEvmCodeMetadata,
  PalletDrandBeaconConfiguration,
  PalletDrandPulse,
  PalletCrowdloanCrowdloanInfo,
} from "./types";

export interface ChainStorage<Rv extends RpcVersion>
  extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => FrameSystemAccountInfo,
      AccountId32
    >;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<
      Rv,
      () => FrameSupportDispatchPerDispatchClass
    >;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<
      Rv,
      (arg: H256) => Array<[number, number]>,
      H256
    >;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemLastRuntimeUpgradeInfo | undefined
    >;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemCodeUpgradeAuthorization | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `RandomnessCollectiveFlip`'s storage queries
   **/
  randomnessCollectiveFlip: {
    /**
     * Series of block headers from the last 81 blocks that acts as random seed material. This
     * is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of
     * the oldest hash.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    randomMaterial: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<SpConsensusAuraSr25519AppSr25519Public>
    >;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Grandpa`'s storage queries
   **/
  grandpa: {
    /**
     * State of the current authority set.
     *
     * @param {Callback<PalletGrandpaStoredState> =} callback
     **/
    state: GenericStorageQuery<Rv, () => PalletGrandpaStoredState>;

    /**
     * Pending change: (signaled at, scheduled change).
     *
     * @param {Callback<PalletGrandpaStoredPendingChange | undefined> =} callback
     **/
    pendingChange: GenericStorageQuery<
      Rv,
      () => PalletGrandpaStoredPendingChange | undefined
    >;

    /**
     * next block number where we can force a change.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextForced: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * `true` if we are currently stalled.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    stalled: GenericStorageQuery<Rv, () => [number, number] | undefined>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     *
     * @param {Callback<bigint> =} callback
     **/
    currentSetId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     *
     * @param {bigint} arg
     * @param {Callback<number | undefined> =} callback
     **/
    setIdSession: GenericStorageQuery<
      Rv,
      (arg: bigint) => number | undefined,
      bigint
    >;

    /**
     * The current list of authorities.
     *
     * @param {Callback<Array<[SpConsensusGrandpaAppPublic, bigint]>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<[SpConsensusGrandpaAppPublic, bigint]>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletBalancesAccountData,
      AccountId32
    >;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>,
      AccountId32
    >;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesReserveData>,
      AccountId32
    >;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>,
      AccountId32
    >;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<
      Rv,
      () => PalletTransactionPaymentReleases
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `SubtensorModule`'s storage queries
   **/
  subtensorModule: {
    /**
     *
     * @param {Callback<number> =} callback
     **/
    minActivityCutoff: GenericStorageQuery<Rv, () => number>;

    /**
     *
     * @param {Callback<number> =} callback
     **/
    coldkeySwapScheduleDuration: GenericStorageQuery<Rv, () => number>;

    /**
     *
     * @param {Callback<number> =} callback
     **/
    coldkeySwapRescheduleDuration: GenericStorageQuery<Rv, () => number>;

    /**
     *
     * @param {Callback<number> =} callback
     **/
    dissolveNetworkScheduleDuration: GenericStorageQuery<Rv, () => number>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    senateRequiredStakePercentage: GenericStorageQuery<Rv, () => bigint>;

    /**
     *
     * @param {[number, bigint]} arg
     * @param {Callback<PalletSubtensorStakeJob | undefined> =} callback
     **/
    stakeJobs: GenericStorageQuery<
      Rv,
      (arg: [number, bigint]) => PalletSubtensorStakeJob | undefined,
      [number, bigint]
    >;

    /**
     * --- DMap ( netuid, coldkey ) --> blocknumber | last hotkey swap on network.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint> =} callback
     **/
    lastHotkeySwapOnNetuid: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => bigint,
      [number, AccountId32]
    >;

    /**
     * Ensures unique IDs for StakeJobs storage map
     *
     * @param {Callback<bigint> =} callback
     **/
    nextStakeJobId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ============================
     * ==== Staking Variables ====
     * ============================
     * The Subtensor [`TotalIssuance`] represents the total issuance of tokens on the Bittensor network.
     *
     * It is comprised of three parts:
     * - The total amount of issued tokens, tracked in the TotalIssuance of the Balances pallet
     * - The total amount of tokens staked in the system, tracked in [`TotalStake`]
     * - The total amount of tokens locked up for subnet reg, tracked in [`TotalSubnetLocked`] attained by iterating over subnet lock.
     *
     * Eventually, Bittensor should migrate to using Holds afterwhich time we will not require this
     * separate accounting.
     * --- ITEM --> Global weight
     *
     * @param {Callback<bigint> =} callback
     **/
    taoWeight: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- ITEM ( default_delegate_take )
     *
     * @param {Callback<number> =} callback
     **/
    maxDelegateTake: GenericStorageQuery<Rv, () => number>;

    /**
     * --- ITEM ( min_delegate_take )
     *
     * @param {Callback<number> =} callback
     **/
    minDelegateTake: GenericStorageQuery<Rv, () => number>;

    /**
     * --- ITEM ( default_childkey_take )
     *
     * @param {Callback<number> =} callback
     **/
    maxChildkeyTake: GenericStorageQuery<Rv, () => number>;

    /**
     * --- ITEM ( min_childkey_take )
     *
     * @param {Callback<number> =} callback
     **/
    minChildkeyTake: GenericStorageQuery<Rv, () => number>;

    /**
     * MAP ( hot ) --> cold | Returns the controlling coldkey for a hotkey.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<AccountId32> =} callback
     **/
    owner: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => AccountId32,
      AccountId32
    >;

    /**
     * MAP ( hot ) --> take | Returns the hotkey delegation take. And signals that this key is open for delegation.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number> =} callback
     **/
    delegates: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => number,
      AccountId32
    >;

    /**
     * DMAP ( hot, netuid ) --> take | Returns the hotkey childkey take for a specific subnet
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<number> =} callback
     **/
    childkeyTake: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => number,
      [AccountId32, number]
    >;

    /**
     * DMAP ( netuid, parent ) --> (Vec<(proportion,child)>, cool_down_block)
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[Array<[bigint, AccountId32]>, bigint]> =} callback
     **/
    pendingChildKeys: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => [Array<[bigint, AccountId32]>, bigint],
      [number, AccountId32]
    >;

    /**
     * DMAP ( parent, netuid ) --> Vec<(proportion,child)>
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<Array<[bigint, AccountId32]>> =} callback
     **/
    childKeys: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => Array<[bigint, AccountId32]>,
      [AccountId32, number]
    >;

    /**
     * DMAP ( child, netuid ) --> Vec<(proportion,parent)>
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<Array<[bigint, AccountId32]>> =} callback
     **/
    parentKeys: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => Array<[bigint, AccountId32]>,
      [AccountId32, number]
    >;

    /**
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint> =} callback
     **/
    alphaDividendsPerSubnet: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => bigint,
      [number, AccountId32]
    >;

    /**
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint> =} callback
     **/
    taoDividendsPerSubnet: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => bigint,
      [number, AccountId32]
    >;

    /**
     * ==================
     * ==== Coinbase ====
     * ==================
     * --- ITEM ( global_block_emission )
     *
     * @param {Callback<bigint> =} callback
     **/
    blockEmission: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- DMap ( hot, netuid ) --> emission | last hotkey emission on network.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<bigint> =} callback
     **/
    lastHotkeyEmissionOnNetuid: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => bigint,
      [AccountId32, number]
    >;

    /**
     * ==========================
     * ==== Staking Counters ====
     * ==========================
     * The Subtensor [`TotalIssuance`] represents the total issuance of tokens on the Bittensor network.
     *
     * It is comprised of three parts:
     * - The total amount of issued tokens, tracked in the TotalIssuance of the Balances pallet
     * - The total amount of tokens staked in the system, tracked in [`TotalStake`]
     * - The total amount of tokens locked up for subnet reg, tracked in [`TotalSubnetLocked`] attained by iterating over subnet lock.
     *
     * Eventually, Bittensor should migrate to using Holds afterwhich time we will not require this
     * separate accounting.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    totalStake: GenericStorageQuery<Rv, () => bigint>;

    /**
     *
     * @param {Callback<SubstrateFixedFixedI128> =} callback
     **/
    subnetMovingAlpha: GenericStorageQuery<Rv, () => SubstrateFixedFixedI128>;

    /**
     *
     * @param {number} arg
     * @param {Callback<SubstrateFixedFixedI128> =} callback
     **/
    subnetMovingPrice: GenericStorageQuery<
      Rv,
      (arg: number) => SubstrateFixedFixedI128,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetVolume: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetTAO: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetAlphaInEmission: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetAlphaOutEmission: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetTaoInEmission: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetAlphaIn: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetAlphaOut: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    stakingHotkeys: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<AccountId32>,
      AccountId32
    >;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    ownedHotkeys: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<AccountId32>,
      AccountId32
    >;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[number, AccountId32]> =} callback
     **/
    coldkeySwapScheduled: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [number, AccountId32],
      AccountId32
    >;

    /**
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<bigint> =} callback
     **/
    totalHotkeyAlpha: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => bigint,
      [AccountId32, number]
    >;

    /**
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<bigint> =} callback
     **/
    totalHotkeyAlphaLastEpoch: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => bigint,
      [AccountId32, number]
    >;

    /**
     * DMAP ( hot, netuid ) --> total_alpha_shares | Returns the number of alpha shares for a hotkey on a subnet.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<SubstrateFixedFixedU128> =} callback
     **/
    totalHotkeyShares: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => SubstrateFixedFixedU128,
      [AccountId32, number]
    >;

    /**
     *
     * @param {[AccountId32Like, AccountId32Like, number]} arg
     * @param {Callback<SubstrateFixedFixedU128> =} callback
     **/
    alpha: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, AccountId32Like, number],
      ) => SubstrateFixedFixedU128,
      [AccountId32, AccountId32, number]
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    tokenSymbol: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * ============================
     * ==== Global Parameters =====
     * ============================
     * --- StorageItem Global Used Work.
     *
     * @param {BytesLike} arg
     * @param {Callback<bigint> =} callback
     **/
    usedWork: GenericStorageQuery<Rv, (arg: BytesLike) => bigint, Bytes>;

    /**
     * --- ITEM( global_max_registrations_per_block )
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    maxRegistrationsPerBlock: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- ITEM( total_number_of_existing_networks )
     *
     * @param {Callback<number> =} callback
     **/
    totalNetworks: GenericStorageQuery<Rv, () => number>;

    /**
     * ITEM( network_immunity_period )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkImmunityPeriod: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( network_last_registered_block )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkLastRegistered: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( min_network_lock_cost )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkMinLockCost: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( last_network_lock_cost )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkLastLockCost: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( network_lock_reduction_interval )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkLockReductionInterval: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( subnet_owner_cut )
     *
     * @param {Callback<number> =} callback
     **/
    subnetOwnerCut: GenericStorageQuery<Rv, () => number>;

    /**
     * ITEM( network_rate_limit )
     *
     * @param {Callback<bigint> =} callback
     **/
    networkRateLimit: GenericStorageQuery<Rv, () => bigint>;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    nominatorMinRequiredStake: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ITEM( weights_version_key_rate_limit ) --- Rate limit in tempos.
     *
     * @param {Callback<bigint> =} callback
     **/
    weightsVersionKeyRateLimit: GenericStorageQuery<Rv, () => bigint>;

    /**
     * ============================
     * ==== Rate Limiting =====
     * ============================
     * --- MAP ( RateLimitKey ) --> Block number in which the last rate limited operation occured
     *
     * @param {PalletSubtensorRateLimitKey} arg
     * @param {Callback<bigint> =} callback
     **/
    lastRateLimitedBlock: GenericStorageQuery<
      Rv,
      (arg: PalletSubtensorRateLimitKey) => bigint,
      PalletSubtensorRateLimitKey
    >;

    /**
     * ============================
     * ==== Subnet Locks =====
     * ============================
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    transferToggle: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    subnetLocked: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    largestLocked: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * =================
     * ==== Tempos =====
     * =================
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    tempo: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * ============================
     * ==== Subnet Parameters =====
     * ============================
     * --- MAP ( netuid ) --> block number of first emission
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    firstEmissionBlockNumber: GenericStorageQuery<
      Rv,
      (arg: number) => bigint | undefined,
      number
    >;

    /**
     * --- MAP ( netuid ) --> subnet mechanism
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    subnetMechanism: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> subnetwork_n (Number of UIDs in the network).
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    subnetworkN: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> modality TEXT: 0, IMAGE: 1, TENSOR: 2
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    networkModality: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> network_is_added
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    networksAdded: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     * --- DMAP ( hotkey, netuid ) --> bool
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<boolean> =} callback
     **/
    isNetworkMember: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => boolean,
      [AccountId32, number]
    >;

    /**
     * --- MAP ( netuid ) --> network_registration_allowed
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    networkRegistrationAllowed: GenericStorageQuery<
      Rv,
      (arg: number) => boolean,
      number
    >;

    /**
     * --- MAP ( netuid ) --> network_pow_allowed
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    networkPowRegistrationAllowed: GenericStorageQuery<
      Rv,
      (arg: number) => boolean,
      number
    >;

    /**
     * --- MAP ( netuid ) --> block_created
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    networkRegisteredAt: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> pending_emission
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    pendingEmission: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> pending_root_emission
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    pendingRootDivs: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> pending_alpha_swapped
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    pendingAlphaSwapped: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> pending_owner_cut
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    pendingOwnerCut: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> blocks_since_last_step
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    blocksSinceLastStep: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> last_mechanism_step_block
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    lastMechansimStepBlock: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> subnet_owner
     *
     * @param {number} arg
     * @param {Callback<AccountId32> =} callback
     **/
    subnetOwner: GenericStorageQuery<Rv, (arg: number) => AccountId32, number>;

    /**
     * --- MAP ( netuid ) --> subnet_owner_hotkey
     *
     * @param {number} arg
     * @param {Callback<AccountId32> =} callback
     **/
    subnetOwnerHotkey: GenericStorageQuery<
      Rv,
      (arg: number) => AccountId32,
      number
    >;

    /**
     * --- MAP ( netuid ) --> serving_rate_limit
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    servingRateLimit: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> Rho
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    rho: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> AlphaSigmoidSteepness
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    alphaSigmoidSteepness: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> Kappa
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    kappa: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> registrations_this_interval
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    registrationsThisInterval: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> pow_registrations_this_interval
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    powRegistrationsThisInterval: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> burn_registrations_this_interval
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    burnRegistrationsThisInterval: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> max_allowed_uids
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    maxAllowedUids: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> immunity_period
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    immunityPeriod: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> activity_cutoff
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    activityCutoff: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> max_weight_limit
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    maxWeightsLimit: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> weights_version_key
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    weightsVersionKey: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> min_allowed_weights
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    minAllowedWeights: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> max_allowed_validators
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    maxAllowedValidators: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> adjustment_interval
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    adjustmentInterval: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> bonds_moving_average
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    bondsMovingAverage: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> bonds_penalty
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    bondsPenalty: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> bonds_reset
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    bondsResetOn: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     * --- MAP ( netuid ) --> weights_set_rate_limit
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    weightsSetRateLimit: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> validator_prune_len
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    validatorPruneLen: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> scaling_law_power
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    scalingLawPower: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * --- MAP ( netuid ) --> target_registrations_this_interval
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    targetRegistrationsPerInterval: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> adjustment_alpha
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    adjustmentAlpha: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> commit reveal v2 weights are enabled
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    commitRevealWeightsEnabled: GenericStorageQuery<
      Rv,
      (arg: number) => boolean,
      number
    >;

    /**
     * --- MAP ( netuid ) --> Burn
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    burn: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> Difficulty
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    difficulty: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> MinBurn
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    minBurn: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> MaxBurn
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    maxBurn: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> MinDifficulty
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    minDifficulty: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> MaxDifficulty
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    maxDifficulty: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * --- MAP ( netuid ) --> Block at last adjustment.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    lastAdjustmentBlock: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> Registrations of this Block.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    registrationsThisBlock: GenericStorageQuery<
      Rv,
      (arg: number) => number,
      number
    >;

    /**
     * --- MAP ( netuid ) --> Halving time of average moving price.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    emaPriceHalvingBlocks: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- MAP ( netuid ) --> global_RAO_recycled_for_registration
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    raoRecycledForRegistration: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- ITEM ( tx_rate_limit )
     *
     * @param {Callback<bigint> =} callback
     **/
    txRateLimit: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- ITEM ( tx_delegate_take_rate_limit )
     *
     * @param {Callback<bigint> =} callback
     **/
    txDelegateTakeRateLimit: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- ITEM ( tx_childkey_take_rate_limit )
     *
     * @param {Callback<bigint> =} callback
     **/
    txChildkeyTakeRateLimit: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- MAP ( netuid ) --> Whether or not Liquid Alpha is enabled
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    liquidAlphaOn: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     * --- MAP ( netuid ) --> Whether or not Yuma3 is enabled
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    yuma3On: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     * MAP ( netuid ) --> (alpha_low, alpha_high)
     *
     * @param {number} arg
     * @param {Callback<[number, number]> =} callback
     **/
    alphaValues: GenericStorageQuery<
      Rv,
      (arg: number) => [number, number],
      number
    >;

    /**
     * --- MAP ( netuid ) --> If subtoken trading enabled
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    subtokenEnabled: GenericStorageQuery<Rv, (arg: number) => boolean, number>;

    /**
     * =======================================
     * ==== Subnetwork Consensus Storage ====
     * =======================================
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    stakeWeight: GenericStorageQuery<
      Rv,
      (arg: number) => Array<number>,
      number
    >;

    /**
     * --- DMAP ( netuid, hotkey ) --> uid
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    uids: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number | undefined,
      [number, AccountId32]
    >;

    /**
     * --- DMAP ( netuid, uid ) --> hotkey
     *
     * @param {[number, number]} arg
     * @param {Callback<AccountId32> =} callback
     **/
    keys: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => AccountId32,
      [number, number]
    >;

    /**
     * --- MAP ( netuid ) --> (hotkey, se, ve)
     *
     * @param {number} arg
     * @param {Callback<Array<[AccountId32, bigint, bigint]> | undefined> =} callback
     **/
    loadedEmission: GenericStorageQuery<
      Rv,
      (arg: number) => Array<[AccountId32, bigint, bigint]> | undefined,
      number
    >;

    /**
     * --- MAP ( netuid ) --> active
     *
     * @param {number} arg
     * @param {Callback<Array<boolean>> =} callback
     **/
    active: GenericStorageQuery<Rv, (arg: number) => Array<boolean>, number>;

    /**
     * --- MAP ( netuid ) --> rank
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    rank: GenericStorageQuery<Rv, (arg: number) => Array<number>, number>;

    /**
     * --- MAP ( netuid ) --> trust
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    trust: GenericStorageQuery<Rv, (arg: number) => Array<number>, number>;

    /**
     * --- MAP ( netuid ) --> consensus
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    consensus: GenericStorageQuery<Rv, (arg: number) => Array<number>, number>;

    /**
     * --- MAP ( netuid ) --> incentive
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    incentive: GenericStorageQuery<Rv, (arg: number) => Array<number>, number>;

    /**
     * --- MAP ( netuid ) --> dividends
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    dividends: GenericStorageQuery<Rv, (arg: number) => Array<number>, number>;

    /**
     * --- MAP ( netuid ) --> emission
     *
     * @param {number} arg
     * @param {Callback<Array<bigint>> =} callback
     **/
    emission: GenericStorageQuery<Rv, (arg: number) => Array<bigint>, number>;

    /**
     * --- MAP ( netuid ) --> last_update
     *
     * @param {number} arg
     * @param {Callback<Array<bigint>> =} callback
     **/
    lastUpdate: GenericStorageQuery<Rv, (arg: number) => Array<bigint>, number>;

    /**
     * --- MAP ( netuid ) --> validator_trust
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    validatorTrust: GenericStorageQuery<
      Rv,
      (arg: number) => Array<number>,
      number
    >;

    /**
     * --- MAP ( netuid ) --> pruning_scores
     *
     * @param {number} arg
     * @param {Callback<Array<number>> =} callback
     **/
    pruningScores: GenericStorageQuery<
      Rv,
      (arg: number) => Array<number>,
      number
    >;

    /**
     * --- MAP ( netuid ) --> validator_permit
     *
     * @param {number} arg
     * @param {Callback<Array<boolean>> =} callback
     **/
    validatorPermit: GenericStorageQuery<
      Rv,
      (arg: number) => Array<boolean>,
      number
    >;

    /**
     * --- DMAP ( netuid, uid ) --> weights
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    weights: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => Array<[number, number]>,
      [number, number]
    >;

    /**
     * --- DMAP ( netuid, uid ) --> bonds
     *
     * @param {[number, number]} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    bonds: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => Array<[number, number]>,
      [number, number]
    >;

    /**
     * --- DMAP ( netuid, uid ) --> block_at_registration
     *
     * @param {[number, number]} arg
     * @param {Callback<bigint> =} callback
     **/
    blockAtRegistration: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => bigint,
      [number, number]
    >;

    /**
     * --- MAP ( netuid, hotkey ) --> axon_info
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSubtensorAxonInfo | undefined> =} callback
     **/
    axons: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletSubtensorAxonInfo | undefined,
      [number, AccountId32]
    >;

    /**
     * --- MAP ( netuid, hotkey ) --> certificate
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSubtensorNeuronCertificate | undefined> =} callback
     **/
    neuronCertificates: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => PalletSubtensorNeuronCertificate | undefined,
      [number, AccountId32]
    >;

    /**
     * --- MAP ( netuid, hotkey ) --> prometheus_info
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletSubtensorPrometheusInfo | undefined> =} callback
     **/
    prometheus: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => PalletSubtensorPrometheusInfo | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSubtensorChainIdentity | undefined> =} callback
     **/
    identities: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletSubtensorChainIdentity | undefined,
      AccountId32
    >;

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletSubtensorChainIdentityV2 | undefined> =} callback
     **/
    identitiesV2: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletSubtensorChainIdentityV2 | undefined,
      AccountId32
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletSubtensorSubnetIdentity | undefined> =} callback
     **/
    subnetIdentities: GenericStorageQuery<
      Rv,
      (arg: number) => PalletSubtensorSubnetIdentity | undefined,
      number
    >;

    /**
     *
     * @param {number} arg
     * @param {Callback<PalletSubtensorSubnetIdentityV2 | undefined> =} callback
     **/
    subnetIdentitiesV2: GenericStorageQuery<
      Rv,
      (arg: number) => PalletSubtensorSubnetIdentityV2 | undefined,
      number
    >;

    /**
     * =================================
     * ==== Axon / Promo Endpoints =====
     * =================================
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<bigint> =} callback
     **/
    transactionKeyLastBlock: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => bigint,
      [AccountId32, number, number]
    >;

    /**
     * --- MAP ( key ) --> last_block
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    lastTxBlock: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => bigint,
      AccountId32
    >;

    /**
     * --- MAP ( key ) --> last_tx_block_childkey_take
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    lastTxBlockChildKeyTake: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => bigint,
      AccountId32
    >;

    /**
     * --- MAP ( key ) --> last_tx_block_delegate_take
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint> =} callback
     **/
    lastTxBlockDelegateTake: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => bigint,
      AccountId32
    >;

    /**
     * ITEM( weights_min_stake )
     *
     * @param {Callback<bigint> =} callback
     **/
    stakeThreshold: GenericStorageQuery<Rv, () => bigint>;

    /**
     * --- MAP (netuid, who) --> VecDeque<(hash, commit_block, first_reveal_block, last_reveal_block)> | Stores a queue of commits for an account on a given netuid.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<Array<[H256, bigint, bigint, bigint]> | undefined> =} callback
     **/
    weightCommits: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => Array<[H256, bigint, bigint, bigint]> | undefined,
      [number, AccountId32]
    >;

    /**
     * --- MAP (netuid, commit_epoch) --> VecDeque<(who, serialized_compressed_commit, reveal_round)> | Stores a queue of v3 commits for an account on a given netuid.
     *
     * @param {[number, bigint]} arg
     * @param {Callback<Array<[AccountId32, Bytes, bigint]>> =} callback
     **/
    crv3WeightCommits: GenericStorageQuery<
      Rv,
      (arg: [number, bigint]) => Array<[AccountId32, Bytes, bigint]>,
      [number, bigint]
    >;

    /**
     * --- Map (netuid) --> Number of epochs allowed for commit reveal periods
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    revealPeriodEpochs: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * --- Map (coldkey, hotkey) --> u64 the last block at which stake was added/removed.
     *
     * @param {[AccountId32Like, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    lastColdkeyHotkeyStakeBlock: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, AccountId32Like]) => bigint | undefined,
      [AccountId32, AccountId32]
    >;

    /**
     * =============================
     * ==== EVM related storage ====
     * =============================
     * --- DMAP (netuid, uid) --> (H160, last_block_where_ownership_was_proven)
     *
     * @param {[number, number]} arg
     * @param {Callback<[H160, bigint] | undefined> =} callback
     **/
    associatedEvmAddress: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [H160, bigint] | undefined,
      [number, number]
    >;

    /**
     * ==================
     * ==== Genesis =====
     * ==================
     *
     * @param {BytesLike} arg
     * @param {Callback<boolean> =} callback
     **/
    hasMigrationRun: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => boolean,
      Bytes
    >;

    /**
     * Storage value for pending childkey cooldown, settable by root.
     *
     * @param {Callback<bigint> =} callback
     **/
    pendingChildKeyCooldown: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Triumvirate`'s storage queries
   **/
  triumvirate: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<NodeSubtensorRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<
      Rv,
      (arg: H256) => NodeSubtensorRuntimeRuntimeCall | undefined,
      H256
    >;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletCollectiveVotes | undefined,
      H256
    >;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TriumvirateMembers`'s storage queries
   **/
  triumvirateMembers: {
    /**
     * The current membership, stored as an ordered Vec.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The current prime member, if one exists.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `SenateMembers`'s storage queries
   **/
  senateMembers: {
    /**
     * The current membership, stored as an ordered Vec.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The current prime member, if one exists.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Sudo`'s storage queries
   **/
  sudo: {
    /**
     * The `AccountId` of the sudo key.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    key: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, FixedBytes<32>],
      ) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageOldRequestStatus | undefined,
      H256
    >;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageRequestStatus | undefined,
      H256
    >;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<
      Rv,
      (arg: [H256, number]) => Bytes | undefined,
      [H256, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<
      Rv,
      (arg: number) => Array<PalletSchedulerScheduled | undefined>,
      number
    >;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<
      Rv,
      (arg: FixedBytes<32>) => [number, number] | undefined,
      FixedBytes<32>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Registry`'s storage queries
   **/
  registry: {
    /**
     * Identity data by account
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletRegistryRegistration | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletRegistryRegistration | undefined,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Commitments`'s storage queries
   **/
  commitments: {
    /**
     * Tracks all CommitmentOf that have at least one timelocked field.
     *
     * @param {Callback<Array<[number, AccountId32]>> =} callback
     **/
    timelockedIndex: GenericStorageQuery<
      Rv,
      () => Array<[number, AccountId32]>
    >;

    /**
     * Identity data by account
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletCommitmentsRegistration | undefined> =} callback
     **/
    commitmentOf: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => PalletCommitmentsRegistration | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    lastCommitment: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    lastBondsReset: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<Array<[Bytes, bigint]> | undefined> =} callback
     **/
    revealedCommitments: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => Array<[Bytes, bigint]> | undefined,
      [number, AccountId32]
    >;

    /**
     * Maps (netuid, who) -> usage (how many “bytes” they've committed)
     * in the RateLimit window
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletCommitmentsUsageTracker | undefined> =} callback
     **/
    usedSpaceOf: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => PalletCommitmentsUsageTracker | undefined,
      [number, AccountId32]
    >;

    /**
     *
     * @param {Callback<number> =} callback
     **/
    maxSpace: GenericStorageQuery<Rv, () => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AdminUtils`'s storage queries
   **/
  adminUtils: {
    /**
     * Map PrecompileEnum --> enabled
     *
     * @param {PalletAdminUtilsPrecompileEnum} arg
     * @param {Callback<boolean> =} callback
     **/
    precompileEnable: GenericStorageQuery<
      Rv,
      (arg: PalletAdminUtilsPrecompileEnum) => boolean,
      PalletAdminUtilsPrecompileEnum
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `SafeMode`'s storage queries
   **/
  safeMode: {
    /**
     * Contains the last block number that the safe-mode will remain entered in.
     *
     * Set to `None` when safe-mode is exited.
     *
     * Safe-mode is automatically exited when the current block number exceeds this value.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    enteredUntil: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Holds the reserve that was taken from an account at a specific block number.
     *
     * This helps governance to have an overview of outstanding deposits that should be returned or
     * slashed.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    deposits: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number]) => bigint | undefined,
      [AccountId32, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Ethereum`'s storage queries
   **/
  ethereum: {
    /**
     * Current building block's transactions and receipts.
     *
     * @param {Callback<Array<[EthereumTransactionTransactionV2, FpRpcTransactionStatus, EthereumReceiptReceiptV3]>> =} callback
     **/
    pending: GenericStorageQuery<
      Rv,
      () => Array<
        [
          EthereumTransactionTransactionV2,
          FpRpcTransactionStatus,
          EthereumReceiptReceiptV3,
        ]
      >
    >;

    /**
     * The current Ethereum block.
     *
     * @param {Callback<EthereumBlock | undefined> =} callback
     **/
    currentBlock: GenericStorageQuery<Rv, () => EthereumBlock | undefined>;

    /**
     * The current Ethereum receipts.
     *
     * @param {Callback<Array<EthereumReceiptReceiptV3> | undefined> =} callback
     **/
    currentReceipts: GenericStorageQuery<
      Rv,
      () => Array<EthereumReceiptReceiptV3> | undefined
    >;

    /**
     * The current transaction statuses.
     *
     * @param {Callback<Array<FpRpcTransactionStatus> | undefined> =} callback
     **/
    currentTransactionStatuses: GenericStorageQuery<
      Rv,
      () => Array<FpRpcTransactionStatus> | undefined
    >;

    /**
     *
     * @param {U256} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: U256) => H256, U256>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `EVM`'s storage queries
   **/
  evm: {
    /**
     *
     * @param {H160} arg
     * @param {Callback<Bytes> =} callback
     **/
    accountCodes: GenericStorageQuery<Rv, (arg: H160) => Bytes, H160>;

    /**
     *
     * @param {H160} arg
     * @param {Callback<PalletEvmCodeMetadata | undefined> =} callback
     **/
    accountCodesMetadata: GenericStorageQuery<
      Rv,
      (arg: H160) => PalletEvmCodeMetadata | undefined,
      H160
    >;

    /**
     *
     * @param {[H160, H256]} arg
     * @param {Callback<H256> =} callback
     **/
    accountStorages: GenericStorageQuery<
      Rv,
      (arg: [H160, H256]) => H256,
      [H160, H256]
    >;

    /**
     *
     * @param {H160} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    suicided: GenericStorageQuery<Rv, (arg: H160) => [] | undefined, H160>;

    /**
     *
     * @param {Callback<Array<H160>> =} callback
     **/
    whitelistedCreators: GenericStorageQuery<Rv, () => Array<H160>>;

    /**
     *
     * @param {Callback<boolean> =} callback
     **/
    disableWhitelistCheck: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `EVMChainId`'s storage queries
   **/
  evmChainId: {
    /**
     * The EVM chain ID.
     *
     * @param {Callback<bigint> =} callback
     **/
    chainId: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `BaseFee`'s storage queries
   **/
  baseFee: {
    /**
     *
     * @param {Callback<U256> =} callback
     **/
    baseFeePerGas: GenericStorageQuery<Rv, () => U256>;

    /**
     *
     * @param {Callback<Permill> =} callback
     **/
    elasticity: GenericStorageQuery<Rv, () => Permill>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Drand`'s storage queries
   **/
  drand: {
    /**
     * the drand beacon configuration
     *
     * @param {Callback<PalletDrandBeaconConfiguration> =} callback
     **/
    beaconConfig: GenericStorageQuery<Rv, () => PalletDrandBeaconConfiguration>;

    /**
     * map round number to pulse
     *
     * @param {bigint} arg
     * @param {Callback<PalletDrandPulse | undefined> =} callback
     **/
    pulses: GenericStorageQuery<
      Rv,
      (arg: bigint) => PalletDrandPulse | undefined,
      bigint
    >;

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    lastStoredRound: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Defines the block when next unsigned transaction will be accepted.
     *
     * To prevent spam of unsigned (and unpaid!) transactions on the network,
     * we only allow one transaction per block.
     * This storage entry defines when new transaction is going to be accepted.
     *
     * @param {Callback<number> =} callback
     **/
    nextUnsignedAt: GenericStorageQuery<Rv, () => number>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Crowdloan`'s storage queries
   **/
  crowdloan: {
    /**
     * A map of crowdloan ids to their information.
     *
     * @param {number} arg
     * @param {Callback<PalletCrowdloanCrowdloanInfo | undefined> =} callback
     **/
    crowdloans: GenericStorageQuery<
      Rv,
      (arg: number) => PalletCrowdloanCrowdloanInfo | undefined,
      number
    >;

    /**
     * The next incrementing crowdloan id.
     *
     * @param {Callback<number> =} callback
     **/
    nextCrowdloanId: GenericStorageQuery<Rv, () => number>;

    /**
     * A map of crowdloan ids to their contributors and their contributions.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    contributions: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => bigint | undefined,
      [number, AccountId32]
    >;

    /**
     * The current crowdloan id that will be set during the finalize call, making it
     * temporarily accessible to the dispatched call.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    currentCrowdloanId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Storage for the migration run status.
     *
     * @param {BytesLike} arg
     * @param {Callback<boolean> =} callback
     **/
    hasMigrationRun: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => boolean,
      Bytes
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}
